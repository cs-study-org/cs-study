# 1장 컴퓨터 내부의 언어 체계
**프로그래머가 할일** ⇒ 컴퓨터에게 명령을 내리는 것
>- 컴퓨터는 사람의 말을 알아듣지 못한다.
>- 사람은 컴퓨터의 말을 배워야 한다.

## <br>언어란 무엇인가
**언어**란 의사소통에 필요한 매개체

>- 모든 언어의 의미는 **기호의 집합**으로 **인코딩** 된다
>- 언어가 제대로 작동하기 위해서는 의사소통 당사들이 모두 같은 **문맥**을  공유하여 같은 기호의 뜻을 부여 할 수 있어야 한다.

⇒ **즉 언어는 <U>기호의 집합으로 인코딩 되지만 동일한 기호의 구분을 하기 위해서는 문맥이 필요</U>하다.**

## <br>문자 언어

>- 사람이 사용하는 언어 = 자연어
>- 컴퓨터가 사용하는 컴퓨터 언어

자연어와 컴퓨터 언어 모두 문자 언어의 틀을 이루어 사용된다.

문자 언어의 세가지 구성 요소

- **기호가 들어가는 상자**
- **상자에 들어갈 기호**
- **상자의 순서**

ex) 
| 김 | 지 | 용 |
| --- | --- | --- |
- 기호가 들어갈 상자
- 상자에 들어갈 기호 ( 김, 지, 용 )
- 상자의 순서 ( 김 → 지 → 용 )

## <br>비트
상자|상자|상자|
|-|-|-|
| 김 | 지 | 용 |
| - | - | - |   

- 기호가 들어갈 상자
    - 자연어에서는 ⇒ **단어** ( 김 ) , ( 지 ), ( 용 )
    - 컴퓨터 언어 ⇒ **비트** (Binary + Digit)
        - Binary( 두가지 부분을 이루어진 대상을 뜻함)
        - Digit (일상생활에서 사용하는 10진수 표현 10가지 기호 )<br><br>
        
- 상자에 들어갈 기호
    - 자연어에서는 = **기호** ( ㄱ, ㅣ , ㅁ)
    - 컴퓨터 언어에서는 = **모스 부호** ( 점 (.) , 선(-) )
    <br><br>
- 상자의 순서
    - 자연어에서는 [ (김) - (지) - (용) ]
        - ‘김지용’ 이라는 사람을 의미한다.
    - 컴퓨터 언어에서는 [ (.) (-) ]
        - ‘[ (.) (-) ]’ 점 - 선 은 A를 의미한다.
        
    
기호라는 개념은 추상적이기 때문에 실제 기호가 무엇이든 상관이 없다   
    - 기호가 켜짐/꺼짐, 낮/밤 일수도 있다.
    
>⇒ 중요한 점은 언어는 <U>**문맥 없이는 제대로 동작할 수 없다**</U>는 것이다.    
    
>⇒ **즉 기호가 무엇이냐에 따라서 보다는 <U>지정된 문맥상에서 그 기호가 뜻하는 바</U>가 중요한 것이다.**
    

## <br>논리 연산
* 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작을 의미

* 산술 연산 ( 가 , 감 , 승 , 제 ) 을 제외한 문자나 숫자에 대해 여러가지 연산을 의미하며 논리 연산에서 사용되어지는 데이터는 <U>**숫자가 아닌 비트나 바이트 단위로 취급**</U>한다.


    <br>
- 불리언 대수
    - **대수** : 대수학 ( 개개의 숫자 대신 숫자를 대표하는 일반적 문자를 사용하여 수의 관계, 성질, 계산 법칙 따위를 연구하는 학문 )
    - **불리언 대수** : 조지 불이 창시한 논리 수학, 명제의 참과 거짓을 판단하는 논리 연산을 다루는 대수
        - 논리 회로 설계에 이용되어 컴퓨터 동작의 기초과 됨
        - 논리의 참 거짓을 갖는 논리 변수들의 상관 관계를
            - 논리 부정 ( NOT )
            - 논리 곱 ( AND )
            - 논리 합 ( OR )
            - 베타적 OR ( XOR )
            
               등의 논리 연산을 이용해 논리식으로 표현한다.
            
        
- 불리언 대수의 연산
    - 불 연산자에는 NOT(부정), AND(논리곱), OR(논리합)으로 구성
        - NOT : 논리적 반대를 의미, 참과 거짓을 뒤집는다.
            
            ![not진리표](https://user-images.githubusercontent.com/81874493/146687577-7bdd6c17-573b-4c7c-8c59-60c283f1f761.png)

            
            <NOT 진리표> 
            <br><br>
        - AND : 둘 이상의 비트에 작용하며 불대수에서의 AND와 곱셈은 동일하게 정의된다.
            
            ![and진리표](https://user-images.githubusercontent.com/81874493/146687584-739d5d3f-c746-40b9-8431-530f69c3737e.png)

            
            <AND 진리표> 
            <br><br>
        
        - OR : 둘 이상의 비트에 작용하며 불대수에서의 OR과 덧셈은 동일하게 정의된다.
            
            ![or진리표](https://user-images.githubusercontent.com/81874493/146687591-5385f01a-970f-4a4e-9044-c4570a2da9cd.png)

            <OR 진리표> 
            <br><br>
        
        - XOR : 둘 이상의 비트에 작용하며 두 명제 여부가 다를 때 참 값을 돌려준다.
            
            ![xor진리표](https://user-images.githubusercontent.com/81874493/146687600-f2d232ee-3d06-4d7f-9c2e-a0e8eebbf6aa.png)

            
            <XOR 진리표> 
            
            - XOR연산을 다른 연산들을 결합해 동일한 연산을 만들 수 있다.
                - A XOR B = (A OR B) AND ( NOT(A AND B))
           <br><br><br>
        
        - 드모르간의 법칙
            
            드모르간의 법칙 : 드모르간이 발견한 불리언 대수에 적용할 수 있는 새로운 법칙을 의미한다.
            
            <드모르간의 법칙>
            
            - A AND B ==  NOT ( NOT A OR NOT B)
            
               ⇒ NOT을 충분히 사용하여 AND 연산을  OR 연산으로 대체할 수 있다.
            
               ![드모르간](https://user-images.githubusercontent.com/81874493/146687609-fc274796-a132-4cd7-b117-3ea2830ccf4d.png)

            <br><br>
            <드모르간의 법칙은 언제 사용 할까?> 
            
              - 컴퓨터 프로그래밍에 있어 정논리와 부논리를 기술할때
              - 예시 ( 조건문 )
                
                ```java
                /* 놀이기구를 탈 수 있는 조건은
                키 140 이하 
                나이 20 세 이하
                */
                
                if( !(age >=20 && height >=140)){
                // 놀이기구 사용 가능
                }
                
                // 드모르간의 법칙을 이용하여 
                //&& 연산을 ||연산으로 변경

                
                if( age<20 || height <140 ){
                // 놀이기구 사용가능
                }
                
                ```
                
                - `if( !(age >=20 && height >=140))` 
                - 연산에 추가 연산이 붙게 된다면 가독성이 떨어지고 유지보수가 어려워 질 수 있다
                - 그래서 드모르간의 법칙을 활용하여 리팩토링 한다.
                <br><br>
            

## 정수를 비트로 표현하는 방법
    비트를 사용하여 수를 표현하는 방법을 알아보자

- 양의 정수 표현
    - 10진수 체계
        - 밑을 10으로 하는 수의 체계

            ex) 5028 = 5 * 10^3 + 0* 10^2 + 2*10^1 + 8*10^0
            
            | 10 ^3 | 10 ^2 | 10^1 | 10^0 |
            | --- | --- | --- | --- |
            | 5 | 0 | 2 | 8 |
            
            10 진수 체계에서 5028은 4 자리 숫자라고 할 수 있다.
            <br><Br>
            
    - 2진수 체계
        - 밑을 2로 하는 수의 체계
            
            ex) 5028  
            
            | 2^12 | 2^11 | 2^10 | 2^9 | 2^8 | 2^7 | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
            | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
            | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
            
            2 진수 체계에서 5028은 13비트 수 라고 할 수 있다.
            <br><br>
            
    - 2진수로 표현할 수 있는 값의 범위
        
        
        | 비트 개수 | 값의 개수 | 값의 범위 |
        | --- | --- | --- |
        | 4 | 16 | 0~15 |
        | 8 | 256 | 0~255 |
        | 12 | 4096 | 0~4095 |
        | 16 | 65536 | 0~65535 |
        | ... |  |  |
        | 64 | 18,446,744,073,709,551,616 | 0~18,446,744,073,709,551,615 |
        <br>
        
    - LSB 와 MSB
        
        ![LsbMsb](https://user-images.githubusercontent.com/81874493/146687618-a6971a44-ed06-4b78-a011-534a6dba3953.png)

        
        - 2진수에서 가장 왼쪽의 비트 = 가장 큰 유효 비트 MSB
            
            ⇒ 2진수의 값의 비트중 **변경시 가장 크게 변하는 비트**
            
        - 2진수에서 가장 오른쪽의 비트 = 가장 작은 유효 비트 LSB
            
            ⇒ 2진수의 값의 비트중 변경시 가장 작게 변하는 비트
            <br><br>
    - 2진 산술 연산
        
        
        - 논리 연산을 사용한 2진 덧셈 (AND, XOR)
            
            (연산은 LSB 자리부터 시작)
            
            1. XOR연산한 값을  위치에 넣는다
            2.  AND연산한 값을 올림 한다.
                

                ![2진 덧셈](https://user-images.githubusercontent.com/81874493/146687630-914e84b8-1fc8-41f2-b461-037d171f8ef0.png)

                <br><br>
                - 용어 정리
                    - 오버플로우( Overflow )
                        
                        ⇒ 사용할 비트의 개수로 표현할 수 있는 범위를 벗어남( MSB에서 올림이 발생)
                        
                        - 오버플로우 발생시
                            
                            ⇒ 컴퓨터에서 조건코드 레지스터에 오류 정보를 담는다.
                            
                            ⇒ 오류정보에는 오버플로 비트 (MSB에서 올림한 값 ) 이 저장된다.
                            <br><br>
                    - 언더플로우 ( UnderFolow)
                        
                        ⇒ MSB에서 1을 빌려오는 경우
                        
                        - 언더 플로우 발생시
                            
                            ⇒ 컴퓨터에서 조건코드 레지스터에 오류 정보를 담는다.
                            
                            ⇒ 오류정보에는 언더플로우 비트 (MSB에서 빌린 값 ) 이 저장된다.
                            
        
    - 2진 음수 표현
        
        비트에 대해 덧셈 연산 뿐 아니라 뺄셈 연산 또한 문제 해결에 필요로 하는 경우가 있다.
        
        비트에 대한 뺄셈 연산을 하는 방법에는
        
        <U>**뺄셈 연산의 비트의 부호를 변경하여 덧셈 연산**</U>을 하면 된다.
        <br><br>
        - 부호와 크기
            
            양수와 음수를 구별하기 위해서는 부호(sign)을 사용한다.
            
             2진수에서 음수를 표현하는 방법에는 부호와 크기 표현법을 사용한다.
            
            - 부호와 크기 표현법
                - 가장 왼쪽 비트 (MSB 비트)를 부호에 사용
                    
                    ( 2진수에 대해 마지막 비트가 0이면 양수, 1이면 음수)
                    
                - 단점
                  1. 부호를 결정하는데  0,1 두 가지 표현을 사용해 낭비
                    1. 부호의 크기 표현법을 사용하면 XOR, AND 연산을 사용할 수 없다.
                    <br><br>
        - 1의 보수
            
            음수를 표현하는 또 다른 방법
            
            - 1의 보수 표현법
                
                ⇒ 1의 보수 표현법으로 음수를 표현하는 방법은
                
                ⇒ 양수의 모든 비트를 뒤집는 방법을 사용
                
                - 단점
                    1. 0을 두가지 방식으로 표현한다.
                    2. 1의 보수 표현법으로 덧셈 연산이 복잡하다.
                <br><br>
        
        >현대 컴퓨터에서는 추가적인 하드웨어의 비용 문제로 부호와 크기표현법 이나 1의 보수표현법을 사용하지 않는다.
        
        >현대 컴퓨터에서는  <U>**2의 보수 표현법을 사용하여 음수를 표현하고 덧셈연산을 사용하는 방식을 사용**</U>하고 있다.
        
        <br><br>
        

        - 2의 보수
            
            2의 보수 표현법
            
            - -1 찾기
    
                ![2의보수](https://user-images.githubusercontent.com/81874493/146687639-380b4547-c1f9-43e6-99b5-c0ba35fb1104.png)

                -1을 구한 패턴을 통해 음의 비트를 구하는 방법을 사용한다.
                
                1. 어떤 수의 비트를 뒤집는다( 각 비트의 NOT을 취함)
                2. 1을 추가한다
                3. 이때 MSB에서 올림 발생 시 올림 값은 버린다. 
                <br>
                < 현재 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법 >
                

## 실수를 표현하는 방법



실수 즉 소수점이 붙어있는 수는 어떻게 2진수로 변환할까?

- 고정 소수점 표현 방식
    
    ⇒  소수점의 정수부와 소수부를 나누어 2진수로 변환하는 방식
    <br><br>
    - 변환법
        - 정수부
            
            ⇒ 정수부는 2로 나누어가며 1과 0을 뽑아내어 변환
            
            ⇒ 7 (변환)⇒ 111
            
            <img width="203" alt="고정 소수점 표현" src="https://user-images.githubusercontent.com/81874493/146687653-5cc786ea-1fad-415f-98ad-d8d2a5d3e21b.png">

            <br><br>
        - 실수부
            
            ⇒ 실수부는 2로 곱해가며 1이나 0을 뽑아내어 변환
            
            ⇒ 0.625 *2 = 1.25  (1 추출)
            
            ⇒ 0.25 * 2 = 0.5 (0 추출)
            
            ⇒ 0.5 * 2 = 1.0 (1 추출) 
            
            ⇒ 결과 0.101
            <br><br>
        - 고정 소수점 표현 방식 정리
            
            ![가수부 작성](https://user-images.githubusercontent.com/81874493/146687667-cee28563-6051-4704-89cf-72706cea936c.png)

            - 16비트 체계 사용 가정한다 했을때
                - 맨 앞자리 부호비트 0⇒양수 , 1⇒ 음수
                - 소수점 위치를 미리 정해두어 정수부와 소수부를 2진수로 표현
                - 소수부는 앞에서 부터 채우며 남는 자리는 0으로 채움
            - 고정 소수점 표현 방식
                - 장점 : 구하기 편리
                - 단점 : 사용 비트수 대비 표현 가능 수의 범위와 정밀도가 낮음
                - 범용 시스템에서는 거의 쓰이지 않고 디지털 신호 처리장치(DSP) 등의 일부 컴퓨터에서 사용 중이다.
        
    
- 부동 소수점 표현 방식
    
    부동 소수점 표현 방식에서는 2진수로 변환한 결과에 몇가지 추가 과정을 거친다.
    
    - 정규화
        
        2진수에서의 정규화는 2진수를 [1.xxx... * 2^n] 꼴로 변환하는 것을 의미한다.
        
        ex) 111.101 (정규화)⇒ 1.11101 * 2^2
        
    - IEEE 754 부동 소수점 표현
        
        IEEE 표준에 따르면 부동소수점 방식으로 실수를 저장하는 데는 32비트, 또는 64비트가 사용되며 32비트 기준으로 아래 그림과 같은 구조를 가진다.
        
        ![부동소수점 표현](https://user-images.githubusercontent.com/81874493/146687676-4f30d788-c620-4120-ad2d-d72d9dfec932.png)

        - 변환 방법
            - 7.625 (2진수 변환)⇒ 111.101
            - 111.101 (정규화)⇒  1.11101 * 2^2
            - 1.11101 * 2^2 에서 소수부만 그대로 가수부에 작성
                
                ![가수부 작성](https://user-images.githubusercontent.com/81874493/146687684-c8d7f77b-20a8-428a-9c51-d2dc2c7b2289.png)

            - 2^2 에서 지수부의 2를 가져와 bias 값을 더한다
                
                (IEEE 표준 32 비트 사용시 bias는 127 이며 지수가 음수가 될 수 있어 bias 값을 더하여 2진수로 변환한다)
                
            - 2+127 = 129 ⇒ 2진수 변환 ⇒ 10000001 ⇒ 작성
                
                ![고정소수점표현방식](https://user-images.githubusercontent.com/81874493/146687690-55e0cb7d-c48f-40a8-9548-94495d048198.png)

        - 정리
            - 부동소수점 표현 방식은 고정소수점 표현방식에 비해 비트 수 대비 표현 가능수의 범위와 정밀도 측면에 우위에 있다.
            - 현재 bias 값과 보잡한 과정이 있지만 현재 컴퓨터 시스템에서 부동 소수점을 이용해 실수를 표현하고 있다.
            <br><Br>

## BCD ( Binary-Coded Decimal )

BCD란 binary-coded decimal의 약자로 ‘이진화 십진법’ 이라는 뜻이다.

>컴퓨터는 0 또는 1로 모든걸 표현하지만 사람은 10 진수를 표현을 주로 사용하고 있기 때문에 사람이 보기에 2진수는 불편하다.

>컴퓨터로 보내기위해서는 2진수 체계로 보내야하고 

>사람이 보기에 쉽도록 10진수 체계로 보여주어야 한다

>이 사이 변환과정에 대한 다양한 방법론이 있는데

>그중 하나가 BCD 이다.

- BCD 변환법
    - 10진수의 자리수 마다 2진수로 변환하는 방법
    - 10진수는 한자리에 0~9 값이 들어가기때문에 2진수로 표현하기 위해서는 4bit가 필요하다
    - 예시
        - 15
            - 1 ( 0001 ) , 5 ( 0101 ) [자리수 마다 4bit로 표현]

 

- 컴퓨터 초창기에는 BCD코드를 많이 사용 but,
- 현재 데이터 통신에서는 ASCII 코드가 가장 널리 사용되고 있다
- BCD는 현재 컴퓨터와 상호 작용하는 장치 중 디스플레이나 가속도 센서 등에서 사용되어지는 경우가 있다.
  <br><br>

## 8,16 진수 다루기 

- 8진 표현법
    
    표현할 수 있는 숫자가 **0,1,2,3,4,5,6,7** 로 **8개**라서 8진수
    
    ![8진 표현법](https://user-images.githubusercontent.com/81874493/146687701-2b70dbcb-e246-463c-8e7f-5051b5f05760.png)

    - 8진수에서는 10은  10진수에서 8이라는 값에 해당한다,
    - 8진수에서 11은 10진수에서 9라는 값에 해당한다.
    - 8진수에서 12는 10진수에서 10이라는 값에 해당한다.
    <br><br>
      - 8진수를 10진수로 변환법
                    
        ![8에서10진수](https://user-images.githubusercontent.com/81874493/146687729-1a2992fb-5eb9-4510-8f49-b9a968047416.png)

        
      - 10진수를 8진수로 변환법
        
        ![10에서8진수](https://user-images.githubusercontent.com/81874493/146687747-3d25c085-3e92-4a45-938e-bc3f900323b1.png)
        <br><br>

- 16진 표현법
    
    표현할 수 있는 숫자 **0,1,2,3,4,5,6,7,8,9** 에 문자 **A,B,C,D,E,F** 까지 **16개**라서 16진수이다.
    
    ![16진수표현법](https://user-images.githubusercontent.com/81874493/146687754-7903fa0a-41a6-443a-93a1-75332a8add14.png)

    | 16진수 | 10진수 |
    | --- | --- |
    | A | 10 |
    | B | 11 |
    | C | 12 |
    | D | 13 |
    | E | 14 |
    | F | 15 |
    <br>
    - 16진수를 10진수 변환법
                    
     ![16에서10](https://user-images.githubusercontent.com/81874493/146687757-3ff5b1ee-e0ac-41e2-921f-b89237e5fe02.png)
   
     <br><br>
                    
    - 10진수를 16진수로 변환법
        
        ![10에서16](https://user-images.githubusercontent.com/81874493/146687769-677321a4-3999-4bac-a66d-ee0249db672f.png)
  
        <br><br>

- 진수의 사용 이유
    - 컴퓨터는 진수의 표현을 전기적인 신호로 판단
    <br><Br>
    - 2진수
        - 컴퓨터가 기본적으로 사용하는 진수 체계
        <br><br>
    - 8진수
        - 8은 2의 3승이기 때문에 2진수와 3대 1 변환이 가능
        <br><br>
    - 16진수
        - 16은 2의 4승이기 때문에 2진수와 4대 1 변환이 가능
        <br><br>
    
    >10진수 0~15 까지 표현하는데에
    
    >2진수는 1과0의 조합으로 긴 나열이 필요
    
    >16진수는 1,2,3,4,5,6,7,8,9,10,A,B,C,D,E,F 이렇게 한자리로 표현 가능
    <br><br>

       ⇒ 2진수보다 효율이 좋음
    
       ⇒ 작은수면 모르지만 억 단위로 넘어가는 수라면 16진수로 더 적은 숫자로 표현이 가능하다
    
       ⇒ 이는 곧 메모리 영역의 부담을 줄일 수 있다.
    <br>
- 2진수, 8진수, 16진수의 데이터 표현 방법
    - 2진수 대입하고자 하는 값에 0b를 붙인다
    - 8진수 대입하고자 하는 값에 0을 붙인다
    - 16진수 대입하고자 하는 값에 0x를 붙인다
        
        ```java
        int a = 100 ; // 10진수
        int b = 0b111010 // 2진수
        int c = 0132 // 8진수
        int d = 0x3A // 16진수
        ```
        <br>

## 데이터 자료의 구성 단위
<img width="697" alt="자료구성단위" src="https://user-images.githubusercontent.com/81874493/146687794-9440396e-b778-4ee8-8878-42469caecdd6.png">

<br>

- 자료 구성 단위의 크기 비교
    
    Bit < Nibble < Byte < Word < Half Word < Full Word < Double Word < Field < Record(Logical Record) < Block(Physical Record) < File < DB
    
    - 워드 이하의 단위 ( 비트, 니블, 바이트, 워드) 는 컴퓨터 내부에서 사용하는 단위로 데이터를 칭한다.
    - 필드부터 사람이 인식할 수 있는 논리적 단위 이다.
    <br><br>
    

## 텍스트의 표현


- 인코딩 / 디코딩의 개념
    
    인코딩(부호화)은 정보를 어떠한 목적을 가지고 또 다른 형태의 정보로 변환(Transform)시키는 행위를 의미
    
    ![인코딩디코딩](https://user-images.githubusercontent.com/81874493/146687814-69a2e6b3-f99b-40b3-8486-2f0a400e4ec5.png)

    
    
    인코딩 : 정보를 다른정보로 변환하는것
    
    디코딩 : 변환된 정보를 원래 정보로 다시 되돌리는것
    
    ex) 
    
    >문자들을 모아 문자집합 즉 문자열을 만드는것 ⇒ 인코딩
    
    >문자열을 컴퓨터가 이해할 수 있는 비트 단위로 만드는것 ⇒ 인코딩
    
    >컴퓨터가 이해하는 비트 단위에서 문자열로 되돌리는것 ⇒ 디코딩
    
    <br>
- 아스키 코드 (ASCII)
    >- 7bit (2의 7승 : 128 가지 문자)
    >- American Standard Code for Information Interchange
    >- **컴퓨터의 기본 저장 단위는 바이트(byte)이고, 1byte는 8bit이다.**
    >- 1byte에는 2의 8승에 해당하는 256개의 고유한 값을 저장할 수 있다.
    >- 아스키코드는 7비트로 128개의 고유한 값을 저장한다. (문자 하나당 숫자 하나를 매핑, 1비트는 별도의 목적을 위해서 사용)
    >- ASCII에서는 영어만을 고려하여 만들어졌고, 일본어 중국어 등 다른 언어는 표현이 불가능하다.
    >- 로마자 및 특수 기호(한글 포함 안됨)

    <br>    
- 유니 코드(Unicode)
    >- 2byte (2의 16승 : 65,536가지 문자)
    >- 이와 같이 7bit ASCII 코드에 담을 수 없는 문자를 정의하기 위해서 2byte 국제표준코드 유니코드가 등장하였다.
    >- 2byte는 16bit로 2의 16승 약 6만 5천개의 문자를 저장할 수 있다.
    >- 유니코드로 ASCII 코드를 포용 가능하다.
    >- **UNICODE**는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현할 수 있도록 고안된 코드 조합이다.
    >- 유니코드는 전세계 거의 모든 문자를 2bytes 숫자로 1:1 매핑 시키는 방식을 말하고, 유니코드를 표현하는 여러가지 인코딩 방식들이 존재한다. (ex utf-8)
    
    <br>
- UTF-8
    >- 유니코드 부호화 방식 (8bit 기반 )
    >- 가변 길이 유니코드 인코딩 시스템
    >- 특정 문자 집합 안의 문자들을 컴퓨터 시스템 안헤서 사용할 목적으로 일정한 범위 안의 정수 (코드값) 들로 변환하는 방법
    >- ASCII 코드의 언어는 1byte로 나타내며, 한글의 경우 3byte로 나타낸다.
    
    <br>
- URL 인코딩/디코딩
    >- **URL 인코딩이란 URL에서 URL로 사용할 수 없는 문자 혹은 URL로 사용할 수 있지만 의미가 왜곡될 수 있는 문자들을 '%XX'의 형태로 변환하는 것**을 말한다.
    >- XX는 16진수 값
    >- URL 디코딩이란 변환된 URL을 다시 원래의 형태로 되돌리는 것
    
    <br><br>
    - URL 인코딩/디코딩은 왜 필요한 것일까?
        
        ![url인코딩](https://user-images.githubusercontent.com/81874493/146687827-90f9101c-4336-4bf0-a948-3210718999c4.png)

        - 인터넷을 통해 전송할 수 있는 문자는 **오로지 ASCII 문자**이기 때문
        - 한글은 ASCII 문자가 아니므로 변환이 필요하다. 그리고 이때 변환하는 규칙은 **UTF-8**을 따른다
        - UTF-8에 따르면 한글 문자 1개는 3바이트로 인코딩 된다. 따라서 '피그'는 6바이트로, '브라더'는 9바이트로 인코딩 된 모습을 볼 수 있다.
        - ASCII 문자라 하더라도 예약된 의미를 가지고 있는 문자의 경우, 그 문자 자체의 의미를 전달하고 싶은 경우에는 이스케이프 처리가 필요하기 때문이다('/', '&', '=' 등)
        - 이러한 문자들을 문자 그 자체의 의미로서 전달하고 싶다면 이스케이프 처리가 필요하다
        
<br>

## 색을 표현하는 방법


![색표현](https://user-images.githubusercontent.com/81874493/146687838-84034a93-1d41-4dba-b376-d9b64697c887.png)

- RGB 컬러 모델
    - R(빨간색) G(녹색) B(파란색) 3요소를 사용하여 다른 색을 정의하는 모델이다.
    - TV, 모니터와 같은 빛을 이용하여 색을 표현하는 장치에서 주로 사용한다.
    - (R,G,B)로 색을 표현할때에 (0,0,0)은 검은색, (1,1,1)은 흰색을 나타내며 검은색과 흰색을 잇는 선은 밝기값을 나타낸다. 

<br><br>

## 참고 문헌

[논리연산 참고 문헌](https://life-of-panda.tistory.com/16)

[논리연산 종류 참고 문헌](https://namu.wiki/w/%EB%85%BC%EB%A6%AC%20%EC%97%B0%EC%82%B0?from=%EB%B6%88%20%EC%97%B0%EC%82%B0)

[드모르간 참고 문헌](https://bite-sized-learning.tistory.com/358)

[실수를 2진수로 표현 참고 문헌](https://gsmesie692.tistory.com/94)

[8진수 16진수 다루기 참고 문헌](https://itbeginner2020.tistory.com/17)

[인코딩의 이해 참고 문헌](https://redisle.tistory.com/14) [ <U>**한번 읽어보길 추천드립니다 !**</U> ]
                    
[RGB 모델 참고 문헌](https://mumala.tistory.com/4)
