# 컴퓨터 내부의 언어체계

- [컴퓨터 내부의 언어체계](#컴퓨터-내부의-언어체계)
  - [언어](#언어)
  - [문맥에 따라 달라지는 표현법](#문맥에-따라-달라지는-표현법)
  - [영역과 연산](#영역과-연산)
    - [영역](#영역)
    - [정수 연산](#정수-연산)
    - [실수 연산](#실수-연산)
  - [2진수 실수](#2진수-실수)
    - [부동 소수점 수](#부동-소수점-수)
    - [IEEE 754 표준안](#ieee-754-표준안)
    - [무한 2진 실수(π) 를 IEEE 754 표준 `binary32(float)`로 표현](#무한-2진-실수π-를-ieee-754-표준-binary32float로-표현)
  - [2진수 텍스트](#2진수-텍스트)
    - [유니 코드(π)를 UTF-8로 인코딩](#유니-코드π를-utf-8로-인코딩)
  - [텍스트로 수 표현](#텍스트로-수-표현)
  - [`MSB`를 식별자로 메모리 주소값을 찾는 예제](#msb를-식별자로-메모리-주소값을-찾는-예제)
  - [참고문헌](#참고문헌)

## 언어

언어는 편의를 제공하기 위해 사용한다.

언어가 제대로 작동하려면 `기호의 집합(Encoding)`과 `같은 문맥(Context)`이 필요하다.

> 예로, camisole이라는 기호의 집합이 미국과 프랑스권에서 다른 문맥으로 사용된다면, 제대로 언어가 작동하지 않는다.

하지만, 우리는 언제나 같은 문맥을 명확히 식별할 수 있는 것은 아니며 컴퓨터 상에서도 다양한 정의로 사용된다.

## 문맥에 따라 달라지는 표현법

우리가 통상적으로 4비트에서 0부터 15까지 16가지 수를 표현하지만, 이 표현은 다양한 문맥에서 새로 정의할 수 있다.

| 2진수 | 부호와의 크기 | 1의 보수 | 2의 보수 |
| :---- | :-----------: | :------: | :------: |
| 1111  |      -7       |    -0    |    -1    |

## 영역과 연산

수(數)는 영역과 연산이라는 두 가지 속성을 가진다.

### 영역

|      | 범위[^range] | 정밀도[^precision] |
| :--- | :----------: | :----------------: |
| 정수 |      O       |         X          |
| 실수 |      O       |         O          |

[^range]: 데이터를 표현할 수 있는 최댓값과 최솟값을 의미한다.

[^precision]: 2개의 연속적인 데이터 값 사이의 거리를 의미한다.

### 정수 연산

정수 연산에서 각 비트를 MSB ← LSB 방향으로 결과가 1보다 크면 1을 다음 자리로 옮긴다.

**이때, 덧셈의 결과가 사용하는 비트 갯수의 범위를 벗어나면 어떻게 될까?**

overflow가 발생한다. overflow는 MSB에서 올림이 발생했다는 뜻이다.

> 예로, 4비트 덧셈에서 1001 + 1000 = 10001을 기대하겠지만 0001이 된다.

이럴 경우를 대비해 컴퓨터에는 `조건 코드 레지스터`에 overflow bit 정보를 담아둔다. 이와 반대되는 개념인 underflow는 반대로 MSB에서 1을 빌려온다.

### 실수 연산

실수 연산의 결과가 양수 최댓값 보다 크거나 음수 최솟값 보다 작으면 overflow가 발생하는데, 표현을 할 수 없어 심각한 오류가 된다.

반대되는 개념으로 양수 최솟값과 음수 최댓값의 사이의 0으로 가까이 가는 수(극한)일때, underflow가 발생하는데, 이는 심각한 오류는 아니다. 왜냐면, 0의 근사값으로 대체할 수 있기 때문이다.

## 2진수 실수

### 부동 소수점 수

컴퓨터에서 실수는 아주 커다란 숫자나 아주 작은 숫자를 효율적인 자원의 상태에서 연산하기 위해서 지원하기 시작했다.

실수를 저장하기 위해 부동 소수점으로 표현한다. 이때, 부동 소수점은 하나의 실수에 대한 고유한 표현이 없다. 때문에 비정규화 수라고 한다.

    π = 11.001001000011111101101010100010001000010110100011000010001101...2

따라서, 2진수에서는 가수부의 소수점 옆에 1이 무조건 배치시키는 정규화 작업을 한다.

    1.1001001000011111101101010100010001000010110100011000010001101...2 × 2의 1승

이때, 항상 1이라는 것은 이 정보를 `저장`할 필요가 없음을 의미한다. 이와 같이 가수부에 없지만 사용되는 1개의 유효 비트를 `hidden bit`라고 한다.

때문에, `hidden bit`를 사용하는 경우, 정규화된 부동 소수점 수는 0을 표현할 수 없다.

정리하자면, 부동 소수점 수는 다음과 같은 문제가 있다.

1. `hidden bit`를 사용할 경우 0을 표현하기 위해 정규화된 부동 소수점 수에 예외 조항이 필요하다.

2. 컴퓨터는 유한한 저장공간이기 때문에 `무한 2진 실수`를 저장할 수 없다.

이를 아우르는 IEEE 754 표준안을 소개한다.

### IEEE 754 표준안

IEEE 754 표준안은 NaN, +∞, -∞와 같은 특수한 기호와 비정규화 수를 표현하기 위해 지숫값 -127부터 +128을 별도의 용도로 예약하고 있다.

<br/>
<details>
<summary>별도의 용도 확인</summary>
<div markdown="1">

<table>
  <tr>
    <th rowspan=2>가수부</th>
    <th
      colspan=3;
      style="text-align: center;"
    >
      지수부
    </th>
  </tr>

  <tr>
    <th>-127</th>
    <th>-126 ~ +127</th>
    <th>+128</th>
  </tr>

  <tr>
    <td>=0</td>
    <td>0</td>
    <td rowspan=2>정규화 표현</td>
    <td>∞</td>
  </tr>

  <tr>
    <td>≠0</td>
    <td>비정규화 표현</td>
    <td>NaN</td>
  </tr>
</table>

</div>
</details>
<br/>

이를 토대로 정규화된 부동 소수점 수를 IEEE 754 표준으로 표현해보자.

### 무한 2진 실수(π) 를 IEEE 754 표준 `binary32(float)`로 표현

<br/>
<details>
<summary>표현에 필요한 Parameter는 다음과 같다.</summary>
<div markdown="1">

|  Parameter  |       설명       | binary32 |
| :---------: | :--------------: | :------: |
|      k      |   저장 비트 수   |    32    |
|      p      |   유효 자릿 수   |    24    |
|    emax     |    최대 지수     |   127    |
| bias, E - e |        -         |   127    |
|  sign bit   | 가수부 부호 표시 |    1     |
|      w      |  지수부 비트 수  |    8     |
|      t      |  가수부 비트 수  |    23    |

🙄
주목할점은 지수부에 부호 표시가 없다. 앞서 `hidden bit`는 1로 제한된다 소개하였다. `bias Parameter`는 지수부에 부호 표시가 없는 이유이다. IEEE 754는 앞서 별도의 용도로 정의된 비트 패턴을 사용하는데, 실제 지수부를 해석하기 위해서 bias Parameter를 뺍니다.

</div>
</details>
<br/>

IEEE 754 표현은 다음과 같다.

| S 부호 | E 지수부 | T 가수부       |
| ------ | -------- | -------------- |
| 1 bit  | w bits   | t = p - 1 bits |

binary32에 맞게 자릿수를 정해보자. π는 양수이므로 부호는 0이다.

| S 부호 | E 지수부(8 bits) | T 가수부(23 bits)       |
| ------ | ---------------- | ----------------------- |
| 0      | 00000000         | 00000000000000000000000 |

지수부를 구해보면 다음과 같다.

bias = E - e 공식에 지수 1을 넣어보면, E = 128 = $10000000_2$

가수부까지 넣어 정리하자면 다음과 같다.

| S 부호 | E 지수부(8 bits) | T 가수부(23 bits)       |
| ------ | ---------------- | ----------------------- |
| 0      | 10000000         | 10010010000111111011010 |

여담으로 CPU에서 실수 연산을 할 때는 ALU(Arithmetic logic unit)의 일부에 있는 **실수 처리부인 FPU(Floating Poing Unit)** 에서 처리한다.[^bignote]

[^bignote]: 위 IEEE 754와 같이 실수 연산의 정밀도를 계산하기 위해서 하드웨어가 필요하기 때문이다.

    정수 연산 같은 경우에 하드웨어가 필요하지 않은데, 그 이유는효율이 좋지 않기 때문이며 소프트웨어적으로도 충분히 커버할 수 있기 때문이다.

## 2진수 텍스트

아스키 코드는 2진수로 텍스트를 표현하는 표준이다. 다만, 영어를 표현하는데에만 국한되었다. 그 밖의 언어를 지원해야할 필요가 생긴 나라권에서는 아스키 코드를 확장해 각기 다른 표준이 생겨났다.

이때까지 7-8비트로 표현된 표준들이, 이후에는 유니코드라는 문자에 16비트를 부여한 표준이 생겨났다. 문제는 이 또한 한계가 있고, 스케일만 높일순 없없다.

이를 인코딩으로 해결하였고, UTF-8(유니코드 변환 형식 8비트)이 하위 호환성과 효율성 때문에 대표적이다.[^encoding]

[^encoding]: 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴이다.

UTF-8은 기존 아스키 코드를 인코딩할 때는 추가 공간이 필요하지 않는다.

아스키 코드가 아닌 문자의 경우는 위에 소개한 π의 유니 코드를 인코딩 해보겠다. 

### 유니 코드(π)를 UTF-8로 인코딩

먼저, π의 유니 코드(0x3C0)이다.

```markdown
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
| 0  | 0  |  0 |  0 |  0 |  0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
```

UTF-8로 인코딩 시 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;먼저, 2개의 옥텟으로 쪼개진다. 이 구분을 MSB로 표현한다.

```markdown
+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+
| 1 | 1 | 0 |   |   |   |   |   |  | 1 | 0 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+
```

&nbsp;&nbsp;&nbsp;&nbsp;다음으로, 유니코드에서의 비트를 LSB 순으로 남은 비트에 채워넣는다.

```markdown
                                                                  ←
+---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
```

## 텍스트로 수 표현

UTF-8은 문자를 표현하는 비트들

로부터 나온 숫자들

을 표현하는 숫자들을 표현하기 위해 숫자들을 사용한다.

## `MSB`를 식별자로 메모리 주소값을 찾는 예제

---

## 참고문헌

[소수점수](https://www.youtube.com/watch?v=vOO-oLS0H68&ab_channel=%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%9D%BC) -- 「개발자 라라」 유튜브

[Floating Point 부동소수점](https://johngrib.github.io/wiki/floating-point/) -- John Grib

[「컴퓨터 아키텍처: 컴퓨터 구조 및 동작 원리」](http://www.yes24.com/Product/Goods/14148792) -- 우종정

[언더플로](https://ko.wikipedia.org/wiki/%EC%96%B8%EB%8D%94%ED%94%8C%EB%A1%9C) -- 위키백과
