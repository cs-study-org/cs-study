# 컴퓨터 내부의 언어체계

## 목차

- [언어](#언어)
- [문맥에 따라 달라지는 표현법](#ch-2)
- [2진수 산술연산](#ch-3)
- [2진수 실수](#ch-4)
- [`MSB`를 식별자로 메모리 주소값을 찾는 예제](#extra-1)

### 언어

언어는 편의를 제공하기 위해 사용한다.

언어가 제대로 작동하려면 `기호의 집합(Encoding)`과 `같은 문맥(Context)`이 필요하다.

> 예로, camisole이라는 기호의 집합이 미국과 프랑스권에서 다른 문맥으로 사용된다면, 제대로 언어가 작동하지 않는다.

하지만, 우리는 언제나 같은 문맥을 명확히 식별할 수 있는 것은 아니며 컴퓨터 상에서도 다양한 정의로 사용된다.

### 문맥에 따라 달라지는 표현법

우리가 통상적으로 4비트에서 0부터 15까지 16가지 수를 표현하지만, 이 표현은 다양한 문맥에서 새로 정의할 수 있다.

| 2진수 | 부호와의 크기 | 1의 보수 | 2의 보수 |
| :---- | :-----------: | :------: | :------: |
| 1111  |      -7       |    -0    |    -1    |

### 2진수 산술연산

2진수 산술연산에서 각 비트를 MSB ← LSB 방향으로 결과가 1보다 크면 1을 다음 자리로 옮긴다.

**이때, 덧셈의 결과가 사용하는 비트 갯수의 범위를 벗어나면 어떻게 될까?**

overflow가 발생한다. overflow는 MSB에서 올림이 발생했다는 뜻이다.

> 예로, 4비트 덧셈에서 1001 + 1000 = 10001을 기대하겠지만 0001이 된다.

이럴 경우를 대비해 컴퓨터에는 `조건 코드 레지스터`에 overflow bit 정보를 담아둔다.

### 2진수 실수

컴퓨터에서 실수는 아주 커다란 숫자나 아주 작은 숫자를 효율적인 자원의 상태에서 연산하기 위해서 지원하기 시작했다.

이때, 컴퓨터는 유한한 저장공간이기 때문에 `무한 2진 실수`를 저장할 수 없다.

> 예로, $\pi$가 있다.

이러한 경우 컴퓨터는 실수를 높은 정밀도의 근사치로 계산해서 저장한다.

IEEE 754 부동소수점 수 표준이 이를 정의한다.

### $\pi$ 를 IEEE 754 표준 `binary32(float)`로 표현

표현에 필요한 Parameter는 다음과 같다.
|  Parameter  |       설명       | binary32 |
| :---------: | :--------------: | :------: |
|      k      |   저장 비트 수   |    32    |
|      p      |   유효 자릿 수   |    24    |
|    emax     |    최대 지수     |   127    |
| bias, E - e |        -         |   127    |
|  sign bit   | 가수부 부호 표시 |    1     |
|      w      |  지수부 비트 수  |    8     |
|      t      |  가수부 비트 수  |    23    |

`bias Parameter`는 지수부에 부호 표시가 없는 이유이다. IEEE 754는 특별한 비트 패턴을 제공하는데, 실제 지수부를 해석하기 위해서 bias Parameter를 뺍니다.

**왜 부호 표시가 없는 이유인가요?**

IEEE 754 표현은 다음과 같다.

| S 부호 | E 지수부 | T 가수부       |
| ------ | -------- | -------------- |
| 1 bit  | w bits   | t = p - 1 bits |

binary32에 맞게 자릿수를 정해보자. $\pi$는 양수이므로 부호는 0이다.

| S 부호 | E 지수부(8 bits) | T 가수부(23 bits)       |
| ------ | ---------------- | ----------------------- |
| 0      | 00000000         | 00000000000000000000000 |

$\pi$의 이진 표현은 다음과 같다.

&nbsp;&nbsp;&nbsp;&nbsp;$\pi$ = 11.001001000011111101101010100010001000010110100011000010001101...
2

정규화하면 다음과 같다.
&nbsp;&nbsp;&nbsp;&nbsp;1.1001001000011111101101010100010001000010110100011000010001101...
2 × $2^1$

지수부를 구해보면 다음과 같다.

bias = E - e 공식에 지수 1을 넣어보면, E = 128 = $10000000_2$

가수부까지 넣어 정리하자면 다음과 같다.

| S 부호 | E 지수부(8 bits) | T 가수부(23 bits)       |
| ------ | ---------------- | ----------------------- |
| 0      | 10000000         | 10010010000111111011010 |

여담으로 CPU에서 실수 연산을 할 때는 ALU(Arithmetic logic unit)의 일부에 있는 **실수 처리부인 FPU(Floating Poing Unit)** 에서 처리한다. [^bignote]

[^bignote]: 위 IEEE 754와 같이 실수 연산의 정밀도를 계산하기 위해서 하드웨어가 필요하기 때문이다.

  정수 연산 같은 경우에 하드웨어가 필요하지 않은데, 그 이유는효율이 좋지 않기 때문이며 소프트웨어적으로도 충분히 커버할 수 있기 때문이다.

### 2진수 텍스트

아스키 코드는 2진수로 텍스트를 표현하는 표준이다. 다만, 영어를 표현하는데에만 국한되었다. 그 밖의 언어를 지원해야할 필요가 생긴 나라권에서는 아스키 코드를 확장해 각기 다른 표준이 생겨났다.

이때까지 7-8비트로 표현된 표준들이, 이후에는 유니코드라는 문자에 16비트를 부여한 표준이 생겨났다. 문제는 이 또한 한계가 있고, 스케일만 높일수 없다.

이를 인코딩으로 해결하였고, UTF-8(유니코드 변환 형식 8비트)이 하위 호환성과 효율성 때문에 대표적이다. 여기서 인코딩은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴이다.

UTF-8은 기존 아스키 코드를 인코딩할 때는 추가 공간이 필요하지 않는다.

아스키 코드가 아닌 문자의 경우는 위에 소개한 $pi$의 유니 코드를 인코딩 해보겠고 과정은 다음과 같다.

먼저, $\pi$의 유니 코드이다.
> 유니코드 $\pi$ (0x3C0)

```markdown
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
| 0  | 0  |  0 |  0 |  0 |  0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
+----+----+----+----+----+----+---+---+---+---+---+---+---+---+---+---+
```

UTF-8로 인코딩 시 다음과 같다.

먼저, 2개의 옥텟으로 쪼개진다. 이 구분을 MSB로 표현한다.

```markdown
+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+
| 1 | 1 | 0 |   |   |   |   |   |  | 1 | 0 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+
```

다음으로, 인코딩 전 비트를 LSB 순으로 남은 비트에 채워넣는다.

```markdown
+---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+ +---+---+---+---+---+---+---+---+
```

### 텍스트로 수 표현

UTF-8은 문자를 표현하는 비트들

로부터 나온 숫자들

을 표현하는 숫자들을 표현하기 위해 숫자들을 사용한다.

---
### `MSB`를 식별자로 메모리 주소값을 찾는 예제 {#extra-1}
---

### 참고문헌

[소수점수](https://www.youtube.com/watch?v=vOO-oLS0H68&ab_channel=%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%9D%BC) -- 「개발자 라라」 유튜브

[Floating Point 부동소수점](https://johngrib.github.io/wiki/floating-point/) -- John Grib
