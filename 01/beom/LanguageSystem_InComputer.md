# 1주차 컴퓨터 내부의 언어 체계

## 이 책을 들어가기전 간단 용어정리

#### 컴퓨터란 무엇인가?
컴퓨터는 휴대 전화나 음악 플레이어 같이 하이테크 장난감을 돌아가게 해주는 두뇌라는 것을 가지고 있다.

#### 컴퓨터 프로그래밍이란?
프로그래밍은 컴퓨터의 선생님이다.
프로그래머는 컴퓨터가 프로그래머를 위해 할일을 하는 방법을 컴퓨터에게 가르켜줌

#### 코딩
코딩은 어느 정도 기계적인 변환 작업으로 볼 수 있다.
전체 프로그램 중 HTML이나 자바스크립트 등 어느 한 언어에만 능숙한 것과 비슷

#### 프로그래밍
한 전문 분야 이상을 알고 있다는 뜻
데이터를 정렬하고 조작하는 최적의 알고리즘을 결정하고, 웹 클라이언트와 웹서버 사이의 통신 구조를 결정하며, 사용자 인터페이스를 결정하는 등의 작업을 수행 -> 프로그램의 전체적인 지휘

#### 엔지니어링
엔지니어링은 지식을 얻고, 얻은 지식을 활용해 어떤 목표를 달성하는 기술이다.

#### 컴퓨터 과학
계산(컴퓨팅)에 대해 연구하는 학문

#### 애플리케이션 프로그래머
웹페이지, 폰 앱, 음악 플레이어 등의 프로그램을 작성하는 사람
이사람들은 다른 사람이 만든 기본 요소를 임포트하는 방법과 이 기본 요소들을 서로 붙이는 방법일 뿐이다.

#### 시스템 프로그래밍
직접적으로 하드웨어에 간섭하는 사람, 애플리케이션 프로그래머가 사용하는 기본 요소를 만든다.


## 컴퓨터 내부의 언어 체계

### 언어란 무엇인가
언어는 **편의를 제공하기 위한 지름길**이다
모든 언어의 뜻은 기호의 집합으로 인코딩됨
하지만 모두 다 같은 문맥을 공유해 같은 기호에 같은 뜻을 부여할 수 있어야함(이 점이 어려움)

### 문자 언어
모든 나라의 문자가 다르기때문에 문자 언어의 틀을 이룬다
#### 문자 언어의 틀
- 기호에 들어갈 상자
- 상자에 들어갈 기호
- 상자의 순서

### 비트
비트(bit) = 바리너리(binary) + 디지트(digit)
비트를 사용하면 적은 비용으로 편리하게 기호를 담을수 있음

#### 상자
자연어에서 상자 : 문자(character)
컴퓨터에서 상자 : 비트(bit)

### 논리 연산
다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작

### 불리언 대수
연산 규칙의 집합

- NOT : **논리적 반대** ex) 거짓인 비트에 NOT을 하면 참이 되고 참인 비트에 NOT를 하면 거짓이 된다.
- AND : 모든 비트가 참이면 AND 연산의 결과도 참이다.
- OR : 어느 한 비트라도 참이면 OR연산의 결과도 참이다.
- XOR : **배타적 OR** , 첫번째 비트와 두번째 비트가 다른 값인 경우에만 참 나머지 다 거짓

### 드모르간의 법칙
논리 연산에서 논리합은 논리곱과 부정기호로, 논리곱은 논리합과 부정기호로 표현할 수 있음을 가르키는 법칙
-> 긍정적인 논리에서는 or연산을 사용하고, 부정적인 논리에서는 and연산을 사용하여 결정 -> 비용 절감


### 정수를 비트로 표현하기
비트는 각 상자에 사용할 수 있는 기호가 0과 1밖에 없음
각상자의 자릿수는 2의 거듭제곱의 수가 들어간다.

가장 작은 유효 비트(least significant bit) : LSB, 가장 오른쪽 비트
가장 큰 유효 비트(most significant bit) : MSB, 가장 왼쪽 비트


#### 부호와 크기
음수와 양수를 구별하기 위해 사용 : 양부호(+), 음부호(-)
부호는 MSB를 사용(양수이면 0, 음수이면 1)
ex) 5 = 0 1 0 1
   -5 = 1 1 0 1

5 + -5 = ? 는 10진수로 0이다.
  0 1 0 1
+ 1 1 0 1
= 0 0 1 1
하지만 2진수 계산으론 3이 나온다. 

#### 1의 보수
음수를 표현하는 다른 방법
: 양수의 모든 비트를 뒤집는 방법

ex) 5 = 0 1 0 1
   -5 = 1 0 1 0

MSB의 결과가 10이 나오면 순환 올림을 통해 LSB에 더해서 계산해야함
-> 복잡

#### 2의 보수
부호와 크기 표현법이나 1의 보수 표현법을 해결한 표현법

어떤 수를 뒤집고 1을 추가하여 음수를 구하는 방법
0000을 뒤집으면 1111이고 1111에 1을 더하면 10000이 된다. 이 숫자는 5비트이기 때문에 첫번째 1을 무시해주고 0000으로 나타낸다.

### 정리
2진수 1111
- 부호와 크기 표기 -7
- 1의 보수 -0
- 2의 보수 -1

이러한 표기법이 있다는 것을 알고있자!


### 실수를 표현하는 방법

#### 고정소수점 표현법
2비트는 2진 소수점의 분수를 표현하기 위해 쓴다(4가지 분숫값을 표현가능 : 1/4, 2/4, 3/4, 1)
소수점의 위치가 항살 일정하기 때문에 고정소수점 표현법

범용 컴퓨터에서는 거의 사용 x
디지털 신호 처리 장치(DSP:digital signal processor) 등 특별한 목적에 쓰이는 일부 컴퓨터에서 사용

#### 부동소수점 표현법
실수를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현
ex) 0.101 = 1.0(1/2 * 2^1)
    1.010 = 4.0(1* 2^2)

#### 단점
- 비트 조합중 낭비되는 부분이 많다.
- 비트 패턴이 가능한 모든 수를 표현하지 못함

### IEEE 부동소수점 수 표준
이상하지만 부동소수점 표현법이 실수를 표현하는 표준 방법이다.
IEEE는 더 많은 비트를 사용하고, 가수와 지수에 대해 각각의 부호비트를 사용
다만 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다. 그리고 낭비되는 비트 조합을 최소화하고 반올림을 ㄱ쉽게 하기 위한 여러가지 트릭이 사용됨

IEEE 754라는 표준은 이 모든 기능을 정의함

#### 트릭
- 정규화 : 가수를 조정하여 맨 앞에 0이 없게 만드는 것
- 디지털 이큅먼트 사에서 고안한 트릭 : 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 생략

#### 정밀도
- 기본 정밀도 
32비트 사용

- 2배 정밀도
64비트 사용

2배 정밀도가 기본 정밀도보다 지수가 3비트(8배) 더크고, 가수는 29비트 더 크다 하지만 비트를 2배 사용한다는 비용 지불이 따른다.

### 2진 코드화한 10진수 시스템(BCD, binary-coded decimal)
ex) 12의 이진수 = 1100
    12의 BCD = 0001 0010
    -> 0001은 십의 자리의 1, 0010은 일의 자리의 2를 표현

디스플레이, 가속도 센서 등에서 BCD 사용

#### BCD의 인기가 줄어든 이유
2진수를 효율적으로 활용하지 못함


### 2진수를 다루는 쉬운 방법

#### 8진 표현법
2진수의 비트들을 3개씩 그룹으로 묶는 방법

101110111001010의 8진 표현법 -> 101, 110, 111, 001, 010
-> 56712

#### 16진 표현법
2진수의 비트들을 4개씩 그룹으로 묶는 방법
101100011001의 16진 표현법 -> 1011, 0001, 1001
-> b19

### 프로그래밍 언어의 진법 표기법
- 0으로 시작하는 숫자는 8진 숫자 ex) 017 -> 15 (8진법 -> 10진법)
- 1부터 9 사이의 숫자로 시작하는 수는 10진수
- 0x가 앞에 붙은 숫자는 16진수 ex) 0x12f -> 303

### 비트 그룹의 이름

| 이름  | 비트 개수  |
|---|---|
| 니블(nibble)  | 4 |
| 바이트(byte)  | 8  |
| 하프 워드(half word)  | 16  |
| 워드(word)  | 32  |
| 더블 워드(double word)  | 64  |
| 킬로바이트(kilovyte) | 1024  |
| 메가바이트(MB)  | 1048576  |
| 기가바이트(GB)  | 8589934592  |

### 텍스트 표현

#### 아스키 코드
아스키는 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당했다.
ex) 65 = 'A' , 61 = '='

아스키코드는 제어문자를 포함하고 있음
-> 제어문자 : 글자를 출력하는데 쓰이지는 않고 장치를 제어하기 위해 사용됨
ex) ACK : 수신확인, FS : 파일 구분자


### 유니코드 변환 형식 8비트(UTF-8)
유니코드는 지구상의 모든 문자를 16비트 안에 넣은 것 -> 현재는 21비트까지 확장됨

하지만 8비트만 사용해서 모든 문자를 표현할 수 있는데 굳지 16비트를 사용하기 싫음
그래서 나온 게 UTF-8

#### UTF-8의 장점
- 하위 호환성
- 효율성
- 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때 추가 공간 필요x
- 문자 깨짐 x


### 문자를 사용한 수 표현

#### 출력 가능하게 변경한 인코딩
쿼티드 프린터블 인코딩, QP인코딩 : 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법
주로 전자 우편 첨부에서 사용

단점 : 1바이트를 표현하기 위해 3바이트를 사용해야함 

#### 베이스64 인코딩
3바이트 데이터를 4문자로 표현
즉 6비트에 한 문자가 들어감
ex) 012 -> 베이스64 인코딩 -> 00000000 00000001 00000010
-> 000000 000000 000100 000010 -> AAEC

단점 : 데이터가 3바이트라는 보장이 없음
-> 패딩문자를 도입해 해결(2바이트가 남으면 끝에=, 1바이트가 남으면 끝에==)

#### URL인코딩
1. 문자나 특수문자를 웹서버와 브라우저에서 보편적으로 허용되는 형식으로 변화하는 메커니즘이다.
2. URL은 아스키 문자 집합을 사용하여 인터넷을 통해서만 전송 가능
3. URL은 종종 아스키 세트 외부의 문자를 포함하기 때문에 URL은 유효한 아스키 형식으로 변환되어야 한다.
4. URL 인코딩은 안전하지 않은 아스키 문자를 "%"다음에 두 개의 16진수로 대체한다.
5. URL은 공백을 포함할 수 없다. URL인코딩은 일반적으로 공백을 +기호 또는 % 20으로 바꾼다.
6. 즉, 아스키 이외의 문자는 다 인코딩 해야한다.

ex) 입력 : 헬로우 WORLD
 출력 : %ED%97%AC%EB%A1%9C%EC%9A%B0+WORLD