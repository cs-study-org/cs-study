# 목차

## Story 01.  HTTP 리퀘스트 메시지 작성

## Story 02. 웹 서버의 IP 주소를 DNS 서버에 조회

## Story 03. 전 세계의 DNS 서버가 연대한다.

## Story 04. 프로토콜 스택에 메시지 송신을 의뢰

<br>

* * *

<br>

## Story 01.  HTTP 리퀘스트 메시지 작성

### 1) URL의 이해

- URL 의 공통점
    - URL은 `[http://www.google.com](http://www.gmail.com)` 의 `http:` 와 같이 맨 앞 문자열에 Access 방법을 표시한다.
        
        >⇒ Access 대상에 따라 Access 방법을 명시하는 프로토콜을 나타내는 것
        
        <br>

        ex) 액세스 대상이 Web server 라면 Http 프로토콜을 사용하여 Access 한다.
        
        - `http:` → 웹서버 Access
        - `ftp:`   → 파일 전송 서버 Access
        - `file:` → 클라이언트 PC 자체 파일 데이터 Access
        - ... etc
    
    <br>

    - URL 형식 예시
        - Http 프로토콜을 통한 웹 서버 Access
            
            
            | http:// | user: | password@ | www.google.com | :80 | /dir/file1.html |
            | --- | --- | --- | --- | --- | --- |
            | 프로토콜 | 사용자명(생략 가능) | 패 스워드 (생략 가능 ) | 웹 서버 도메인명 | 포트 번호 (생략 가능) | 파일 경로명 |

        - FTP 프로토콜로 파일 다운 및 업로드
            
            
            | ftp:// | user: | password@ | ftp.cyber.co.kr | :21 | /dir/file1.html |
            | --- | --- | --- | --- | --- | --- |
            | 프로토콜 | 사용자명(생략 가능) | 패 스워드 (생략 가능) | FTP 서버 도메인명 | 포트 번호 (생략 가능) | 파일 경로명 |
        - 클라이언트 PC 자체의 파일에서 데이터 Access
            
            
            | file:// | localhost/ | c:/path/file1.zip |
            | --- | --- | --- |
            | 프로토콜 | 컴퓨터명 (생략 가능) | 파일의 경로명 |
        - 메일 송신
            
            
            | mailto: | tone@cyber.co.kr |
            | --- | --- |
            | 프로토콜 | 메일 주소 |
        - 뉴스 그룹 기사 Access
            
            
            | news: | comp.protocols.tcp-ip |
            | --- | --- |
            | 프로토콜 | 뉴스 그룹명 |

<br>

### 2) URL의 해독

- 브라우저는 클라이언트가 작성한 URL을 해독한다.
    - 예시) `http://www.google.com/dir1/file1.html`
        
        `http:` + `//` + [`www.google.com`](http://www.google.com) + `/` + `dir1` + `/` + `file1.html`
        
        >⇒ 위와 같이 나누어 해독한다.
        
        <br>

        참고)
        
        - 만약 `[http://www.google.com/dir](http://www.google.com/dir)` 과 같이 파일명을 생략한 경우에는?
            - 위와 같이 파일명을 생략한 경우 어느 파일에 Access 해야할지 모른다.
                
                >⇒ 그렇기 때문에 파일명을 생략할 때 서버측에서 미리 설정을 해두어야 한다.
                
                - 파일명을 생략한 경우 서버에서 미리 설정된 파일을 응답하게 된다.
                    - `index.hml` 또는 `default.html`..(서버에 따라 다를 수 있다.)
         
         <br>

        - 만약 `[http://www.google.com](http://www.google.com)` 과 같이 `/dir` , `/` 을 생략한 경우에는 ?
            - 위와 같이 파일명 혹은 디렉토리까지 생략되는 경우
                
                >⇒ 서버측의  루트 디렉토리 아래에 미리 설정된 파일을 응답하게 된다.
        
        <br>       

        - 만약 `[http://www.google.com/kim](http://www.google.com/kim)` 에서 `kim` 이라는 디렉토리와 파일이 존재한다면?
            - 위와 같은 경우 `kim` 이 파일일 경우 확장자 명이 붙어야 하기 때문에 디렉토리로 취급하게 된다.

<br>

### 3) HTTP 의 기본 개념

URL 해독 이후 브라우저는 HTTP 프로토콜을 이용하여 웹서버에 Access 하게 된다.

- HTTP ( Hyper Text Transfer Protocol)
    - 서버와 클라이언트간 주고 받는 메시지의 내용이나 순서를 정한 규칙
    
    <br>

- HTTP Message
    
    >⇒ 서버와 클라이언트간 HTTP를 통해 `메시지`를 주고받는다
    
    <br>

    <메시지 구조>
    
    <img width="384" alt="스크린샷 2022-02-15 오후 7 20 37" src="https://user-images.githubusercontent.com/81874493/154042360-1ea06148-9335-4fb2-b312-0056cfc71d80.png">

    - HTTP Request Message
        - 메시지내에는 `“무엇을”` `”어떻게”` 하겠다라는 내용이 작성되어 있다.
            - `“무엇을”`에 해당되는 것을 URI 라고 한다.
                - URL [`http://www.google.com/dir/file.html`](http://www.google.com/dir/file.html) 에서
                    
                    >⇒ `dir/file.html` 와 같은 식
                    
                    <br>
                
                참고) URL vs URI
                
                <details>
                <summary>URL 과 URI ?</summary>

                - URL 과 URI ?
                    - URL (Uniform Resource Locator)
                        
                        >⇒ 흔히 웹 **주소**라고도 하며, 컴퓨터 네트워크 상에서 리소스가 **어디 있는지 알려주기**
                         위한 규약이다. (URI의 서브셋이다.)
                        
                    - URI ( Uniform Resource Identifier)
                        
                        >⇒ 특정 리소스를 식별하는 **통합 자원 식별자**를 의미한다. 웹 기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열 시퀀스다.

                    <br>    
                    
                    차이점)
                    
                    URL : 위치를 가리킨다.
                    
                    URI : 식별한다.
                    
                    <br>

                    <img width="537" alt="스크린샷 2022-02-15 오후 7 22 04" src="https://user-images.githubusercontent.com/81874493/154042428-ce19f19e-67dd-4029-9b41-3f45d22c723b.png">

                    ⇒ 두 주소는 모두 index.html 을 가리키고 있다.
                    
                    - 첫번째 주소는 웹서버의 실제 파일 위치를 나타내는 주소이므로 URI이면서 URL이다.
                    - 두번째 주소는 실제로 index라는 파일이 웹서버에 존재하지 않으므로 URL은 아니다. 하지만 서버 내부에서 이를 처리하여 결국 index.html을 가리키기 때문에 URI라고 볼 수 있다.
                    
                    </details>
                    
                    <br>

        - `“어떻게”`에 해당되는 것은 HTTP 메소드 이다.
            - 메소드를 통해 웹 서버에 어떤 동작을 하고 싶은지 전달한다.
            - HTTP 메소드
                
                <img width="542" alt="스크린샷 2022-02-15 오후 7 20 44" src="https://user-images.githubusercontent.com/81874493/154042454-fbd6c788-9aba-4a0e-be96-12654f3e4e45.png">

                - 속성
                    - 안전 : 호출시 리소스에 변경하지 않는다.
                    - 멱등 : 1번 호출 하든 100번 호출 하든 그 결과가 동일하다.
                        >⇒ Post의 경우 결제 Post를 두번 호출하면 결제가 2번 진행된다.
                    - 캐시 가능 : 응답결과를 캐시하여 사용해되 되는가.

                    <br>

        - 요청 메시지 포멧
            
            <img width="262" alt="스크린샷 2022-02-15 오후 7 20 49" src="https://user-images.githubusercontent.com/81874493/154042471-60cda88d-01dd-4b2e-84aa-58dde8b0ce5a.png">

            <br>

    - HTTP Response Message
        - 응답 메시지에는 상태코드와 응답 결과를 담아 클라이언트에게 응답한다.
            
            <img width="591" alt="스크린샷 2022-02-15 오후 7 20 55" src="https://user-images.githubusercontent.com/81874493/154042488-69c2e0ee-37d4-4394-967a-ae172949fe78.png">

            <br>

        - 응답 메시지 포멧
            
            <img width="270" alt="스크린샷 2022-02-15 오후 7 20 59" src="https://user-images.githubusercontent.com/81874493/154042512-9cf5bf83-a856-4f61-8a8c-1cf21ac2d9ad.png">


<br>

* * *

<br>

## Story 02. 웹 서버의 IP 주소를 DNS 서버에 조회

브라우저가 사용자가 입력한 URL을 해석하여 HTTP 메시지를 만들었다.

>⇒ 하지만 **브라우저는 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하여 송출**해야한다.

<br>

단! 여기서 OS에 송신을 의뢰할때!! 

**`도메인 명`이 아닌 `IP 주소`를 통해 메시지 받을 상대를 지정해 줘야 한다!**

이 과정을 알아보자.

<br>

### 1) IP 주소

인터넷 혹은 사내 LAN 경우 TCP/IP 기초하여 만들어 졌다.

- TCP/IP 개념
    
    >⇒ 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어지며 IP주소를 통해 통신한다.
    
    - 서브넷
        - 허브나 스위치에 몇개의 PC가 연결되어 하나의 조그만한 네트워크를 구성한 것

     <br>

- IP 주소
    
    ⇒ 어떤 서브넷의 어떠한 PC 혹은 통신 기기 인지를 구별하는 주소로 
    
    - 어떤 서브넷인지 → 네트워크 번호
    - 어떤 PC 혹은 통신 기기 인지 → 호스트 번호
        
        >⇒ 두 번호의 조합으로 구성된다.
        
        <br>
    
    구조)
    
    IP 구조 :`210.192.122.5`
    
    32 비트의 구조로 8비트씩 점으로 구분하여 10진수로 표기한다.
    
    - 서브넷 마스크
        
        >⇒ `210.192.122.5/24`
        
        >⇒ `210.192.122.5/255.255.255.0`
        
        - IP 주소에서는 네트워크 번호, 호스트번호 두가지로 구성된다는 점만 알고 있지 실제 네트워크 내역에 대해서는 명시되어있지 않음
            
            >⇒ 이 내역을 명시해주는 것이 서브넷 마스크이며 , 네트워크 구축시 사용자가 직접 내역을 구축할 수 있고 내역을 필요에 따라 IP 주소에 덧붙히는 주소
            
            <br>            

- 도메인 명과 IP 주소를 구분하여 사용하는 이유
    - 일일이 IP 주소를 외워 Access 하기 번거로우며 어렵다.
        
        <br>

        ⇒ 그렇다면 처음부터 IP가 아닌 이름으로 상대를 지정하여 통신한다면?
        
        - 실행 효율 과점 좋은 방법이지만
            
            >⇒ IP 주소 4바이트 만 이용하여 활용 하고 있지만 
            
            >⇒ 이름을 통해 사용하게 된다면 1~255 바이트 까지의 문자를 취급하여야 하기 때문에
            
            >⇒ 라우터가 부하되어 데이터 운반 동작에 더 많은 시간이 걸리며 네트워크 속도가 늦어진다.
            
            <br>

        - 이 때문에 라우터는 IP 주소를 사용하는 방법이 정착되었고
            - 도메인 을 알면 IP 를 알수 있다는 원리를 사용하여 통신하는 방법이 구상 되었는데
                
                >⇒ 이를 **DNS** 라고 한다.
                
<br>

### 2) 도메인 주소로 IP 주소를 찾는 과정

브라우저가 도메인 주소를 통해 IP 주소를 조사하는 방법은

>⇒ Socket 라이브러리 내부의 DNS 리졸버를 사용하여 

>⇒ DNS 서버에게 IP 주소를 요청하여 알아낸다.

<br>

- Socket 라이브러리
    - 라이브러리의 일종으로 OS에 포함되어 있는 네트워크 기능을 애플리케이션에서 호출하기 위해 부품을 모아 놓은 것
    
    <br>

- DNS 리졸버
    - 도메인 이름을 통해 IP 주소를 알아내는 라이브러리 부품
    
    <br>

- DNS 리졸버 내부 동작
    
    <img width="254" alt="스크린샷 2022-02-15 오후 7 21 07" src="https://user-images.githubusercontent.com/81874493/154042560-43f55152-286f-4ff4-84bf-44f6a7efa149.png">

    1. 애플리케이션에서 리졸버를 호출하는 부분에 이르르면 제어권이 리졸버에게 넘어감
    2. 리졸버는 DNS 서버에 IP 주소를 문의를 위한 메시지를 만든다.
        
        >⇒ ( 여기서 메시지는 바이너리 데이터로 표현됨)
        
    3. 리졸버는 OS의 내부에 포함된 프로토콜 스택을 호출하여 실행을 의뢰한다.
        
        >⇒ (리졸버도 마찬가지로 데이터를 송 * 수신하는 기능은 없다.)
        
    4. 리졸버가 프로토콜 스택을 호출하면 제어권이 OS의 프로토콜 스택으로 넘어간다.
    5. 프로토콜 스택은 리졸버가 만든 메시지를 LAN 어댑터를 통해 DNS 서버에게 송신된다.
    6. DNS 서버가 메시지를 받고 이에 해당하는 IP 주소를 OS 내부 프로토콜 스택으로 응답한다.
    7. 프로토콜 스택은 응답받은 결과를 리졸버에게 넘기고 리졸버는 다시 애플리케이션 프로그램으로 응답한다.

<br>

* * *

<br>

## Story 03. 전 세계의 DNS 서버가 연대한다.

### 1) DNS 서버의 동작

- 클라이언트가 DNS 서버에게 요청하는 메시지 구성
    - 이름 : 서버나 메일의 목적지 이름
    
    <br>

    - 클래스 : 인터넷 이외 다른 네트워크 에서 사용시 구분을 목적으로 만든것
        


        ( 현재는 인터넷을 사용하기 때문에 ‘IN’ 이라는 값을 고정적으로 사용한다.)
        
        <br>

    - 타입 : 어떤 타입의 정보가 지원 되는지를 나타낸다.
        - A 타입 : IP 주소가 지원
        - MX 타입 : 메일 배송 목적지가 지원
    
    >⇒ DNS 서버는 이 세가지 정보에 대응하여 클라이언트에 회답하는 정보를 등록해 둔다.
    
    <br>

- DNS 서버 동작
    
    ```www.google.com``` 서버의 IP 주소를 조사할때
    
    <문의 메시지 구성>
    
    - 이름 : www.google.com
    - 클래스 : IN
    - 타입 : A
    
    <DNS 서버 동작>
    
    1. DNS서버는 소스 레코드( 도메인 명과 IP 주소의 대응 표 ) 에서 조사
    2.  도메인명과  대응하는 IP 주소를 응답한다.
    

<br>

### 2) 도메인 계층

인터넷에는 막대한 수의 서버가 있으며

>⇒  이 모든 서버의 도메인 주소 정보를 1대의 DNS 서버에 등록하여 운영하는 것은 **불가능** 하다.

>⇒ 그렇기에 도메인은 계층적으로 나누어지며 그에 맞게 여러 DNS 서버 또한 계층적으로 운영되어진다.

<br>

EX)

`www.cyber.co.kr`

- (최상위) kr 도메인 : 대한민구에 할당된 도메인
- co 도메인 : 국내의 도메인을 분류하기위해 설치된 도메인
- cyber 도메인 : 회사에 할당된 도메인
- (최하위) www 도메인 : 서버의 이름

<br>

### 3) DNS 서버 찾기

<img width="345" alt="스크린샷 2022-02-15 오후 7 21 21" src="https://user-images.githubusercontent.com/81874493/154042594-b8a4c4a9-3cee-4622-9dd0-346b96545720.png">

<DNS 서버 찾기 동작>

`www.lab.glasscom.com`

1. 현재 클라이언트와 가장 가까운 DNS 서버에게 IP문의 메시지를 요청한다.
2. 가장 가까운 DNS 서버는 `[www.lab.glasscom.com](http://www.lab.glasscom.com)` 이라는 정보가 없으므로 
    
    >⇒ 자신의 DNS 서버의 최상위 계층의 루트 도메인 DNS 서버를 찾는다.
    
3. 루트 DNS 서버에게 IP 문의를 한다.
4. 루트 DNS 서버 또안 도메인 정보를 가지고 있지 않지만 
    
    >⇒ com 아래 도메인 아래에 있다는 것을 알기 때문에 com DNS서버에게 요청하라고 응답한다.
    
    >⇒ 반복
    
5. 반복 이후 `www.lab.glasscom.com` 의 상위 DNS 서버인 lab DNS서버가 정보를 가지고 있으므로
    
    >⇒ 클라이언트와 가장 가까운 DNS 서버에게 IP 주소를 응답한다.
    
6. 클라이언트와 가장 가까운 DNS 서버는 IP 주소를 클라이언트에게 다시 응답한다.

<br>

### 4) 캐시 기능 사용

DNS 서버도 브라우저에서도 캐시 기능을 사용하여 속도를 향상 시킬 수 있다.

- DNS 서버 : 한번 요청된 도메인의 IP를 캐시에 기록해두고 이후 동일 요청시 바로 응답한다.
- 브라우저 : 한번 요청한 도메인의 IP를 캐시에 기록해두고 동일 도메인에 접근시 바로 사용한다.

<br>

* * *

<br>

## Story 04. 프로토콜 스택에 메시지 송신을 의뢰

DNS 서버를 통해 IP 주소를 조사했으니

>⇒ IP 주소를 통해 Access 대상 서버와 통신을 해야한다.

>⇒ 이전 언급했듯이 브라우저 혹은 어플리케이션 같은 경우 실제 네트워크를 통해 데이터 전송 기능이 없다.

>⇒ 그러므로 OS의 프로토콜 스택에 의뢰하여 통신하게 된다.

<br>

### 1) 프로토콜 스택에 의뢰

프로토콜 스택에 HTTP 메시지(디지털 데이터) 송신을 의뢰할때 또한 

>⇒ Socket 라이브러리의 부품을 이용

>⇒ 단, IP추적할때 처럼 하나의 부품(리졸버) 만 호출하는것이 아닌 일련의 순번대로 호출하여 의뢰한다.

<br>

EX)

1) 소켓 작성 부품 호출

2) 접속 부품 호출

3) 데이터 송수신 부품 호출

4) 연결 끊기 부품 호출

>⇒ 브라우저나 어플리케이션은 호출만 한다

>⇒ 호출했을 때 실제 동작하는 것은 프로토콜 스택이다.

<br>

### 2) 데이터의 송수신

<img width="587" alt="스크린샷 2022-02-15 오후 7 21 32" src="https://user-images.githubusercontent.com/81874493/154042683-369e01e7-17ba-443f-8da8-2eb611b6aa67.png">

<Socket 라이브러리를 이용한 데이터 송 * 수신 동작 이미지>

- 데이터의 송수신 과정
    - 클라이언트와 서버 각각 소켓을 만든다
    - 클라이언트와 서버 각각의 소켓을 파이프로 연결한다.
    - 파이프를 통해 데이터를 송 * 수신한다.
    - 송 수신이 완료 후 파이프를 삭제한다.
    
    >⇒ 여기 모든 동작은 프로토콜 스택이 실행하며 이를 호출하는 주체는 브라우저나 어플리케이션이다.
    
    <br>

- 데이터 송수신 과정을 수행하기 위해 각 단계가 구성된다.
    
    1) 소켓을 만든다 ( 소켓 작성 단계 )
    
    2) 서버측의 소켓에 파이프를 연결한다 ( 접속 단계 )
    
    3) 데이터를 송 * 수신 한다 ( 송 * 수신 단계 )
    
    4) 파이프를 분리하고 소켓을 말소한다 ( 연결 끊기 단계 )
    
    >⇒ 각 단계를 자세히 알아보자
    

<br>

### 3) 데이터 송수신 단계

<img width="717" alt="스크린샷 2022-02-15 오후 7 21 38" src="https://user-images.githubusercontent.com/81874493/154042710-ad507c07-ea78-4777-8cbb-3795f569ec9b.png">

**1) 소켓 작성 단계**

- 브라우저나 어플리케이션 에서 Socket 라이브러리의 소켓 생성 부품을 호출한다.
    
    >⇒ 제어권이 소켓 내부에 제어가 넘어가 소켓을 만드는 동작을 실행
    
    >⇒ 실행 완료 후 어플리케이션으로 제어권을 돌려줌
    
    <br>

- 소켓이 생성되면 디스크립터라는 것을 어플리케이션에게 반환해준다.
    
    >⇒ 어플리케이션은 이를 받아 메모리에 기록해 둔다
    
    >⇒ 디스크립터는 소켓을 식별하기 위해 사용
    
    ( 이후 접속 , 송시, 수신, 연결 종료 등의 과정에서 소켓 지칭하기 위해 디스크립터를 이용 )
    
    <br>

    ex) 클라이언트와 서버간 동시에 데이터를 주고 받을 시 두개의 소켓을 생성하여 송수신한다.
    
    >⇒ 이때 두 소켓 각각을 구분하기 위해 디스크립터를 이용한다.
    
    <br>

**2) 접속 단계**

- 브라우저나 어플리케이션에서 Socket 라이브러리의 접속 부품을 호출한다.
    
    ⇒ Socket 라이브러리의 connect라는 부품을 호출하게 된다.
    
    <br>

    이때, connect 호출시 들어가는 파라미터로
    
    - 디스크립터 ( 자신이 사용할 소켓의 디스크립터)
        
        >⇒ 자신이 파이프 연결에 사용할 소켓의 디스크립터
        
        <br>

    - 서버의 IP 주소
        
        >⇒ 접속할 서버 구분을 위해
        
        <br>

    - 포트 번호
        
        >⇒ 서버 측에 어떤 소켓과 연결할지에 대한 식별을 위해  라고 작성되어 있지만,
        
        >⇒ 실제 서버에서 가동되는 프로그램 중 어떤 프로그램과 연결할지 식별을 위해 사용한다라고 알 고 있다.
        
        - 포트 번호는 미리 결정된 값을 대부분 이용한다.
            - 웹 80 번
            - 메일 25번 ...etc
        
        <br>

        참고)
        
        클라이언트 측에서는 서버의 어떤 소켓과 연결할지 포트를 사용한다고 했다,
        
        >⇒ 그렇다면 서버측에서 통신할 클라이언트의 소켓은 어떻게 식별하나?
        
        >⇒ 클라이언트 측 프로토콜 스택이 소켓 디스크립터 값을 서버에게 넘겨 인지시켜 연결한다.
        
        <br>
    
    결론적으로 접속단계에서 connect를 호출하면
    
    - 프로토콜 스택이 접속 동작을 수행한다.
        
        >⇒ 상대와 연결되면 프로토콜 스택은 연결된 상대의 IP주소, 포트 번호 등 정보를 소켓에 기록한다.
        
        >⇒ 이로써 송 * 수신이 가능한 상태(파이프가 연결된 상태)가 된다.
        

<br>

**3) 송 * 수신 단계**

- 소켓이 상대측과 연결되면 파이프에 데이터를 쏟아 부으면 상대 측 소켓에 데이터가 도착하게 된다.
    - 송신
        - 브라우저나 어플리케이션은
            
            >⇒ 디스크립터와 송신데이터를 파라미터로 Write를 호출하여 데이터를 송신한다.
            
            >⇒ 소켓에는 연결된 상대측이 기록되어 있어
            
            >⇒  소켓에 데이터를 write 하면 상대측에 도착하게 된다.
            
            <br>

    - 수신
        - 브라우저나 어플리케이션은
            - 우선적으로 수신한 응답 메시지를 저장하기 위한 메모리를 지정하는데
                - 이를 수신 버퍼라고 한다.
                    
                    ( 수신 버퍼는 애플리케이션 프로그램 내부에 마련된 메모리 영역으로 이 영역에 수신 데이터를 저장하여 사용한다.)
                    
            
            >⇒ 이후 디스크립터와 수신버퍼 등을 파라미터로 read 를 통해 수신버퍼에 데이터를 저장한다.
            
            <br>


**4) 연결 끊기 단계**

- 브라우저가 데이터 수신을 완료하면 송 * 수신 동작은 끝이난다.
    - 이후 Socket 라이브러리의 close라는 부품을 호출하여 연결 끊기 단계로 들어가도록 의뢰한다.
        
        <br>

        - 1) 서버측 에서 HTTP 응답 메시지 송신을 완료 했을때 서버 측에서 먼저 연결 끊기 동작을 실행
            
            >⇒ 클라이언트 측에 연결 끊기 동작을 실행했다고 알림 
        
        <br>    

        - 2) 연결 끊기 동작 실행되었다는 알림을 받은 클라이언트 측 또한 연결 끊기 단계로 들어가게 된다.
        
        <br>

        - 3) 어플리케이션이 read를 통한 수신 동작을 요청했을때 연결이 끊겼다는 사실을 반환한다.
        
        <br>
        
        - 4) 어플리케이션 에서도 송 수신이 완료 되었다는 것을 알고 close를 호출하여 연결 끊기 단계에 들어간다.


<br>
