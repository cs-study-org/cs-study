# 스토리지 기술의 변천과 데이터베이스에 끼치는 영향


## 들어가며
이번장에서는 `하드웨어` 기술의 변천을 배울 예정이다. 특히 HDD -> SDD로 이행하는 과정을 자세히 볼 것!

## 용어 정리
- 랜덤 액세스 : 데이터를 저장하는 블록을 한번에 여러 개 액세스하는 것이 아니라 한번에 하나의 블록만을 액세스하는 방식

**[ SQL 서버 ]** = `MySQL엔진 + 스토리지 엔진`

- MySQL엔진
  - Connection Handler : 커넥션 및 쿼리 요청을 처리 담당
  - SQL 인터페이스 : DML, DDL, Procedure, View 등 SQL 인터페이스 제공 담당
  - SQL 파서(parser) : SQL문법 오류 탐지 및 SQL 쿼리 문장을 MySQL이 처리하기 좋은 토큰 단위로 나눠서 트리 형태로 파싱하는 작업 담당
  - SQL 옵티마이저 : 쿼리의 최적화된 실행 담당
  - 캐시와 버퍼 : 성능 향상을 위한 보조 저장소 기능 담당 

- 스토리지 엔진 : MySQL엔진과 플러그인 형태로 연동/분리 가능하고 핸들러 API(핸들러 요청)를 통해 스토리지 엔진에 읽기/쓰기 요청이 가능

**[ MySQL스레드 구조 ]**</br>
MySQL서버는 프로세스 기반이 아닌 `스레드`기반이다.</br>
(클라이언트 별로 커넥션을 주면서, 다수의 클라이언트가 연결되는 멀티스레드 방식)

MySQL 스레드 = 포그라운드 스레드 + 백그라운드 스레드

- 포그라운드 스레드
  - 클라이언트/사용자가 요청한 쿼리 문장을 처리하는 스레드(고객 창구 역할)
  - 데이터 조회 스레드(데이터 버퍼나 캐시 또는 직접 디스크나 인덱스 파일로 접근하여 데이터를 가져오는 스레드)
- 백그라운드 스레드
  - Insert buffer를 병합하는 스레드
  - 로그 기록 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크로 기록하는 스레드
  - 데이터를 버퍼로 읽어들이는 스레드
  - 잠금, 데드락을 모니터링하는 스레드
  - 모든 백그라운드 스레드를 관리하는 메인 스레드


## 하드웨어 성능 개선
DB에서 데이터를 액세스하는 공간은 두가지가 있다.
1. 메모리
2. 디스크

- 메모리 액세스
  - 액세스 속도가 빠르다.
  - 휘발성이다.
  - 담을 수 있는 데이터의 양이 적다.
- 디스크 액세스
  - 담을 수 있는 데이터의 양이 많다.
  - HDD를 액세스하기 위해서는 물리적인 동작이 필요하다.
    1. 디스크 헤드가 해당 트랙에 도달하기까지의 탐색 대기 시간
    2. 원하는 위치에 올 때까지의 회전 대기 시간

## 액세스 성능 극대화

### 메모리 상에서의 작업 수행
- 메모리에서는 액세스가 매우 빠르다.
- 메모리의 가격이 비싸다.

### 디스크 복제
- RAID 구성을 통해 병렬적으로 액세스를 처리한다.
- 2배의 효과는 있는지 딱히 좋은 방식은 아니다.

### 서버 복제
- 참조 처리(SELECT)에 경우, 슬레이브를 많이 만들어 병렬처리
- 갱신 처리(UPDATE)에 경우, 마스터와 슬레이브의 모든 서버에서 실행되기 때문에 슬레이브만 만들면 불가능
- 샤딩(하나의 큰 데이터를 여러 데이터 베이스 서버로 나누는 것)을 통해 여러 데이터베이스 서로 분할 처리

### 단일 스레드 처리 성능 문제
디크스, 메모리의 크기를 늘려서 DB서버가 담당할 데이터 양/사용자 수가 모두 증가 하게 되면 새로운 문제가 발생한다.

바로 집계처리와 같은 **단일 스레드**에서 작업하는 것의 시간이 오래걸린다.

MySQL에서 `바이너리 로그 수신`하는 동작 역시 단일 스레드 작업이다.

### SATA SDD로 성능 개선
위 단일 스레드 처리의 성능 지연의 주요 이유는 **디스크I/O가 느리기 때문이다.**

기존의 HDD를 SATA SDD로 변경하여 고속 액세스를 하는 방법이 있다.

### SATA SDD -> PCI-Express SSD
PCI-Express SSD의 등장으로 인터페이스의 속도를 더 빠르게 사용하였다.

## SDD/HDD를 사용한 DBMS 성능 차이

|   | SSD | HDD |
|---|---|---|
| 보관 기간 | 2~5년 | 5~10년 |
| 가격 | 비싸다 | SSD에 비해 싸다 |
| 복구 가능성 | 아예 없다. | 일부분이 가능할 수 있다. |
| 랜덤 액세스 | 빠르다 | 느리다(물리적 이동) |

**[ 결론 ]**

Buffer size가 충분하다면 어느 저장장치를 사용하든 큰 차이는 없다.

다만, Buffer size가 부족한 경우 TPS, 초당 I/O 처리율에서 SSD가 더 뛰어난 성능을 보여준다. 하지만 Buffer size를 늘리는 것이 비용에 비해서 성능을 더 올릴 수 있다.

결론 적으로 SSD를 사용하는 것보다 **HDD + 높은 Buffer size**가 비용 면에서 가장 좋은 선택이지만 Buffer size를 못늘리면 SSD를 사용하자


## 데이터베이스 개선
위 내용은 하드웨어의 진화이다. 이제부터는 데이터베이스 제품(소프트웨어)의 진화를 보여준다. 

**[ MySQL 개선 ]**

1. CPU 확장성 향상
2. 디스크 I/O 병렬성의 개선
3. 백그라운드의 분할/병렬화

### CPU 확장성 향상
프로그램 중에는 동시에 하나의 스레드만 접근 가능하도록 하는 구간이 존재한다.

이런 구간을 **임계 영역**이라고 한다.

요즘 CPU는 기본적은 멀티코어, 헥사코어인데 이런 멀티코어도 임계영역이 많으면 무쓸모 이다.

그래서 이러한 임계영역을 분할하여 병렬적으로 처리하는 방식을 발명하였다.

### 디스크 I/O 병렬성의 개선
기존의 I/O를 담당하는 스레드는 2개 -> I/O 스레드 수를 설정할 수 있게 됨

### 백그라운드의 분할/병렬화
기존의 백그라운드 스레드 처리는 단일스레드에서 담당하였다.

하지만 스레드를 나누어서 처리할 수 있도록 개선되었다.

그리고 비동기 I/O의 지원으로 스레드가 적어도 I/O 요청을 많이 던질 수 있어 병렬성이 높아졌다.



## 참고 문헌
[SSD/HDD를 사용한 DBMS 성능차이](https://velog.io/@yangsijun528/DB%EC%97%90%EC%84%9C-HDD%EC%99%80-SSD%EC%9D%98-%EC%B0%A8%EC%9D%B4)

[MySQL 아키텍처](https://jeong-pro.tistory.com/239)

[InnoDB 엔진 특징](https://nomadlee.com/mysql-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%A2%85%EB%A5%98-%EB%B0%8F-%ED%8A%B9%EC%A7%95/)

[데이터 처리 메커니즘](https://pearlluck.tistory.com/47)