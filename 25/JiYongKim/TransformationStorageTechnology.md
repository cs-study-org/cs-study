# Chapter 7 : 스토리지 기술의 변천과 DB에 끼치는 영향

## 목차

1. HDD에 의한 처리의 한계
    1. 랜덤 액세스
2. 메모리 상에서의 작업 수행
    1. 캐싱
    2. 샤딩
3. CPU의 확장성 향상
    1. 배타 제어
    2. mutex
4. 백그라운드 처리의 분할/병렬화
    1. 백그라운드 프로세스
    

---

<br>

## HDD에 의한 처리의 한계

인덱스와 실제 데이터는 물리적 인접해 있지 않기 때문에 각각 별도로 액세스 할 필요가 있다.

⇒ 이러한 접근 방식을 랜덤 액세스 라고 한다.

액세스 방식에 대해 알아보자

- **Sequential Access**
    
    ![스크린샷 2022-06-23 오전 5.57.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/475f1508-15ea-4ab3-8006-31de35373a49/스크린샷_2022-06-23_오전_5.57.48.png)
    
    - 논리적 또는 물리적으로 연결된 순서에 따라 순차적으로 Block을 읽는 방식
    - Sagment Header 에 Extent정보를 Map의 key로 가지고 있고 해당 Extent의 첫 Block부터 연속해서 읽게되면 Sequential Access 가 가능하게 되며, 이러한 방식을 **Full Table Scan** 이라고 한다.
    - Table Full Scan의 경우에는 한 번에 여러 개의 블록을 액세스할 수 있다.

<br>

- **Random Access**
    - 어떤 파일내에 있는 특정한 레코드를 찾을 때 다른 레코드를 순차적으로 읽지 않고 원하는 레코드만을 직접 액세스 하는 방식
    - 원하는 레코드만을 직접 액세스 하기 때문에 데이터를 빨리 검색 할 수 있다.
        
        ⇒ (단. 데이터의 절재적인 면적이 중요하며 , index 의Clustering Factor 에 따라서 어떤 경우는 Full table scan 이 더 빠를 수 도 있다. )
        
    - 한번에 여러 개 액세스하는 것이 아니라 한 번에 하나의 블록만을 액세스하는 방식

<br>

**<그렇다면 언제 랜덤 액세스가가 발생할까?>**

바로 인덱스를 액세스하여 확인한 ROWID를 이용하여 테이블을 액세스하는 경우 랜덤액세스가 발생하게 된다.

ROWID는 **해당 데이터를 찾아가는 유일한 주소 값**이며 우리가 인덱스를 이용한다는 것은 **인덱스로부터 조건을 만족하는 인덱스 값을 액세스한 후 ROWID를 확인하여 ROWID 값으로 테이블을 액세스하는 것**을 의미한다.

이와 같이 인덱스 액세스 후 테이블을 액세스하는 경우에 발생하는 I/O는 한 번에 하나의 블록만 액세스하는 랜덤 액세스가 발생하게 된다.

<br>

- ROWID?
    
    ROWID란?
    
    ![스크린샷 2022-06-23 오전 5.50.40.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/246cc756-eb5c-48af-b4a3-a7c552bf86b8/스크린샷_2022-06-23_오전_5.50.40.png)
    
    - 테이블에서 행의 위치를 지정하는 논리적 주소값
    - DB 전체에 중복되지 않은 유일한 값으로 테이블에 새로운 행이 삽입시 테이블 내부에서 의사 컬럼 형태로 자동적 생성됨
    - 테이블의 특정 레코드를 랜덤하게 접근하기 위해해 주로 사용된다.
    
<br>

<랜덤 액세스의 종류>

인덱스 액세스 후 테이블을 액세스하는 것은 랜덤 액세스를 발생시키게 되며,

랜덤 액세스는 다음과 같이 세 가지로 구분된다.

<br>

- **확인 랜덤 액세스**
    - WHERE 조건의 컬럼이 인덱스에 존재하지 않아 테이블을 액세스하는 랜덤 액세스를 확인 랜덤 액세스
    - 부가 설명
        
        만약, WHERE 조건에는 카드번호 조건과 거래일자 조건이 함께 있으며 인덱스는 카드번호 컬럼으로만 구성되어 있다고 가정하자. 이와같다면 카드번호 컬럼에 의해 인덱스를 액세스하게 될 것이다.
        
        결국, 카드번호 컬럼에 의해 처리 범위가 감소하게 된다. 그렇다면 거래일자 컬럼은 어떤 역할을 수행하게 되는가?
        
        분명 카드번호 조건을 만족하는 데이터 중 거래일자 조건을 만족하는 데이터만을 결과로 추출해야 할 것이다. 하지만, 카드번호 컬럼으로만 인덱스가 구성되므로 거래일자 조건을 인덱스에서 확인할 수 없게 된다.
        
        따라서, 카드번호 조건을 만족하는 모든 데이터에 대해 테이블을 액세스하여 거래일자 컬럼의 값을 확인해야 할 것이다.
        
<br>

- **추출 랜덤 액세스**
    
    WHERE절의 컬럼은 모두 인덱스에 존재하지만 SELECT 절의 컬럼이 인덱스에 존재하지 않는다면
    
    - SELECT 절의 컬럼을 결과로 추출하기 위해서는 반드시 인덱스 액세스 후 테이블을 액세스해야 할 것이다. 이와 같은 현상이 추출 랜덤 액세스이다.

<br>

- **정렬 랜덤 액세스**
    - ORDER BY 절 등에 사용된 컬럼이 인덱스에 존재하지 않아 테이블을 액세스하여 정렬을 수행하기 위해 데이터 를 액세스하는 랜덤 액세스를 발생시키는 경우를 정렬 랜덤 액세스 라고 한다.

<br>

## 메모리 상에서의 작업 수행

메모리가 아닌 HDD에 직접 액세스 하여 데이터 접근시 초당 10쿼리 밖에 처리할 수 없는 데이터 베이스라면 아무도 사용하지 않을 것이다

>→ 이를 위해 데이터 파일 중에서도 자주 사용되는 영역을 메모리에 캐시해 두어

빠른 액세스가가 완결될 수 있도록 해야한다.

<br>

**< 캐시 사용 >**

메모리의 크기가 윤택해 질 수록 캐시 가능한 데이터 양이 증가하게 되어 효율은 좋아진다.

>⇒ 하지만 메모리는 비싸며 탑재 수도 한정되기 때문에 실제어느 정도의 메모리가 필요한지는 애플리케이션의 데이터 뿐 아니라 데이터에 어떻게 접근해갈 것인가 (최신 데이터에 집중하는지, 골고루 사용되는지) 에 대해 의존한다.

>⇒ 이러한 구조는 DB한정이 아닌 OS에서도 같은 구조를 채용하고 있다.

<br>
<details>
<summary>캐시 복습</summary>

- 캐시 복습
    - 정의 : 데이터나 값을 미리 복사해 놓는 임시 저장소를 가리킨다.
    
    <br>

    - 언제 사용할까?
        - 속도가 다른 두 장치 사이에 속도차이를 메워주기 위해 사용 한다.
            
            >⇒ 각 계층간 속도 차이에 따른 병목현상으로 성능 저하를 완충해주기 위해 사용된다.
            
    
    <br>

    - 개념의 일반화
        - 식료품 창고와 집이 멀다고 가정했을때
            
            >⇒ 식료품 창고에서 사용할 식료품을 미리 집 내부의 냉장고에 넣어 둘때 여기서의 냉장고가 캐쉬의 개념이다.
    
    <br>

    - 캐시의 종류
        - 캐시 메모리
            - 대용량의 메인 메로리 접근을 빠르게 하기 위해 CPU 칩 내부나 바로 옆에 탑재하는 장치이다.
            - L1, L2, L3 캐시 등이 있다.
    
    <br>

    - 캐시 에서의 중요 개념
        - 지역성
            
            캐시가 효율적으로 동작하기 위해서는
            
            >⇒ 캐시의 적중률(Hit-rate)를 극대화 시켜야 한다.
            
            <br>

            - 캐시에 저장할 데이터가 지역성을 가져야 한다.
            - 지역성이란, **기억장치 내의 정보를 균일하게 Access 하는 것이 아닌** **어느 한 순간에 특정 부분을 집중적으로 참조하는 특성을 말한다.**

           <br>

        - 지역성의 종류
            - 시간적 지역성
                - 특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은것을 시간적 지역성이라고 한다.
                - 한번 가져왔던 데이터를 또 쓸일이 있다는 의미
                    
                    ⇒ 캐시해 한번 가져와 저장해 놓고 여러번 사용하게 되면 메모리 접근 횟수가 줄어들어 높은 효율성을 낼 수 있다.
                
                <br>    

            - 공간적 지역성
                - 특정 데이터와 가까운 주소가 순서대로 접근되었을 경우 공간적 지역성이라고 한다.
                - 앞으로 사용할 데이터들이 가져온 블록 안에 많이 모여있는 것을 의미
                    
                    >⇒ 필요한 데이터가 모여잇다면, 한번 메모리 접근시 그 블록을 캐시에 가져오면 캐시 히트 확률을 높힐 수 있다.
                    
                    >⇒ 만약 데이터가 여기저기 흩어져 있다면, 캐시 미스 확률이 높아지고 메모리에 여러번 접근되어 효율성이 떨어진다.
                    
                    <br>

        - 캐시는 메모리의 데이터를 임시로 가져온것
            
            >⇒ 그렇기에 캐시 데이터가 변경되면 메모리에 있는 데이터도 변경해야 한다.
            
            <br>

            - 즉시 쓰기(Write through)
                - 캐시에 있는 데이터가 변경되면 이를 즉시 메모리에 반영
                - 메모리와의 빈번한 데이터 전송으로 인해 성능이 느려진다는 단점.
                - 메모리에 최신값이 항상 유지된다는 장점.
                
                <br>

            - 지연 쓰기(copy back , write back)
                - 변경된 내용을 모아 주기적 반영하는 방식
                - 메모리와의 데이터 전송수가 줄어 시스템 성능 향상 장점.
                - 메모리와 캐시의 데이터 사이 불일치가 발생할 수 있다는 단점.
                
                <br>

    - 계층 구조에서의 캐시 의미
        - 개념
            - 속도가 다른 두 장치 사이에 속도차이를 메워주기 위해 사용
        - cpu - memory
            - CPU의 처리 속도와 메모리에서 데이터를 가져오는 속도가 달라 병목현상을 완충하기 위해 CPU내부에 캐시를 두고 메모리에서 미리 데이터를 가져와 캐시에 먼저 접근하는 것을 의미한다.
            
            <br>

    - 트레이드 오프
        - 장점
            - 캐시를 통해 데이터를 미리 복사해 두어 더 빠른 속도로 데이터 접근이 가능
        - 단점
            - 메모리 저장공간은 속도가 빠를 수록 용량이 작고 가격이 높다.
            
</details>

<br>

**< 액세스 성능 향상 >**

- 메모리는 한정적이기 때문에 HDD에 액세스가 이루어질때 하나의 HDD에 모든 데이터가 구성되어 있다면 초당 처리할 수 있는 쿼리 수는 크게 줄어들게게 된다.
- RAID구성을 만들어 병렬성을 올렸다해도 크게 변동 되지는 않는다
    
    >⇒ 그렇기에 데이터를 분할한다는 방침을 통해 취해야 하며 그 방법을 샤딩이라고 한다
    
<br>

<샤딩(sharding)>

![스크린샷 2022-06-23 오후 3.52.55.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b360e0cf-5439-496f-9c48-cd88cac0a49f/스크린샷_2022-06-23_오후_3.52.55.png)

샤딩(sharding)이란 하나의 거대한 데이터베이스나 네트워크 시스템을 여러 개의 작은 조각으로 나누어 분산 저장하여 관리하는 것을 말한다.

이는 단일의 데이터를 다수의 데이터베이스로 쪼개어 나누는 걸 말하는데, 단일의 데이터베이스에서 저장하기 너무 클 때 사용하여 데이터를 구간별로 쪼개어 나눔으로써

>→ 노드에 무겁게 가지고 있던 데이터를 빠르게 검증할 수 있어 빠른 트랜잭션 속도를 향상시킬 수 있다.

 샤딩을 통해 나누어진 블록들의 구간(epoch)을 샤드(shard)라고 부른다.

<br>

## CPU의 확장성 향상

프로그램 중에서는 동시에 하나의 스레드밖에 액세스 할 수 없도록 배타 제어를 해야하는 처리 구간이 존재한다

>⇒ 이러한 구간을 임계 영역이라고 한다.

<br>

멀티 CPU 코어 머신이라도 동시에 한개의 스레드 밖에 액세스 할 수 없기 때문에 이러한 구간에 대한 액세스 빈도가 높을 수록 멀티 코어를 활용할 수 없는 소프트웨어가 된다.

<br>

MySQL에서는 주로 C / C++ 사용하여 작성되었으며 **mutex**를 이용한 배타 제어를 하고 있다.

<br>

<DB의 lock에 대해 자세히 알아보자>

- Lock의 종류
    
    Lock은 상황에 따라서 크게 두가지로 나누어 진다.
    
    <br>

    1. Shared Lock(공유 Lock 또는 Read Lock)
        - Read Lock 이라고도 하는 공유락은 데이터를 읽을 때 사용하는 Lock 이다.
        - Database의 주요 기능인 데이터 일관성과 무결성을 해치지 않기 때문에
            
            Read Lock은 같은 Read Lock 끼리는 동시에 접근이 가능하다.
            
        - 사용자가 데이터를 읽어 갈 뿐, 데이터 변경이 없기 때문에 동시 접근이 가능하지만
        그 다음에 나올 Exclusive Lock의 접근을 막는다.
    
    <br>

    2. Exclusive Lock(배타적 Lock 또는 Write lock)
    
    - Write Lock이라고도 하는 베타락은 데이터를 변경할 때 사용하는 Lock이다.
    - 트랜잭션이 완료될 때까지 유지되며 Exclusive Lock이 끝나기 전까지 어떠한 접근도 허용하지 않는다.
    - 이 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서 접근하여 Lock을 걸 수 없다.

<br>

< Blocking >

![스크린샷 2022-06-23 오전 8.27.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/53ac757e-e0c6-4cc1-8a93-6dea580396f5/스크린샷_2022-06-23_오전_8.27.48.png)

블로킹은 Lock들의 경합(Race condition이라고도 합니다)이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태를 의미한다.

<br>

`공유Lock과 배타적Lock` 또는 `배타적Lock과 배타적Lock`끼리 블로킹이 발생할 수 있으며 이를 해결하는 방법은 Transaction commit 또는 rollback 뿐이다.

경합이 발생할 때, 먼저 Lock을 설정한 트랜젝션을 기다려야하기 때문에, 이런 현상이 반복되면 빠른 서비스를 제공할 수 없게 된다.

<br>

**해결방안**

1. SQL 문장에 가장 빠르게 실행되도록 리팩토링하는 것이 가장 기본이며 효과적인 방법이다.
2. 트랜잭션을 가능한 짧게 정의하면 경합을 줄일 수 있다.
3. 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계하는 것이 좋다.
또한 트랜젝션이 활발한 주간에는 대용량 갱신 작업을 수행하면 안된다.
4. 대용량작업이 불가피할 경우, 작업단위를 쪼개거나 `lock_timeout`을 설정하여 해당 Lock의 최대시간을 설정할 수 있다.

<br>

< 뮤텍스란? >

**뮤텍스(Mutex) : 상호 배제(Mutual Exclusion)를 뜻하는 말**로 **Critical Section을 가지는 쓰레드들의 Running time이 서로 겹치지 않도록 해주는 기법**

<br>

특징

- **뮤텍스는 1개의 스레드만이 공유 자원에 접근**할 수 있도록 합니다.
- 뮤텍스에서는**Lock과 Unlock개념을 사용**
    
    ⇒ 자원을 점유하고 있는 대상이 Lock을 할 수 있는 권한을 가지고 있어서 자원을 점유하기 시작할 때 들어가서 Lock을 걸어버린다. 
    
    ⇒ 이렇게 되면 다른 대상들은 Unlock 상태가 될 때까지 기다렸다가 나중에 해당 공유 자원에 접근할 수 있게 된다.

<br>    


## 백그라운드 처리

데이터 베이스에서는 애플리케이션에서 실행되는 쿼리 처리 외에도 백그라운드 실행해야 하는 작업이 몇가지 존재한다.

오라클은 인스턴스와 DB로 구성되어 있으며, 인스턴스에는 메모리 영역과 프로세스 영역으로 나눠져 있다.

<br>

프로세스 영역에는 전면에서 쿼리를 받아 수행하는 서버프로세스가 있으며, 전면에 나서지는 않지만 필수적으로 작동하는 백그라운드 프로세스들이 있다.

그 중 5가지 프로세스를 필수 백그라운드 프로세스라고 부른다.

<br>

**PMON(Process Monitor)**

- 오라클에서 사용되는 프로세스를 정기적으로 관리하고 감시하는 프로세스
- 비정상적으로 종료된 세션이 있다면 처리중이었던 데이터를 복구하고 정리하는 역할을 한다.
- 디스패치 프로세스와 서버 프로세스의 상태를 정기적으로 체크하고 실행이 정지된 프로세스가 있다면 재기동 한다.
- 인스턴스와 디스패처 프로세스에 관한 정보를 리스너에 자동적으로 등록 한다.

<br>

**SMON(System Monitor)**

- 오라클에서 사용되는 인스턴스의 상태를 감시하는 프로세스
- 인스턴스 기동 시 복구가 필요하면 인스턴스 복구(instance recovery)를 수행 한다.
- UNDO 세그먼트를 관리 한다. (크기가 커진 UNDO 세그먼트 축소 등)
- 다 사용한 Temp 세그먼트를 정리 한다.

<br>

**DBWR**

- DB buffer cache에 있는 내용을 data file(disk)에 내려쓰는 프로세스
- 내려씀으로써 DB buffer cache를 free 상태로 만들어 다시 사용할 수 있게 해준다.

<br>

**LGWR**

- redo log buffer에 있는 내용을 online redo log file에 내려 쓰는 프로세스
- LGWR이 내려쓰는 시점
- 3초마다
- 체크포인트 발생시
- 데이터베이스 commit 수행시
- 리두 로그 버퍼가 1/3이상 찼을 때
- 리두 로그 버퍼가 1m이상 일때
- DBWR이 내려쓰기 전

<br>

**CKPT**

- 체크포인트가 발생하면 컨트롤 파일의 헤더와 데이터 파일을 갱신하여 동기화를 시키는 프로세스

<br>

InnoDB에서는 위의 백그라운드 처리를 모두 단일 스레드에서 처리 하였지만

Mysql 5.5 부터 제거처리 외 체크포인트 두 스레드가 작업을 따로 수행하여 동시성을 높혔다.