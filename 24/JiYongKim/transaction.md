## 트랜잭션 이란?

- 트랜잭션 정의
    - 데이터베이스의 **상태를 변화**시키기 위해 수행하는 더이상 쪼개질 수 없는  **작업의 단위**를 뜻한다
        - 상태 변화
            - INSERT
            - DELETE
            - UPDATE
                
                ⇒ 위와 같은 SQL을 통해 데이터 베이스를 접근하는 것을 의미한다
                
                ⇒ 하지만 **작업의 처리의 단위**는 하나의 SQL으로 완결되는 일은 적으며
                
                여러 SQL문을 조합하여 하나의 작업을 처리하게 될때 그 묶음을 트랜잭션이라 일컫는다.
                
                ex) 상품 구매 프로세스 
                
                1. 상품 재고 가격 조사 ( item Table , inventory Table 접근)
                2. 자신의 구매한 제품 수 한개 늘리기 (user_item Table 접근)
                3. 소지하고 있는 돈 감소 (user Table 접근)
                4. 구매 내역 갱신 ( purchase_history Table 접근 )
                    
                    ⇒  하나의 상품 구매 작업을 처리하기 위해  위의 처리 과정을 하나의 작업의 처리 단위로 지정하게 되며 이러한 작업 단위를 트랜잭션이라고 한다
                    
                
- 트랜잭션의 특징 ACID
    - 원자성 (Atomicity)
        - 트랜잭션이 데이터베이스에 모두 반영되거나, 아니면 완전히 반영되지 않아야 한다는 것
            
            ⇒ 트랜잭션과 관련된 작업들이 부분적 완료되다가 중단되지 않게 하는 것을 보장
            
            ⇒ All or Nothing
            
    - 일관성 (Consistency)
        - 트랜잭션 작업 처리의 결과가 항상 일관되어야 한다는 것
            
            ⇒ 데이터 타입이 반환 후와 전이 동일해야 한다
            
            다시 말해, 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻이다.
            
            ex) **‘모든 고객은 반드시 이름을 가지고 있어야 한다’는 데이터베이스의 제약이 있다고 가정한다.**
            
            - **다음과 같은 트랜잭션은 Consistency(일관성)를 위반한다.
                1. 이름 없는 새로운 고객을 추가하는 쿼리
                2. 기존 고객의 이름을 삭제하는 쿼리데이터베이스의 유효한 상태는 다를수 있지만, 데이터의 상태에 대한 일관성은 변하지 않아야 한다.**
    - 독립성 (Isolation)
        - 둘 이상의 트랜잭션이 동시 병행 실행되고 있을때,
            
            어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
            
            ⇒ 각각의 트랜잭션은 독립적으로 수행되어야 한다.
            
    - 지속성 (Durability)
        - 트랜잭션이 성공적 완료시 영구적 결과에 반영되어야 한다.
            
            ⇒ 보통 commit 완료시 지속성은 만족 가능
            
    
- 트랜잭션의 기능
    - Commit & LollBack
        
        트랜잭션에는 
        
        - 내가 적은 쿼리문과 데이터를 최종적으로 데이터베이스에 반영하는 COMMIT과
        - 실패했을때 COMMINT 시점으로 다시 되돌아가는 ROLLBACK이 존재
        
        <img width="658" alt="스크린샷 2022-06-22 오후 3 56 06" src="https://user-images.githubusercontent.com/81874493/174964323-5891f591-c1c9-4d8a-877d-bad05f99af6e.png">

        1. 활동 : 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태
        2. 실패 : 트랜잭션이 실행에 오류가 발생하여 중단된 상태
        3. 철회 : 트랜잭션이 비정상적으로 종료되어 ROLLBACK 연산을 수행한 상태
        4. 부분적 완료 : COMMIT 연산이 실행되기 직전의 상태로 아직 작성한 것들을 저장하지 않은 상태
        5. 완료 : 트랜잭션이 성공적으로 종료되어 COMMIT 연산을 실행한 후의 상태
        
        - Commit
            - 완전 저장
            - COMMIT이란 모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어로 처리과정을 **DB에 영구 저장**하는 것
            - COMMIT을 수행하면 하나의 트랜잭션 과정을 종료하는 것
            - COMMIT을 수행하면 이전 데이터가 완전히 UPDATE 된다.
            
            <img width="624" alt="스크린샷 2022-06-22 오후 3 56 14" src="https://user-images.githubusercontent.com/81874493/174964334-a1a33231-1a73-4b26-93ed-6a72e16dd0d3.png">

            - 위 그림에서 첫번째 COMMIT후 그 뒤에 UPDATE 문으로 데이터를 갱신하고(3), DELETE문으로 데이터를 삭제하고(4), INSERT 문을 사용해 데이터를 삽입(5)한다.
                
                ⇒ 만약 이 모든 과정이 오류 없이 수행되었다면 지금까지 실행한 모든 작업(3,4,5)을 데이터베이스에 영구 저장하라는 명령으로 COMMIT을 수행한다.
                
        - ROLLBACK
            - **ROLLBACK은 작업 중 문제가 발생되어 트랜잭션의 처리과정에서 발생한 변경사항을 취소하는 명령어 이다.**
            - 트랜잭션이 시작되기 이전의 상태로 되돌린다.
                
                ⇒ 즉, 마지막 COMMIT을 완료한 시점으로 다시 돌아가 COMMIT하여 저장한 것만 복구한다.
                
                <img width="590" alt="스크린샷 2022-06-22 오후 3 56 19" src="https://user-images.githubusercontent.com/81874493/174964352-5bdb5d6a-912d-4c83-90be-c8690971e4ed.png">

            - 위 그림에서 ROLLBACK 명령은 마지막으로 수행한 COMMIT 명령까지만 청상처리(1,2)된 상태로 유지한다.
            - 그 이후에 수행했던 모든 DML 명령어 작업(3,4,5)들을 취소시켜 이전 상태로 원상 복귀 시킨다.
            - 트랜잭션은 이렇든 ALL-OR-Nothing 방식으로 DML 명령어들을 처리한다.
            - ALL-OR-Nothing이란 '모든것을 수행하던가 아무것도 하지말라'라는 의미.
    
    - 무정지성 확보
        - 트랜잭션의 두번째 기능은 무정지성의 향상이다.
            
            무정지성 : OS 장애 등 서버 장애 발생하여 이로부터 DB를 재기동할 때 [장애 직전까지의 커밋 결과를 손실하지 않고 마치는 것이 가능하게 하는 것
            
            ⇒ 트랜잭션을 지원하지 않는 DB 경우 OS장애 뿐 아니라 DB 프로세스가 비정상 종료하기만해도 DB가 손상될 수 있다.
            
            ⇒ 또한, 깨진 DB는 복구하려고 해도 일부 데이터가 없어지거나 완전히 복구되지 않는 등 완전한 회복이 불가능 한 경우도 존재한다.
            
            여기서 무정지성을 보장하도록 하는 기술이 [**REDO 로그를 이용한 아키텍처]** 이다.
            
        - Redo log
            - Redo log과 DB구성 그리고 데이터를 디스크에 기록
                
                ## redo.log
                
                <img width="593" alt="스크린샷 2022-06-22 오후 3 56 28" src="https://user-images.githubusercontent.com/81874493/174964374-029d7316-9efb-4e2f-82ac-7c5cb43512ee.png">

                ORACLE_BASE 아래 oradata 디렉토리를 보면 redo.log 파일들이 있다.
                
                ⇒ 이 파일들은 **Recovery 작업을 하기 위해 Oracle의 Background Process인 LGWR(Log Writer)가 수시로 입력해주고 있는 파일** 이다.
                
                ---
                
                ## **Oracle Databas 구성과 데이터를 디스크에 쓰기**
                
                <img width="592" alt="스크린샷 2022-06-22 오후 3 56 35" src="https://user-images.githubusercontent.com/81874493/174964403-d9da55cd-160a-4d19-af33-74a45c5fc256.png">

                Oracle Database의 구조는 크게 3가지 구성요소를 갖고 있다.
                
                - **Control File**
                    
                    ⇒ DB의 물리적 구조에 대한 정보를 갖고 있다.
                    
                - **DB File**
                    
                    ⇒ 실제 테이블의 데이터를 갖고 있다.
                    
                - **Redo Log File**
                    
                    ⇒ Redo Log Buffer가 기록하는 모든 데이터베이스의 변경사항을 파일로 저장한다.
                    
                
                ---
                
                ## **LGWR(Log Writer)**
                
                <img width="598" alt="스크린샷 2022-06-22 오후 3 56 43" src="https://user-images.githubusercontent.com/81874493/174964429-677eab99-cf78-409b-8ab2-b2a807cf8b98.png">

                **LGWR은 LOG BUFFER에 저장되는 데이터베이스의 변경사항을 로그파일로 기록한다.**
                
                그 로그 파일이 redo.log 파일이고 계속 생성되는 것이 아니라 각 데이터베이스 서버마다 갯수가 다르지만 redo.log 파일은 **기본 2개는 있어야 한다**. 
                
                ## Log Sequence Number
                
                **각 redo.log 파일 그룹에는 순차적인 번호**가 있다. 
                
                이 번호는 LGWR 프로세스가 낮은 번호의 그룹을 사용하기 위해 사용되기도 하지만, Database Buffer Cache에 변경된 내용이 얼마나 DB File에 적용되었는지 확인하기 위한 번호이기도 하다.
                
                ⇒ 즉, 비정상적인 종료나 문제가 생겼을 경우 **회복하기 위한 용도**로 사용된다.
                
                ## **Log Switch Event**
                
                <img width="594" alt="스크린샷 2022-06-22 오후 3 56 50" src="https://user-images.githubusercontent.com/81874493/174964443-8d958be0-422e-4516-910f-26f598b531eb.png">

                계속해서 그룹1에 변경된 내용을 기록하면 언젠가는 기록할 공간이 부족하게될 시기온다.
                
                이때 **Log Switch라는 이벤트가 발생**하는데, **다른 그룹으로 대상을 변경하여 기록**하는 것 이다. Log Switch Event가 발생하면 Checkpoint Event라는 것이 발생하고
                
                Checkpoint 이벤트가 발생하면서 사용하게되는 그룹의 Log Sequence Number를 이전에 사용하던 그룹의 번호보다 하나 높은 번호로 변경된다.
                
                ## **Checkpoint Event**
                
                <img width="602" alt="스크린샷 2022-06-22 오후 3 56 56" src="https://user-images.githubusercontent.com/81874493/174964463-f7d5aab7-d95b-4080-86d1-e97078e24e86.png">

                **Checkpoint Event는 DBC 메모리의 변경된 정보를 실제 물리 DB File에 적용하는 이벤트이다.**
                
                 그럼 Checkpoint Event가 완료되면 redo log file는 어떻게 될까?
                
                redo log file은 회복을 위해 사용되는데 만약 DBC와 DB File안에 있는 내용이 일치한다면 그룹1의 내용은 더 이상 필요 없는 내용이된다.
                
                즉, **Checkpoint가 전진** 되었기 때문에 더 이상 이전 내용은 필요 없게되버린다.
                
                RPG게임을 하다가 저장하게 되면 저장한 시점으로의 데이터만 필요하지 더 이상 이전의 저장내용이 필요 없듯이, 없어도 되는 로그내용이 되어버린다.
                
                ## **Log File Full**
                
                <img width="588" alt="스크린샷 2022-06-22 오후 3 57 01" src="https://user-images.githubusercontent.com/81874493/174964489-2d152df8-8f4c-468c-9f02-1806e36f935e.png">

                Checkpoint의 전진으로 더 이상 필요없게되버린 Group1의 내용을 위의 이미지에 이어서 생각해본다면,
                
                 만약 group1을 전부 사용하고 Log Switch가 발생해서 Group2에다 기록하다가 **Group2까지 더 이상 기록할 공간이 없다면 어떻게 해야할까?**
                
                Checkpoint Event가 발생해서 Log Switch Event가 다시 발생하고 **더 이상 필요없는 내용이 되어 버린 Group1에 Overwrite하여 기록**을 계속하게 된다.
                
                그럼 **Log Switch를 하려고하는데 Checkpoint Event가 끝나지 않았을 경우에는**
                
                 **Checkpoint Event가 완료될때까지 기다려야한다.**
                
                <img width="523" alt="스크린샷 2022-06-22 오후 3 57 09" src="https://user-images.githubusercontent.com/81874493/174964511-2042b8c7-2727-4ad1-965b-8b48093b2f26.png">

                **1. Log Switch 발생 --> Checkpoint Event**
                
                Log Switch 발생
                
                **2. Checkpoint Event**
                
                DBC 메모리의 변경 내용을 DB File에 적용하고 작업이 끝나면 CKPT에게 끝났다고 신호 전송
                
                **3. Control File 기록**
                
                Control File에 Checkpoint SCN을 기록
                
                **4. DB File Header 기록**
                
                모든 DB File Header에 Checkpoint SCN 정보를 기록
                
                Checkpoint 이벤트가 발생하면 위 흐름대로 계속 반복한다.
                
                그런데 만약 2번의 작업이 끝나지도 않았는데 Log Switch가 발생해서 다시 Checkpoint Event가 발생했고 그룹은 2개 밖에 없을때는 **이전 Checkpoint 작업이 끝날때까지 대기** 해야 한다.
                

---

## Lock mechanism

## 공유 자원

그렇다면 위의 “경합조건”에서의 공유자원이 하나의 계좌인것 처럼

⇒ 컴퓨터 분야에서 공유자원은 어떤게 될 수 있을까?

예시)

- 스레드간 공유 메모리
    
    ⇒ 한 프로세스내 여러 스레드는 메모리의 코드, 데이터 힙 영역을 공유하여 사용한다.
    
    ⇒ 스레드간 공유 자원 ( 메모리 ) 접근에 있어 동기화 문제가 있다.
    
    ⇒ ( 참고, 스레드는 독립적인 작업의 흐름이기에 각자의 스택과 PC(Program Counter)는 따로 할당된다.)
    

- 프린터 공유
    
    ⇒ 여러 사용자들이 하나의 프린터를 공유하여 사용한다.
    
    ⇒ 여러 사용자들의 문서가 프린터에서 뒤섞인다면 제대로 작동하지 않는다.
    

⇒ 위와 같은 공유 자원을 사용함에 있어 늘 공유 자원 접근시에 문제가 뒤따른다.

## 임계 영역 ( Critical Section)

( 아래의 내용은 프로세스 뿐 아니라 스레드도 포함되는 내용 인지)

**임계영역(Critical Section)**

정의 : 프로세스간 공유 자원 접근 하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 접근 할 수 있도록 보장 해주어야 하는 영역을 말한다.

**임계영역을 해결하기 위한 3가지 조건**

⇒ 임계 영역을 문제를 해결 하기 위해 3가지 조건을 충족하여야 한다.

- 상호 배재 ( Mutual Exclusion )
    - 하나의 프로세스가 임계영역에 접근 하였을 경우 다른 프로세스는 접근할 수 없어야 한다.
- 진행 ( Progress )
    - 현재 이용하지 않는 임계영역에 접근하는 프로세스가 여러개라면 어떤 프로세스가 들어가야 할지 결정해주어야 한다.
- 한정 대기 ( Bounded Waiting )
    - 다른 프로세스의 기아(Starvation)현상을 방지하기 위해 임계영역에 들어간 프로세스는 다음 임계영역에 들어갈 때 제한을 두어야 한다.

**임계 영역 동시 접근 해결 방법**

- Lock
- Semaphore
- monitor
    
    .. 등이 있다. 
    

## **프로세스 동기화**

정의 : 협력하는 프로세스 사이에서 실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것

⇒ 다르게 말하면 동기화는 프로세스들이 서로 동작을 맞추고 정보를 공유하는 것을 의미

**동기화의 도구**

- 락(lock)
    
    동시에 공유 자원 접근 하는것을 막기 위해 임계 구역에 진입하는 프로세스는 Lock을 획득하고 임계구역을 빠져나올때, Lock을 방출함 으로서
    
    ⇒ 동시 접근 되지 않도록 적용하는 방법
    

## Lock

**Lock이란 트랜잭션 처리의 순차성을 보장하기 위한 방법**입니다.

중요한 것은 DBMS마다 Lock을 구현하는 방식과 세부적인 방법이 다르다.

⇒  따라서 DBMS를 효과적으로 이용하기 위해서는 해당 DB의 Lock에 대한 이해가 요구된다.

## Lock의 종류

**Lock의 종류로는 공유(Shared) Lock과 베타(Exclusive) Lock이 있습니다. 공유락은 다른 말로 Read Lock이라고 불리며 베타락은 Write Lock이라고도 불린다.**

- 공유(Shared) Lock
    
    **공유 Lock은 데이터를 읽을 때 사용되어지는 Lock이**다. 이런 **공유 Lock은 공유 Lock 끼리는 동시에 접근이 가능**하다.
    
    ⇒  즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다라는 것 이지만  공유 Lock이 설정된 데이터에 베타 Lock을 사용할 수는 없다.
    
- 베타(Exclusive) Lock
    
    **베타 Lock은 데이터를 변경하고자 할 때 사용**되며, 트랜잭션이 완료될 때까지 유지된다.
    
    ⇒ **베타락은 Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없으며**  해당 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없다.
    

## 블로킹(Blocking)

<img width="688" alt="스크린샷 2022-06-22 오후 3 57 19" src="https://user-images.githubusercontent.com/81874493/174964542-44ef1ec5-fe1f-44f7-9d78-61553bcb79c1.png">

**블로킹은 Lock간(베타 - 베타, 베타 - 공유)의 경합이 발생하여 특정 Transaction이 작업을 진행하지 못하고 멈춰선 상태**를 말한다.

공유락 끼리는 블로킹이 발생하지 않지만 베타락은 블로킹을 발생시킨다.

블로킹을 해소하기 위해서는 이전의 트랜잭션이 완료(커밋 OR 롤백)되어야 한다.

또한, 뒤에 들어온 트랜잭션은 이전 트랜잭션이 마무리되어야 이후 진행이 가능하다.

[DB를 사용하는 프로그래밍을 진행하면서 몇가지 주의사항]

1. 한 트랜잭션의 길이를 너무 길게하는 것은 경합의 확률을 올립니다.
2. 처음부터 설계할 때 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 해야합니다.
3. 쿼리를 오랜시간 잡아두지 않도록 적절한 튜닝을 진행합니다.
    
    이외에 DBMS에 따라서 lock 대기 시간 등을 설정할 수 있습니다.
    

### 동기화로 인해 발생하는 문제

- 교착상태 (Dead Lock)
    - 두 개 이상의 프로세스가 어떤 사건을 기다리고 있는데,
        
        같이 기다리는 프로세스 중 하나만이 그 사건을 발생시킬 수 있는 상황이다.
        
    - 교착상태 원인과 방지
        - 원인
            
            교착 상태는 공유자원과 이 자원을 함께 사용하는 프로세스나 스레드가 아래의 4가지 조건을 모두 충족할 경우 교착 상태가 발생한다.
            
            - 상호배제 : 공유 자원을 함께 사용할 수 없어 어느 한 프로세스가 독점적으로 사용 해야한다.
            - 점유 대기 : 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청한다.
            - 비선점 : 프로세스가 할당 받은 자원을 강제로 빼앗을 수 없다.
            - 순환 대기 : 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구한다.
                
                ⇒ 위의 4가지중 하나라도 충족되지 않으면 교착 상태가 발생하지 않는다.
                

## 교착상태(DeadLock)

<img width="513" alt="스크린샷 2022-06-22 오후 3 57 26" src="https://user-images.githubusercontent.com/81874493/174964558-b0658f03-e7d1-4605-95b7-6d760433160f.png">

**교착상태는 두 트랜잭션이 각각 Lock을 설정하고 다음 서로의 Lock에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 Lock이 설정되어 있기 때문에 양쪽 트랜잭션 모두 영원히 처리가 되지않게 되는 상태**를 말한다.

**그래서 교착상태가 발생하면 DBMS가 둘 중 한 트랜잭션에 에러를 발생시킴으로써 문제를 해결하며 교착상태가 발생할 가능성을 줄이기 위해서는 접근 순서를 동일하게 하는것이 중요하다.**

 

# 교착 상태 해결 방안

DB(데이버베이스)에서 교착상태(Dead Lock)을 해결하기 위한 방법은 아래와 같다.

- 예방 기법
- 회피 기법
- 낙관적 병행 제어 기법
- 빈도 줄이기 기법

# 예방 기법

대표적인 예방 기법은 아래와 같다.

- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 Lock(잠금)한다.
    - 필요한 모든 데이터를 Lock(잠금)해야 하므로 병행성이 떨어진다.
- SET LOCK_TIMEOUT문을 통해 일정 시간이 지나면 쿼리를 취소한다.
    - 기존의 교착상태인 데이터가 있다면, 그 데이터에 접근하는 쿼리만 취소한다.
    - 즉, 근본적인 해결책이 될 수 없다.

# 회피 기법

**회피 기법은 자원을 할당할 때 시간 스탬프(Time Stamp)를 활용해서 교착상태가 일어나지 않도록 회피하는 방법**이다. 예방 기법의 단점 때문에 실제로는 회피 기법이 많이 사용된다.

회피 기법의 종류는 크게 2가지가 있다.

- Wait-Die 방식
    - 트랜잭션 A가 트랜잭션 B에 의해 잠금된 데이터를 요청할 때 트랜잭션 A이 먼저 들어온 트랜잭션이라면 대기(Wait)한다.
    - 트랜잭션 A가 나중에 들어온 트랜잭션이라면, 포기(Die)하고 나중에 다시 요청한다.
- Wound-Wait 방식
    - 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이라면, 데이터를 선점(Wound)한다.
    - 반면, 트랜잭션A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(Wait)한다.

# 낙관적 병행 제어 기법

낙관적 병행 제어 기법은 트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백(Rollback)하는 방법이다.

즉, 낙관적 병행 제어 기법은 **판독->확인->기록** 단계를 따른다. **확인 단계**를 성공적으로 거친 트랜잭션만  **기록 단계**를 수행할 수 있다.

# 빈도 줄이기

교착상태의 빈도를 낮추는 방법은 아래와 같다.

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. (위에서는 트랜잭션 1은 B->A 순, 트랜잭션 2는 A->B순으로 접근했다.)
- 읽기 잠금 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 테이블 단위의 Lock(잠금)을 획득해 갱신을 직렬화한다. (테이블의 복수행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 자주 발생하기 때문)
- Index 설계 (Update시 Index를 타지 않으면 테이블 전체에 Lock이 걸릴 수 있다.)
- Isolation level(고립 수준)을 낮춘다. (서비스 검토 필요)
