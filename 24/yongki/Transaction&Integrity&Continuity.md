# 트랜잭션과 무결성·무정지성

- [트랜잭션과 무결성·무정지성](#트랜잭션과-무결성무정지성)
  - [점검요소](#점검요소)
  - [개요](#개요)
    - [사용 이유](#사용-이유)
    - [주의사항](#주의사항)
    - [단일 SQL문이라면 트랜잭션이 필요없는가](#단일-sql문이라면-트랜잭션이-필요없는가)
    - [ACID 특성](#acid-특성)
  - [트랜잭션 격리 수준](#트랜잭션-격리-수준)
  - [복구지점을 어떻게 식별하는가](#복구지점을-어떻게-식별하는가)
    - [복제와 연관성](#복제와-연관성)
  - [참고 문헌](#참고-문헌)

## 점검요소

- 트랜잭션 기능이 없으면 어떻게 곤란한가
- 어떤 작업이 늘어나는가

## 개요

<center>
<img width="50%" src="assets/rollback&commit.png"/>
</center>

트랜잭션은 Script 이다.

    즉, Script 내에 1 → 2 → 3 각 단위가 절차적으로 수행된다.

    각 단위는 단일 SQL문을 의미한다.

### 사용 이유

데이터 부정합은

    SQL문 질의와 데이터 반영 사이에 장애가 발생하여

    질의의 의도대로 데이터 반영이 이뤄지지 않을 때를 말한다.

데이터 부정합을 방지하고자

    복구하는 작업을 애플리케이션에서 하거나
    
    사전에 방지하고자 테스트로 대비하는 것도 가능하겠지만

데이터 부정합을 간편하게 방지하고자 사용한다.

    원자성(Atomicity: All or Nothing)을 유지하기 위해

    트랜잭션 내의 모든 단위는 수행이 모두 성공적이거나, 반대로 모두 실패해야한다.

롤백(Rollback)은

    단위 중에 장애가 발생한 경우, 트랜잭션의 첫 단위로 돌아오는 것을 말한다.

트랜잭션에서 발생하는 장애란

    사용자 요청으로 인한 철회
    
      - 잘못된 입력
      - 일관성 제약 조건 위배

    DBMS로 인한 철회

      - 타임 아웃
      - 데드락

커밋(Commit)은

    트랜잭션 내 모든 단위가 성공적이면 디스크에 반영하는 것을 말한다.

### 주의사항

데이터베이스의 커넥션의 개수는 제한적이다.

    트랜잭션의 단위가 커넥션을 소유하는 시간이 길어질수록 여유 커넥션의 개수는 줄어들것이며

    어느 순간 커넥션을 기다려야하는 상황이 발생할 수 있다.

다음 내용은 사용자가 게시판에 게시물을 작성한 후 저장 버튼을 클릭했을 때

서버에서 처리하는 내용을 순서대로 정리한 것이다.

제외할 수 있는 단위를 제외해보자.

    1) 처리 시작
        
    → 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
    → 트랜잭션 시작

    2) 사용자의 로그인 여부 확인

    3) 사용자의 글쓰기 내용의 오류 여부 확인

    4) 첨부로 업로드된 파일 확인 및 저장

    5) 사용자의 입력 내용 DBMS에 저장
    
    6) 첨부 파일 정보를 DBMS에 저장

    7) 저장된 내용 또는 기타 정보를 DBMS에서 조회

    8) 게시물 등록에 대한 알림 메일 발송

    9) 알림 메일 발송 이력을 DBMS에 저장
        
    ← 트랜잭션 종료
    ← 데이터베이스 커넥션 반납

    10) 처리 완료

정답은

    1-4번은 트랜잭션이 필요없다.

    5-6번은 반드시 하나의 트랜잭션으로 처리해야한다.

    7번은 조회이므로 트랜잭션이 필요없다.

    8-9번은 별도의 트랜잭션으로 처리하지만, 네트워크 통신은 트랜잭션에서 배제하는 것이 좋다.

    통신되지 않는 상황이 발생하면 DBMS 까지 영향을 받기 때문이.

재정리하면

    1) 처리 시작

    2) 사용자의 로그인 여부 확인

    3) 사용자의 글쓰기 내용의 오류 여부 확인

    4) 첨부로 업로드된 파일 확인 및 저장

    → 데이터베이스 커넥션 생성
    → 트랜잭션 시작

    5) 사용자의 입력 내용 DBMS에 저장
    
    6) 첨부 파일 정보를 DBMS에 저장

    ← 트랜잭션 종료

    7) 저장된 내용 또는 기타 정보를 DBMS에서 조회

    8) 게시물 등록에 대한 알림 메일 발송

    → 트랜잭션 시작

    9) 알림 메일 발송 이력을 DBMS에 저장

    ← 트랜잭션 종료
    ← 데이터베이스 커넥션 반납

    10) 처리 완료


### 단일 SQL문이라면 트랜잭션이 필요없는가

필요하다.

    단일 SQL문이라도 내부에서 복수의 작업을 수행하기 때문이다.    

**단일 SQL문이 여러 레코드를 업데이트 하는 경우**

> 부제에서 복수의 작업 유추 가능

**단일 SQL문이 하나의 레코드만 업데이트 하는 경우**

인덱스가 있는 테이블이라면, 갱신 대상이 레코드 외에 인덱스도 해당 된다.

**단일 SQL문이 인덱스가 없는 테이블의 하나의 레코드만 업데이트 하는 경우**

하나의 레코드의 각 컬럼의 물리적 저장 위치가 다를 수 있다.

### ACID 특성

 **Atomicity 보장**

    트랜잭션에 의해 변경된 내용은 잠시 메모리에 유지하는데 

    트랜잭션에 오류가 발생하면 메모리를 날려버림으로써 이전 커밋된 디스크에는 간섭하지 않는다.

**Consistency 보장**

    트랜잭션 수행 전, 후에 데이터 모델의 제약 조건을 만족하는 것을 보장한다.

    cf. 칼럼 타입을 바꾼다고 하였을 때 이를 참조하는 테이블도 변경이 되어야한다.

**Isolation 보장**

<table>
    <tr>
        <td>
<p>

    여러 트랜잭션이 공통된 데이터를 조작할 때 locking으로 보장한다.

    단, 성능을 위해 병렬로 처리할 수 밖에 없는 상황에서는

    작업이 지속될 수 있는 대안도 제공된다.   
    
</p>
        </td>
        <td align="center">        
            <img width="60%" src="assets/transaction-isolation-example.jpg"/>
        </td>
    </tr>
</table>

locking 이란

    데이터를 읽거나 쓸때는 문을 잠궈서 다른 트랜잭션이 접근하지 못하도록한다.

    조작을 마치면 unlock을 통해 다른 트랜잭션이 접근할 수 있도록 허용한다.

lock과 unlock을 잘못 사용하여 deadlock 상태에 빠지지 않도록 주의해야한다.

**Durability 보장**

    성공적인 트랜잭션은 커밋을 통해 영속성을 보장받는다.

## [트랜잭션 격리 수준](https://slides.com/kimyongki/deck-221254/fullscreen)    

`MySQL5.5(InnoDB)`에는 격리 수준을 `MVCC(Multi Version Concurrency Control)`로 구현하였다.

    locking을 사용하지 않아, 지속된 작업이 가능하게 한다.

    하나의 레코드에 대해 2개의 버전이 디스크와 메모리(Undo 로그)에 유지되고, 격리 수준에 따라 달라진다.
    
소개하는 순서대로 `격리 수준`이 높아지며, 그만큼 `동시 처리 성능`도 떨어진다.

|                  | DIRTY READ | NON-REPEATABLE READ |    PHANTOM READ    |
| :--------------: | :--------: | :-----------------: | :----------------: |
| READ UNCOMMITTED |    발생    |        발생         |        발생        |
|  READ COMMITTED  |     X      |        발생         |        발생        |
| REPEATABLE READ  |     X      |          X          | 발생<br>(InnoDB X) |
|   SERIALIZABLE   |     X      |          X          |         X          |

<table>
    <tr>
        <th>DIRTY READ</th>
        <th>PHANTOM READ</th>
    </tr>
    <tr>
        <td>
            <img src="assets/dirty-read.png">
        </td>
        <td>
            <img src="assets/phantom-read.png">
        </td>
    </tr>
    <tr>
        <td>
<p>

    롤백 이전에 데이터를 조회하는 경우이다.

    즉, 진행중인 데이터를 의미하며 
    
    재개된 트랜잭션이 커밋되어 온전해질수도, 

    커밋되지 않아 온전해지지 않을 수도 있다.
</p>
        </td>
        <td>
<p>

    트랜잭션 동안 조회한 레코드가 변하지는 않지만

    다른 레코드가 추가되거나 삭제될 수 있다.
</p>
        </td>
    </tr>
</table>

**READ UNCOMMITTED**

    T1으로 인해 변경된 내용을 커밋과 롤백 여부에 상관 없이 T2에서 읽을 수 있다.

1. 사용자 A는 Lara를 INSERT 한다.
2. 사용자 A의 변경된 내용을 커밋하기 이전에, 사용자 B는 SELECT 하고 있다.
3. 사용자 B는 사용자 A의 커밋되지 않은 상태의 테이블에 SELECT가 가능하다.
4. 사용자 A가 롤백을 한다면, 사용자 B는 여전히 Lara를 정상적인 데이터라고 생각한다.

**READ COMMITTED**

    T1으로 변경된 내용을 커밋되기 전까지 T2에서 조회할 수 없다.

1. 사용자 A는 Lara를 Toto로 변경하였다.
2. Toto는 디스크에 즉시 기록되고, Lara는 Undo 로그로 백업된다.
3. 사용자 A가 커밋되기 이전에, 사용자 B의 SELECT는 Lara로 조회된다.
4. 커밋 이후는 사용자 B의 SELECT는 Toto로 조회된다.

**REPEATABLE READ**

MySQL에서 사용하는 방식이다.

    트랜잭션마다 트랜잭션 ID를 부여하여 현 ID보다 작은 ID에서 변경한 것만 읽게 한다.   

## 복구지점을 어떻게 식별하는가

> 지난 스터디 때 레플리카가 구성된 구조에서 온라인 백업이 가능하단걸 봤고,
> 
> 단일 서버로 구성된 구조에서 RAID로 온라인 백업이 가능한가에 대해 결론을 짓지 못했다.
> 
> RAID만 봤을시, 잘못된 데이터를 복제 해둘 수 있어 정상적인 복구는 할 수 없을 가능성이 있기 때문이다.

`MySQL5.5(InnoDB)`를 기준으로 가능함을 기술한다.

<div align="center">
<img width="60%" src="assets/recovery.jpg">
</div>

트랜잭션을 커밋하면 그때마다 LSN(Log Sequence Number)이 증가하고.

REDO 로그 파일이라는 곳에

    LSN과 갱신된 디스크의 데이터 블록을 기록한다.

    즉, REDO 로그 파일에는 최신 커밋 정보가, 
    
        데이터 파일에는 커밋이 반영되기 전 정보를 가진다.

장애 이후 재기동을 했을때,

    데이터 파일에 가장 오래된 LSN을 가진 데이터 블록부터 
    
    REDO 로그 파일을 순서대로 대응하며 복구한다.

> 앞서 등장한 UNDO 로그와 비교하자면
> REDO 로그는 갱신 후의 값을 디스크에 기록하며 필자는 큐와 같은 역할이라 생각하며,
> UNDO 로그는 갱신 전의 값을 메모리에 기록하며 캐시와 같은 역할이라 생각한다.

### 복제와 연관성

<div align="center">
<img width="60%" src="assets/related-replication.png">
</div>

<hr/>

## 참고 문헌

[트랜잭션 개요](https://www.youtube.com/watch?v=7yuGlqPo8XQ&list=PLXvgR_grOs1DEoZFABFCjo7dsXt1BhVih&index=6) ━ *Youtube 「널널한 개발자」*

[트랜잭션 개요](https://victorydntmd.tistory.com/129?category=687930) ━ *Tistory 「victolee」*

[트랜잭션 격리수준](https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation) ━ *「Nesoy 블로그」*

[Dirty read vs Phantom read](https://stackoverflow.com/questions/11043712/what-is-the-difference-between-non-repeatable-read-and-phantom-read) ━ *Stack overflow*

[REDO 로그 vs UNDO 로그](https://velog.io/@pk3669/Mysql-Redo-Undo-Log) ━ *velog*

[REDO 로그 vs 바이너리 로그](http://jongguheo.blogspot.com/2019/10/binary-log-redo-log.html) ━ *Blogger*