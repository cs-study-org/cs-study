# Chapter 5 : 가용성과 데이터의 복제

## 가용성

- 시스템이 서비스를 정상적으로 제공할 수 있는 상태
- 항상 서비스 할 수 있는 시스템을 가용성이 높은 시스템이라고 한다.

<br>

## DB의 크래쉬

24시간 365일 끊임 없이 액세스가 발생하거나 많은 트래픽이 발생하는 서비스와 같이

[<U>**언제든지 필요할 때 동작해야 하는 서비스**</U>]에서는

장애에 대한 대책을 필요로 한다.

<br>

**전형적 장애 종류**

- 소프트웨어 장애
    
    >⇒ Mysql등과 같은 데이터베이스 프로그램의 폭주 나 충돌과 같은 소프트웨어 주변의 결함으로 인해 서비스를 제공할 수 없는 유형의 장애
    
    <br>

- OS 장애
    
    >⇒ Windows의 블루 스크린이나 Linux에서의 커널 패닉과 같은 OS 주변의 장애로 인해 서비스를 제공할 수 없게 되는 장애
   
    <br>

- 하드웨어 장애
    
    >⇒ HDD와 같은 물리적 작동하는 장치들이 오랜 시간으로 인해 고장이 나 서비스를 제공할 수 없게 되는 장애
    
    <br>

- 조작 실수
    
    >⇒ 사용자가 테이블을 지워비리는 식의 조작 실수로 인해 제공해야할 서비스의 장애가 일어나는 경우
    
    <br>

**데이터 손실 방지**

위와 같은 장애들을 발생시키지 않는 것이 최선이긴 하지만,

현실적 발생 확률을 제로로 하는 것은 불가능

<br>

또한, 서비스를 운영하는 관점에서

[장애가 발생해도 서비스를 제공할 수 있도록 설계하는 것] 에 중점을 두어야 한다

특히 장애 대책 중에서도 중요한 것은 <U>**데이터 손실 방지**</U> 이다.

>⇒ 데이터를 잃어버리면 서버 복구되었어도 필요 데이터가 없어 서비스 제공을 할 수 없기 때문

>⇒ 따라서 장애중에서도 데이터 손실을 막기 위한 대책이 결정적으로 중요하다.

<br>

- 데이터 손실 대책 방안
    - RAID
        - HDD는 하드웨어중 가장 고장률이 높은 부품이다
            
            >⇒ 그래서 하나의 서버에 여러 개의 HDD를 탑재하고 동일한 데이터를 두개 이상의 HDD에 분산시키는 기술
            
            | 방식 | 설명 |
            | --- | --- |
            | RAID 0 (스트라이핑) | 복수의 HDD에 데이터를 기록하여 읽고 쓰기를 고속화시키는 방식
            ( 이용 용량 : 디스크의 개수 ) |
            | RAID 1 (미러링) | 두대의 HDD에 동일 데이터를 작성하는 방식
            ( 이용 용량 : 디스크의 개수/2 ) |
            | RAID 5 | 오류 정정 패리티 데이터와 함께 분산하여 기록하는 방식
            ( 이용 용량 : N개의 경우 N-1 ) |
            | RAID 6 | 오류 정정 패리티 를 두개 생성하고 데이터와 함께 분산하여 기록하는 방식 
            ( 이용 용량 : N개의 경우 N-2 ) |
    - 서버 이중화
        - 장애의 원인이 CPU 고장, 커널 패닉, 데이터 베이스 프로세스 장애와 같은 경우 RAID 구성을 해두어도 서버가 하나밖에 없으면 시스템은 즉시 다운된다.
            
            ⇒ 따라서 **서버는 두대 이상 필요로 하며 두대로 동일한 데이터를 가지고 있게 하여 하나가 크래쉬가 발생한 경우 남은 한대를 사용하여 서비스를 유지시킬 수 있다.**
            
            - 복제란?
                - 두대 이상의 서버가 동일한 데이터를 가지고 있게 유지하는 방법

<br>

## 바이너리 로그

**바이너리 로그란?**

MySQL 의 빈로그 혹은 바이너리 로그는 MySQL 서버 인스턴스의 데이터 변경사항들에 대한 정보를 포함하는 로그 파일의 세트이다.

여기에는 에러코드, 바이너리 로그 자체에 대한 메타데이터 등 다양한 데이터가 같이 포함 되어지며,

주로 복제(Replication) 및 복구(Recovery)를 목적으로 binary log 가 사용되어진다.

<br>

**바이너리 로그 종류**

- **Statement-based logging**
    
    Insert, Update, Delete 에 대한 SQL 문들이 포함된다.
    
     Statement base 로 복제를 수행 시 Statement-Based Replication (SBR) 이라고 한다.
    
    이 방식에서는 로그 파일에 적은 데이터가 기록되며, 로그 파일에 필요한 저장 공간이 줄어드는 장점이 있다.
    
    백업에 대한 복구는 Replay 처럼 수행되며 빠르게 복원이 수행될 수 있다.다만 로그 기반으로 복원 시 제약이 조금 있는데, 
    
    예를들어 RAND(), LOAD_FILE, UUID() 등과 같이 결정적이지 않은 동작에 대해서는 정확히 복제가 안된다고 보면 된다. 
    
    <br>

- **Row-based logging**
    
    이 방식은 각 행에 대한 변화를 기록한다. Row-based logging 을 이용해서 Primary → Secondary 로 복제를 수행할 수 있고, 이를 Row-Based Replication(RBR)이라 한다
    
    RBL 의 경우 각 행의 변경 사항을 이진 로그에 기록하므로 로그 파일의 크기가 매우 빠르게 증가할 수 있으며 지연이 발생할 수도 있다.
    
    또한, 임시 테이블의 경우 RBL 기반으로 복제되지 않으므로 임시 테이블 관련 구문은 Statement base 로 기록되어야 한다.
    
    <br>

- **혼합형**
    
    MySQL 5.1 이상부터 Row-based logging 과 함께 혼합형태가 지원되어진다. 기본적으로는 Statement based logging 을 사용하지만, 스토리지 엔진 및 특정 명령문에 따라 로그가 자동으로 Row based logging 으로 기록되어진다.
    

    <br>

## 복제(Replication)

**복제란?**

복제는 레플리카를 다른 서버에 생성하는 기술로, 하나의 서버가 다운되더라도 나머지 서버에 동일한 데이터가 있기 때문에 서비스를 유지시킬 수 있는 방법을 의미한다.

<br>

**사용 방식**

리플리케이션(Replication)은 복제를 뜻하며 2대 이상의 DBMS를 나눠서 데이터를 저장하는 방식이며, 사용하기 위한 최소 구성은 **Master / Slave 구성**으로 이루어진다.

<br>

- **Master DBMS 역할**
    
    웹서버로 부터 데이터 등록/수정/삭제 요청시 바이너리로그(Binarylog)를 생성하여 Slave 서버로 전달하게 됩니다
    
    (웹서버로 부터 요청한 데이터 등록/수정/삭제 기능을 하는 DBMS로 많이 사용된다.)
    
    <br>

- **Slave DBMS 역할**
    
    Master DBMS로 부터 전달받은 바이너리로그(Binarylog)를 데이터로 반영하게 됩니다
    
    (웹서버로 부터 요청을 통해 데이터를 불러오는 DBMS로 많이 사용된다.)
    

<br>

**사용 목적**

- 장애 발생시 서비스 유지 및 백업
    
    ![스크린샷 2022-06-08 오후 7.08.13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/57126a13-c571-4c72-bfb8-676487bea5c3/스크린샷_2022-06-08_오후_7.08.13.png)
    
    Master 서버에 DBMS의 등록/수정/업데이터가 생기는 즉시 Slave 서버의 변경된 데이터를 전달하여 데이터의 백업을 할수 있으며, 또한 Master 서버의 장애가 생겼을 경우 Slave 서버로 변경하여 사용할수 있다.
    
    <br>

- DBMS의 부화분산
    
    ![스크린샷 2022-06-08 오후 7.09.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc55df67-c80e-411a-8cc6-87810b39367b/스크린샷_2022-06-08_오후_7.09.20.png)
    
    사용자의 폭주로 인해 1대의 DB서버로 감당할수 없을때, MySQL 리플리케이션(Replication)을 이용하여 같은 DB 데이터를 여러대를 만들수 있기에 부하를 분산이 가능하다.
    

    <br>

**복제 방식**

- 단방향
    - 단방향 비동기
        - 마스터에서 갱신한 결과가 슬레이브에 비동기로 전파하는 복제 유형
        - Mysql에서 표준으로 사용되는 복제 기능
        - 2단계로 구성
            - 바이너리 로그 수신 ( I/O 스레드)
            - 바이너리 로그 실행 (SQL 스레드)
                
                >⇒ 각 별도의 스레드가 담당
                
                <br>

    - 단방향 준동기
        - 단방향 비동기에서 바이너리 로그 수신 단계를 동기화 방식으로 구성한것
            
            >⇒ 이를 통해마스터를 업데이트한 클라이언트는 마스터 데이터베이스 상에서 확정 가능 
            
            >⇒  슬레이브로 전송하여 그 확인응답이 반환될때 까지 기다리게 되어 업데이트가 슬레이브에 도착된 것이 보증된다
            
            >⇒ 하지만, 바이너리 로그 교환을 기다리는 동안 응답 시간이 나빠진다.
            
            <br>

    - 단방향 동기
        - 2 단계 모두 동기로 구성하여 슬레이브에서도 업데이트 결과가 반영되어 있다
            
            >⇒ 이를 통해 즉시 슬레이브에서 서비스 재개가 가능하다.
            
            <br>

- 양방향
    - SSD 와 멀티 코어 CPU등을 통해 병렬성을 높혀 마스터를 두개 이상 갖게 하여 각 마스터를 업데이트 할 수 있도록 구성한것
        
        >⇒ 하지만 기술적 어려움이 존재한다.
        

<br>

## 백업

장애가 발생했을때 백업을 해두었다면 백업 시점으로 복구가 가능하다

>⇒ 하지만 백업 시점으로 복구만 한다면 여러 문제를 겪게 된다.

<br>

백업은 전체 데이터베이스를 복사하는 묵직한 처리이므로 항상 실행할 수 없다

>⇒ 그렇기에 모든 백업 데이터가 최신의 데이터로 유지되는 것이 아니다.

백업 데이터를 통한 복구에서는 <U>**시점 복구(Point in Time Recovery) 기능**</U>을 통해 복구를 시행한다.

<br>

- 시점 복구
    - DB가 업데이트시 바이너리 로그가 기록된다.
        
        >⇒ 여기서백업 이후 업데이트 로그가 성공적이면 마지막 백업을 복구 이후 업데이트 로그를 순차적 적용해 나가는 것으로 장애 이전 상태로 복구 가능하다.