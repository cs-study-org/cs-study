# 가용성과 데이터의 복제

- [가용성과 데이터의 복제](#가용성과-데이터의-복제)
  - [복제](#복제)
    - [복제 유형에는](#복제-유형에는)
    - [복제시 주의사항](#복제시-주의사항)
    - [복제에 사용되는 파일](#복제에-사용되는-파일)
    - [복제에 사용되는 스레드](#복제에-사용되는-스레드)
    - [복제에 사용되는 식별](#복제에-사용되는-식별)
  - [복제 동기화 방식](#복제-동기화-방식)
  - [참고 문헌](#참고-문헌)

## 복제

한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.

복제(Replica) 서버를 구축하는 이점은 다음과 같다.

1. Scale-out
    
    서비스를 운영하다보면 사용자가 늘고, DB 서버로 유입되는 트래픽도 증가해 부하가 높아진다.

    동일한 데이터를 가진 DB 서버를 한 대 이상 더 사용할 수 있다면 

    애플리케이션으로부터 실행되는 쿼리들을 분산시킬 수 있다.

2. 데이터 백업

    사용자의 실수로 데이터가 삭제되면 서비스 운영에 영향을 줄 수 있다.

    동일한 서버 내에서 백업이 실행되는 경우 
    
        백업 프로그램과 DBMS가 서버의 자원을 공유해서 사용한다.

        이는 백업으로 인해 DBMS에서 실행중인 쿼리들이 영향을 받을 수 있다.

    이를 방지해 백업을 복제 서버에서 실행한다.

필자는 MySQL 복제를 알아볼 것이다.

### 복제 유형에는

    - 성능을 희생하여 데이터를 무결성을 증시하는 유형과

    - 데이터 소실의 리스크를 수용하며 성능을 추구하는 유형이 있다.

### 복제시 주의사항

    - 레플리카 서버는 하나의 소스 서버로만 설정 가능하다.

    - 소스-레플리카 서버 간의 데이터 동기화를 위해 레플리카는 읽기 전용으로 설정한다.

    - 레플리카가 불필요한 경우 바이너리 로그를 중지한다.

### 복제에 사용되는 파일

MySQL 서버에서 발생하는 모든 변경사항(이벤트)은 별도의 로그 파일(바이너리 로그)에 순서대로 기록된다. 

MySQL 복제는 이 바이너리 로그를 기반으로 구현되었다.

1. 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고

2. 레플리카 서버에서 해당 내용을 로컬 디스크에 저장한 뒤 (복제)

3. 자신이 가진 데이터에 반영함으로써 소스-레플리카 서버 간 데이터 동기화가 이뤄진다. (쿼리 처리)

### 복제에 사용되는 스레드

- `바이너리 로그 덤프 스레드`

    1. 레플리카 서버는 소스 서버에 접속해 바이너리 로그 정보를 요청한다.

    2. 소스 서버에서는 레플리카 서버가 연결될 때 
        내부적으로 `바이너리 로그 덤프 스레드`를 생성해서 `바이너리 로그`의 이벤트를 레플리카 서버로 전송한다.

    3. `바이너리 로그 덤프 스레드`는 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 `바이너리 로그`에 잠금을 수행하며, 

    4. 이벤트를 읽고난 후에는 바로 잠금을 해제한다.

- `레플리케이션 I/O 스레드`

    복제가 시작되면 레플리카 서버는 `I/O 스레드`를 생성하고, 복제가 멈추면 `I/O 스레드`는 종료된다.

    `I/O 스레드`는 소스 서버의 `바이너리 로그 덤프 스레드`로부터 `바이너리 로그`의 이벤트를 가져와 로컬 서버의 파일(릴레이 로그)로 저장하는 역할을 담당한다.
    
- `레플리케이션 SQL 스레드`

    SQL 스레드는 `I/O 스레드`에 의해 작성된 `릴레이 로그`의 이벤트들을 읽고 실행한다.

레플리카 서버에서 `I/O 스레드`와 `SQL 스레드`는 서로 독립적으로 동작한다.

    cf. SQL 스레드에서 이벤트를 데이터에 적용하는 게 느리더라도
        I/O 스레드는 무관하게 빠르게 소스 서버로부터 이벤트를 읽어올 수 있다.

또한, 레플리카 서버에서 동작들은 소스 서버의 동작과 별개로 진행되어 

레플리카 서버에 문제가 생기면 소스 서버는 전혀 영향을 받지 않는다.

단, 소스 서버에 문제가 생겨 레플리카 서버의 `I/O 스레드`가 정상 동작하지 않으면 

    복제가 되지 않아 소스 서버로부터 동기화되지 않는다.
    
    현재까지 복제해둔 릴레이 로그에 대한 SQL 스레드의 쿼리 처리는 문제없다.

### 복제에 사용되는 식별

소스 서버에서 발생한 바이너리 로그의 이벤트에 대한 식별이 반드시 필요하다.

복제가 설정된 레플리카 서버는 

    소스 서버의 어느 이벤트까지 로컬 디스크로 가져왔고, 또 적용했는지에 대한 정보를 관리하며

    소스 서버에 해당 정보를 전달해 그 이후의 바이너리 로그의 이벤트들을 가져와야 하기 때문이다.


## 복제 동기화 방식

단방향/비동기 복제는

    a. 마스터에서 갱신 SQL문이 로그 파일(바이너리 로그)에 기록된다.
    
    b. 로그 파일의 내용이 슬레이브로 복사된다. 
    
      (슬레이브의 I/O 스레드에 의한 바이너리 로그 수신)
    
    c. 슬레이브는 저장된 로그 파일을 순차적으로 실행함으로써 
      
      (슬레이브의 SQL 스레드에 의한 바이너리 로그 실행)
    
    마스터와 슬레이브의 상태가 일치되는 구조이다. 

바이너리 로그 수신과 로그 실행은 모두 비동기로 전파된다.

전자는 

    🤔 거의 동기에 가까운 속도로 진행되지만

후자는 

    거대한 테이블을 갱신하는 경우 
    
    디스크가 병목현상을 일으키면 처리가 늦어지는 경향이 있어 

    비동기와 같이 처리 시점의 이원화가 필요한 곳이다.


마스터가 장애를 일으킨 경우 슬레이브에서는 지금까지의 업데이트 결과가 반영되지 않을 수 있다.

1. 마스터에서 생성한 바이너리 로그가 슬레이브에서는 마지막까지 수신되지 않은 상황

    즉, 슬레이브가 수신한 최종 결과와 마스터의 최종 결과 사이의 데이터가 손실된 상황이다.

2. 슬레이브에서의 바이너리 로그의 실행이 마지막까지 종료되지 않은 상황

    🤔 즉, 슬레이브의 SQL 스레드가 지연되었기 때문에 일어나는 상황이다.

<hr/>

## 참고 문헌

[복제](http://www.yes24.com/Product/Goods/105536168) ━ *「Real MySQL 8.0 2권: Ch18. 복제」*