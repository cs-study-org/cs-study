# 데이터베이스 필요성과 인덱스

- [데이터베이스 필요성과 인덱스](#데이터베이스-필요성과-인덱스)
  - [데이터베이스의 필요성](#데이터베이스의-필요성)
  - [데이터베이스 인덱스에 적합한 자료구조](#데이터베이스-인덱스에-적합한-자료구조)
    - [B tree](#b-tree)
  - [참고 문헌](#참고-문헌)

## 데이터베이스의 필요성

교재에 다음과 같은 질문이 있었다.

<dl><dt>
Excel로는 왜 충분하지 않지?
</dt></dl>

이 질문을 보고 *생활코딩*에서 스크랩한 토론글이 떠올라서 정리해본다.

토론글의 필자는 엑셀을 10년 넘게 쓴 사람으로 엑셀을 다음과 같은 장/단점을 달고 사용하다가 

    장점:  직관적인 인터페이스
    단점:  큰 용량에 대해 느린 데이터 수정 연산

최근 데이터베이스를 공부하게 됬는데 데이터베이스 중요성에 대해 자세한 설명을 찾지 못해서 올린 글이었다.

따라서, 답변을 단 사람들의 글을 정리해보게 되었다.

    A1. 배포의 용이성
      
      엑셀: 수정시에 수정본을 여러명에게 배포해야한다.
            원본, 사본 구분의 문제가 생긴다.

      DB:   수정시에 누구나 최신버전을 가지고 있을 수 있다.

    A2. 중앙집중 데이터 처리
        병렬성 제어

      엑셀: 파일 단위로 데이터를 처리하기에 누군가 파일을 열어서 작업하면
            다른 사람은 읽기전용으로 밖에 접근을 할 수 없다.

      DB:   서버 개념으로 여러명이 동시에 서버에 붙어서 데이터 작업 처리가 가능하다.

이 외에 교재에 적힌 필요성은 다음과 같다. 

필요성에 대한 이해는 앞으로 진행될 주차에 기술될거라 판단한다

- 대량의 데이터 중에서 필요한 것을 빨리 반환
  
  > 인덱스를 통해 빠른 탐색이 가능하며, 다음 목차에서 기술한다.

- 장애가 발생했을 때 빠른 복구로 데이터 무결성 보장

## 데이터베이스 인덱스에 적합한 자료구조

인덱스는

    탐색에 대한 성능을 대폭 상승하는 방식이다.

형태는

    키-필드만 가지고, 테이블의 세부 항목을 가지고 있지 않는다.

    +------------------+---------------------------+        +---------+---------+---------+---------+
    | index(책의 목차) | pointer(책의 페이지 번호) |         | pointer | 데이터A | 데이터B | 데이터C |
    +------------------+---------------------------+    →   +---------+---------+---------+---------+
    |        10        |            _300           |        |   _300  |    -    |    -    |    -    |
    +------------------+---------------------------+        +---------+---------+---------+---------+

핵심은

    데이터베이스에서는 부등호를 사용할 수 있기 때문에 여러 데이터를 탐색한다.

    때문에 정렬을 요구한다.

사용하기 좋은 경우는

    a. 규모가 큰 테이블

    b. 삽입/수정/삭제 작업이 자주 발생하지 않는 컬럼

        인덱스는 제거시 '사용하지 않음'상태로 남겨두기 때문에 수정 작업이 많으면 별도의 메모리 공간에 저장된다.

        > 🤔 왜 사용하지 않음으로 두는가

    c. 중복도가 낮은 컬럼        

|  | 배열 | 해시테이블 | 레드-블랙 tree[^RedBlack-tree] | B tree |
|:---:|:---:|:---:|:---:|:---:|
| 탐색 시간 | `O(n)` | `O(1)` | `O(log 2(n))` | `O(log 10(n))` |
| 참조 포인터 연산 | 없다 | 많다 | 많다 | 적다[^less-reference] |
| 부등호 연산<br>(정렬 여부) | O | X | O | O |
| 그외 장점 | - | 고정된 키 값에 <br>여러 데이터 항목 가능[^multiple-data-type] | - | (앞서 기술) |
| 단점 | 삽입/삭제 시간도<br>`O(n)` | 하나의 데이터만 <br>빠른 Search | 데이터당 참조 포인터 사용 | (앞서 기술) |

[^multiple-data-type]: 숫자, 문자열, 날짜/시간 중 긴 것에 맞추지 않고, 해시 함수에 대입하여 고정된 키 값을 유지할 수 있다.

[^RedBlack-tree]: ...
    
[^less-reference]: 노드 하나에 고정된 배열이 있어 여러 데이터가 저장될 수 있다.
    
    노드를 참조 포인터로 탐색한 이후에 

    노드 배열은 실제 메모리의 순서를 반영함으로 참조 포인터 접근의 수를 줄인다.

### B tree

<table>
    <tr>
        <th colspan="2"><code>B-tree</code></th>
    </tr>
    <tr>
        <td>
            <img src="assets/b-tree.png"/>
        </td>
        <td>
<p>

장점은

    하나의 데이터에 탐색은 효율적이다.

    평균적으로 leaf 노드까지 가지 않는다.

단점은

    모든 데이터를 탐색하는 데(Full scan)에는 
    모든 노드를 방문해야해서 비효율적이다.
</p>
        </td>
    </tr>
</table>

가장 범용적으로 사용되는

<table>
    <tr>
        <th colspan="2"><code>B+tree</code></th>
    </tr>
    <tr>
        <td colspan="2">
<p>

    오직 leaf 노드에만 데이터를 저장하고, root, bracnh 노드에는 자식 포인터(key)만 저장한다.

    또한, leaf 노드 끼리는 연결 리스트로 연결된다.
</p>
        </td>
    </tr>
    <tr>
        <td>
            <img src="assets/b+tree.png"/>
        </td>
        <td>
<p>

장점은

    - leaf 노드를 제외한 노드는 
    
      데이터를 저장하지 않기 때문에 메모리를 아끼며,

      때문에 하나의 노드에 더 많은 key를 가질 수 있다.

      이는, 트리의 높이를 낮추므로 탐색 속도를 높인다.

    - Full scan에 연결 리스트 갯수만큼만 선형 시간 소모하면된다.

단점은 `B-tree`장점의 반대이다.
</p>
        </td>
    </tr>
</table>

<hr/>

## 참고 문헌

[데이터베이스의 필요성 토론글](https://www.facebook.com/groups/codingeverybody/posts/6454403514600130/) ━ *생활코딩*

[데이터베이스 인덱스에 적합한 자료구조](https://helloinyong.tistory.com/296) ━ *Hello Inyong*

[B+tree](https://rebro.kr/167) ━ *Rebro의 코딩 일기장*