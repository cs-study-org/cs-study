
# 목차
## Chapter 1 : DB가 없으면 무엇이 곤란한가
## Chapter 2 : 인덱스로 고속 액세스 실현한기

<br>

* * * 
<br>

# Chapter 1 : DB가 없으면 무엇이 곤란한가

## DB의 중요성

데이터를 사용하는 곳에서는 예외 없이 데이터베이스가 중요한 역할을 담당한다.

>⇒ 이 데이터베이스의 사용이 적절하지 않으면 향후

- 성능문제 발생
- 데이터의 잘못된 상태 ( 일관성 혹은 정합성이 없는 상태 )
- 데이터 손실
    
    ⇒ 등 심각한 문제를 야기 시킬 수 있다.
    
<br>

## DB가 없으면 무엇이 곤란한가

- 대량의 데이터 중 필요한 것을 빠르게 반환할 수 없다.

- 대량의 데이터를 메모리 내에서 만으로 취급 불가능 하다.
    
    >⇒ 실제 메모리의 크기는 한정되어 있으며, 메모리는 휘발성이기 때문에 데이터 유지가 어렵다.
    

- 장애 발생시 빠른 복구가 어렵다
    
    >⇒ 장애 발생시 단순한 백업만으로는 
    
    - 최종 백업 이후 업데이트 결과를 되돌릴 수 없다
    - 백업 데이터를 다시 되돌리는 시간동안 다운 타임이 된다.
    - 백업중 업데이트시 백업 손상될 위험이 있다.
        
        와 같은 위험성이 있다.
        
- 병렬성 제어가 어렵다
    
    >⇒ 많은 사람들이 동시에 액세스 하는 환경 제어가 어렵다.
    
- 데이터 무결성을 보장하는 것이 어렵다

<br>

* * *

<br>

# Chapter 2 : 인덱스로 고속 액세스 실현한기

## 2.1 키와 값의 페어 관리

대규모 웹 사이트 들은 홈페이지 접속 빈도가 초당 수천을 넘는 방대한 수이기 때문에

<특정 사용자 정보> 와 같은 정보를

<U> **얼마나 빨리 반환하는가 가 커다란 과제가 된다.** </U>

<br>
<br>

### <전체 검색은 대량 데이터에 적합하지 않다.>

<br>

텍스트 파일을 통해 정보를 관리하는 환경에서

ID = 123,456,789 의 정보를 찾고싶을때 **파일의 처음부터 탐색하여 찾을때 까지 검색**해야 한다.

- 만약 검색하는 ID의 사용자가 없는 사용자일 경우
    - 파일 처음부터 끝까지 찾음
    - 이후 검색 불가 오류를 반환
    
    >⇒ 위와 같은 검색 방법을 선형 검색이라고 한다.
    
    <br>

- 선형 검색은 검색에 걸리는 시간은 문서의 크기에 비례한다
    
    ⇒ 즉 O(n) 계산량이 들어간다.
    

위와 같이 몇백 몇만의 크기의 문서를 선형검색을 통해 검색하게 된다면

오버 헤드가 증가하게 된다.

<br>

<br>

### <원하는 위치까지 순식간에 도달하는 방법 생각하기>

<br>

다른 방법으로는 <고정 길이로 관리하는 기술> 이다.

    ex) 사용자 정보를 100 바이트의 고정된 길이로 관리하는 경우 

사용자 ID * 100 바이트째 가 사용자 정보를 저장하는 시작 위치가 된다

고정 길이 관리 기술을 사용하면 

사용자 [ID * 100byte] 를 통해 원하는 데이터로 바로 접근이 가능하다

하지만 단점 또한 존재한다.

<br>

단점

- 사용자 정보 관리에 있어 100바이트라는 값의 유효성
    
    >⇒ 사용자 별 100바이트를 모두 사용하지 않을 경우 낭비가 존재
    
    >⇒ 사용자 별 정보로 100바이트가 부족할 수 있다
    
    >⇒ 향후 추가 데이터가 있을 시 반영 불가 ( 확장성이 떨어짐 )
    
<br>

<br>

### <인덱스 구조 도입하기>

<br>

인덱스 구조란

각 사용자 ID 마다 파일 상 시작 위치를 기록한 또 다른 파일을 만들어 둠으로써 고속으로 사용자 정보를 찾을 수 있게 하는 것

<br>

| 키 값 | 데이터의 위치 |
| --- | --- |

- 인덱스 파일은 키 값 ,바이트 위치 가 구성 요소가 되므로 고정 길이 방식 포맷을 취할 수 있어 빠르게 값 얻기가 가능
- 키 값과 바이트 위치의 두가지 요소밖에 없기 때문에 사용자 정보와 같이 크기가 무한히 증가하게 되는 일은 없다.
- 키 값 과 바이트 위치 모두 usigned integer로 관리하면 4바이트로 약 40억 까지 취급할 수 있다.
- 고정 길이 파일 방식보다 확장성을 가진 형태로 효율적 검색이 가능
- 인덱스 자체는 본체의 데이터와 별도로 관리해여야 한다
    
    >⇒ 본체의 데이터 업데이트시 인덱스를 변도로 업데이트 해야한다
    
    >⇒ 따라서 데이터 업데이트 비용은 증가하지만 검색을 극적으로 고속화 할 수 있다.
    

<br>

<br>

### <해시 인덱스>

<br>

실제 데이터베이스의 구현은 키 값을 그대로 관리하는 것이 아닌 키 값을 해시시 함수에 대입하여 해시 값과 값의 쌍을 갖는 구조가 즐겨 사용되고 있다

>⇒ 이를 해시 인덱스 라고 한다.

- 해시 값은 문자열 길이에 상관 없이동일한 크기이므로 고정 길이 포맷으로 대응할 수 있을 것이다
- 해시 계산 비용은 데이터의 양에 의존하지 않기 때문에 데이터 양이 늘어도 게산량은 변경되지 않는다.
- 해시의 계산량은 O(1)으로 가장 빠른 알고리즘으로 분류된다.

<br>

해시의 충돌

해시 인덱스를 구할때 다른 키 값인데 해시 값일 동일하 경우가 있다 

>⇒ 이런 경우를 해시의 충돌이라고 한다.

<br>

데이터 베이스에서는 충돌을 감지하여 실제 일치하는지에 대한 여부를 확인하는 구조가 필요하며 데이터베이스 제품에서는 이러한 기능을 제대로 구현하고 있다.

<br>

또한 O(1) 시간이라 하더라도 충돌 판정 및 재계산이 있으므로 데이터의 양이 증가하면 평균 처리 시간은 서서히 증가해 간다

>⇒ 서서히 증가하더라도 선형 검색과는 비교가 되지지 않을 정도로 고속이다.

<br>
<br>

### <해시 인덱스는 만능이 아니다>

<br>

키에서 값을 가져온다는 해시 인덱스는 편리하지만 목적을 달성하지 못하는 일이 종종 있다

예를 들어

- 가격이 10,000 이하의 것을 찾음
- 제목이 abc 로 시작하는 리스트를 찾음
    
    >⇒ 위의 두 가지 경우는 키와 값으로 구할 수 없는 범위 검색이라고 한다.
    
- 업데이트 시간이 최신 순으로 정렬하고 싶다.
    
    >⇒ 어떠한 기준으로 정렬하게 될 경우 순서에 따라 결과 반환이 어렵기 때문에 해시 인덱스는 도움이 되지 않는다.
    

그렇다면 위의 범위 검색이나 정렬이 필요한 상황같은 데이터를 구할때는 어떻게 빠른 결과를 반환할 수 있을까

>⇒ B+Tree 라고 불리는 인덱스 구조가 위의 상황을 해결할 수 있다.

<br>
<br>

## <B tree 인덱스>

<br>

트리 구조의 우위성

트리 구조는 꼭 데이터베이스에 한정하지 않더라도 시스템 세계에서는 데이터를 유지하기 위해 자주 사용하는 구조이다. '탐색' 시, 단시간 내에 실행할 수 있기 때문이다.

B-tree의 핵심은 데이터가 정렬된 상태로 유지되어 있다는 것이다.

<br>

![https://blog.kakaocdn.net/dn/qycZ2/btqBQnr4QYG/7J8KpnmNaJiTjgS0K9TEIK/img.png](https://blog.kakaocdn.net/dn/qycZ2/btqBQnr4QYG/7J8KpnmNaJiTjgS0K9TEIK/img.png)

그림에 표시된 사각형으로 표시된 한 개 한 개의 데이터를 '**노드(Node)**'라고 한다.

가장 상단의 노드를 '**루트 노드(Root Node)**', 중간 노드들을 '**브랜치 노드(Branch Node)**', 가장 아래 노드들을 '**리프 노드(Leaf Node)**'라고 한다.

<br>


![https://blog.kakaocdn.net/dn/cikell/btqBRvDU1xF/CdIhvg8XEhHKaP23vE4Ju1/img.jpg](https://blog.kakaocdn.net/dn/cikell/btqBRvDU1xF/CdIhvg8XEhHKaP23vE4Ju1/img.jpg)

B-tree는 Binary search tree와 유사하지만, 한 노드 당 자식 노드가 2개 이상 가능하다.

key 값을 이용해 찾고자 하는 데이터를 트리 구조를 이용해 찾는 것이다.

<br>

<br>

### <왜 B-tree는 빠른가>

<br>

B-tree의 장점 한 가지는 '어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다'인데, 이를 '균일성'이라고 한다.

위의 예시에서 리프노드에 있는 '15'나 '28'을 찾는 시간은 동일할 것이다.(트리 높이가 다른 경우, 약간의 차이는 있겠지만 O(logN)이라는 시간 복잡도를 구할 수 있다.)

<br>

만약 선형탐색일 경우 어떨까?

리프노드에 있는 값들만 따져보면,

[1, 3, 7, 15, 21 .... 85, 89, 97]

'15', '28'을 찾기 위해서는 배열을 하나씩 체크하는 수 밖에 없고 시간은 더욱 소요된다. (시간복잡도 : O(n))

<br>
<br>

### <B-tree는 균형트리>

<br>

![https://blog.kakaocdn.net/dn/b9BMy3/btqBTL7abid/XsBqjuQU9fMG9CdDakMMa1/img.png](https://blog.kakaocdn.net/dn/b9BMy3/btqBTL7abid/XsBqjuQU9fMG9CdDakMMa1/img.png)

'균형 트리'란 루트로부터 리프까지의 거리가 일정한 트리 구조를 뜻하는 것으로, 트리 중에서 특히 성능이 안정화 되어있다.

<br>

그러나, B-tree 처음 생성 당시는 균형 트리이지만 테이블 갱신(INSERT/UPDATE/DELETE)의 반복을 통해 서서히 균형이 깨지고, 성능도 악화된다.

<br>

어느 정도 자동으로 균형을 회복하는 기능이 있지만, 갱신 빈도가 높은 테이블에 작성되는 인덱스 같은 경우 인덱스 재구성을 해서 트리의 균형을 되찾는 작업이 필요하다.

<br>
<br>

### <데이터양에 비례해 효과 상승>

<Br>

![https://blog.kakaocdn.net/dn/pQB0I/btqBQ05iyzt/f8oPM7x0blzKhEzZMwXDck/img.png](https://blog.kakaocdn.net/dn/pQB0I/btqBQ05iyzt/f8oPM7x0blzKhEzZMwXDck/img.png)

풀 스캔이 테이블의 크기에 비례하는 형태로 실행 시간이 늘어가는데에 비해 인덱스를 사용한 경우 실행 시간의 저하는 보통 원만한 곡선을 그리게 된다.

---

<br>

<br>

### <B+tree란?>

<br>

![https://blog.kakaocdn.net/dn/bRiL19/btqBTMSBCWF/J3nKw2qympUVxGThnVdLK0/img.png](https://blog.kakaocdn.net/dn/bRiL19/btqBTMSBCWF/J3nKw2qympUVxGThnVdLK0/img.png)

B+tree는 B-tree의 확장개념으로, **B-tree의 경우**, internal 또는 branch 노드에 key와 data를 담을 수 있다. 하지만, **B+tree의 경우** 브랜치 노드에 key만 담아두고, data는 담지 않는다. 오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결되어 있다.

<br>
<br>

### B+tree의 장점

<br>

1. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.(cache hit를 높일 수 있음)

2. 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다.

---

<br>
<br>

### <B-tree Vs B+tree>

<br>

아래서 말하는 데이터는 자료구조 상 value를 가리킴. (실제 DB 데이터 X)

[제목 없음](https://www.notion.so/3409a338a07d46268d35237395c9b058)

<br>
<br>

## <RDBMS에서의 최적화>

### 고유성 보장

<br>

데이터 관리 상황에서 [**정보에 대한 중복 없음 을 보증하고 싶다]** 라는 경우가 존재한다.

    ex) 사용자 ID와 같이 두개 이 상 존재하게 되면 문제가 발생

<br>

- 텍스트 파일로 데이터 관리
    
    ⇒ 이전 전통적인텍스트 파일에서는 고유성을 보장할 수 있지만 이전 선형 검색으로 매번 중복을 찾아야 하기 때문에 효율성이 떨어진다.
    

- 인덱스 사용으로는 고유성 보장이 가능하다
    - 해시 인덱스
        
        >⇒ 동일 ID일 경우 동일한 해시값이 되어 중복 확인에 효율적
        
    - B+Tree
        
        >⇒ 동일 리프 블록에 도달하기기 때문에 적은 코스트로 중복 체크 가능

<br>

<br>

### <멀티 칼럼 인덱스>

인덱스 검색에 있어 지정하는 조건이 한개라고 단정 지을 수 없다

    ex) ID 가 100 이고, 마지막 수정날짜가 1월1일인 것 검색

>⇒ 위의 경우 ID만으로 검색하는 것보다 ID와 최종 업데이트 모두 검색하는 것이 효과적

>⇒ 이러한 여러 조건의 인덱스를 **멀티 칼럼 인덱스** 라고 한다.

<br>

RDBMS는 (사용자 ID, 최종 갱신일)과 같이 두가지 요소를 결합한 인덱스를 만들 수 있으며

AND 조건에서 검색을 가속화 할 수 있다.

<br>
<br>

### <인덱스만을 읽는 검색>

<br>

인덱스 검색에서

1. 먼저 인덱스를 읽는다
2. 인덱스가가 가리키는 데이터 영역을 읽는다

>⇒ 2단계의 절차를 채택하고 있다.

<br>

인덱스 부분과 데이터 부분은 서로로 독립적 영역에 존재하고 양쪽을 한번의 액세스로 단번에 읽을 수는 없다

<br>

즉 인덱스와 데이터의 두번에 걸친 로딩 작업이 필요하다

<br>

하지만 인덱스를 읽는 것만으로도 처리가 완결되는 경우가 있다.

    ex) 가격이 10,000 이하의 상품 개수를 알고 싶다.

>⇒ 위와 같은 경우 가격이 10,000 이하의 레코드 건수를 열거하는 것만으로도 결과를 구할 수 있으므로

>⇒ 데이터 영역에 접근할 필요가 없다.

>⇒ 위와 같이 인덱스 영역을 읽는 것만으로 처리를 고속 완료할 수 있으며 

>⇒ 이러한 작업을 **Index only read , Convering Index**  라고 한다.

<br>

### <인덱스 병합>

또한 데이터 검색하기 위한 처리 조건이 단 한개라고 단정 지을 수 없다.

    ex) 부서 코드가 100 번 또는 입사 연도가 2010 년인 직원을 찾고 싶다

>⇒ 위와 같이 OR 조건의 검색은 하나의 인덱스만으로는 검색에 도움이 될 수 없다.

<br>

그렇기에

한번에 검색에서 두개이상의 인덱스를 동시에 사용하여 각각의 결과에서 원하는 레코드를 꺼내려는 방식이 생성됨

>⇒ 이를 **인덱스 병합** 이라고 한다

<br>

- 먼저 각 인덱스에서 각 검색을 실시하여여 대상의 행번호를 추출한다.
- 각각의 결과에에 대해 AND 조건과 OR 조건 등으로 집합 연산을 수행한다
- 마지막으로 남은 행 번호에 대해 실제 데이터를 읽어 가는 효율적인 동작을 시행한다.

<br>

## <업데이트 비용 절감을 위한 노력>

인덱스는 본체 데이터와 별도로 유지할 필요가 있기 때문에

검색 성능이 높아지는 대가로 업데이트 성능이 떨어진다는 단점이 존재

>⇒ 데이터 베이스는 이 업데이트 비용을 최대한 떨어뜨리기 위해 다양한 최적화를 구현하고 있다.

<br>
<br>

### <디스크에 모아서 기록>

<br>

레코드 추가 등록하는 경우

- B+tree 인덱스에도 값을 등록해야 한다

    >인덱스의 리프 블록의 이곳저곳이 무작위에 가까운 형태로 업데이트 되어 간다.

    >랜덤 액세스는 느리기 때문에 이 비용을 얼마나 감소시키느냐가 성능에 있어 중요하다.


데이터 베이스에서 무정지성을 높이기 위해 업데이트 된 부분을 최대한 빨리 디스크에 저장해야 한다.

<br>

- 전통적인 방식
    - 업데이트 순서대로 디스크에 써내려감
        
        >⇒ 이러한 방식은 속도가 느린 랜덤 라이트가 많이 발생하게 된다.
        

- 디스크에 모아서 기록
    - 이에 업데이트 정보를 메모리나 전용 파일등에 일시적 지록하고 나중에 모아서 단번에 리프 블록을 갱신하는 구조를 채택한다
        
        >⇒ 현재 이구조가 MySQL이다.

<br>


이러한 구조는

- 랜덤 라이트보다 훨씬 빠른 시퀀셜 라이트로 빠르게 처리
- 이전 랜덤라이트로 인한 HDD가 병목현상을 일으키고 있는 상태에서 시퀀셜 라이트의 구현으로 초당 2000회 정도의 Insert가 가능해 졌다.