# TCP의 제어

## TCP의 흐름제어

## 흐름 제어

- 송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)을 해결하기 위한 기법
- 만약,
    
    송신측의 전송량 > 수신측의 수신량 일 경우
    
    ⇒ 전송된 패킷은 수신측의 큐를 넘어서 손실될 수 있기 때문에 송신측의 패킷 전송량을 제어하게 된다.

<br>    

(1). Stop and Wait (정지 - 대기)

- **매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다.**
- 이런한 구조 때문에 비효율적이다. (단점)
- Give & Take (패킷을 주는게 있어야 받는게 있다.)

<br>

(2). Sliding Window(슬라이딩 윈도우)

- (송신측 = 전송측)
    - 수신측에서 설정한 윈도우 크기만큼 송신측에서 **확인 응답 없이 세그먼트를 전송할 수 있게 하여** 데이터 흐름을 동적으로 조절하는 기법이다.
- **윈도우** : 송신, 수신  양쪽에서 만들어진 버퍼의 크기
- Stop and Wait의 비효율성을 개선한 기법
- 송신측에서는 Ack 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다
- 송신측에서 0,1,2,3,4,5,6을 보낼 수 있는 프레임을 가지고 있고 데이터 0,1을 전송했다고 가정하면 슬라이딩 윈도우 구조는 2,3,4,5,6처럼 변하게 된다.
- 이때, 만약 수신측으로부터 ACK 프레임을 받게 된다면 송신측은 이전에 보낸 데이터 0,1을 수신측에서 정상적으로 받았음을 알게 되고
    
    ⇒ 송신측의 슬라이딩 윈도우는 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다.
    

## TCP의 오류제어

- 오류 검출과 재전송을 포함한다
- ARQ(Automatic Repeat Request) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구한다.
- ARQ 기법은 흐름 제어 기법과 연관되어 있다.

<br>

(1). Stop and Wait ARQ

- 송신측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무 판단에 따라 ACK or NAK(Negative Acknowledgement)를 보내는 방식이다
- 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0,1 번호를 번갈아가며 부여한다.
- 수신측이 데이터를 받지 못했을 경우, NAK를 보내고 NAK를 받은 송신측은 데이터를 재전송한다.
- 만약, 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다.

<br>

(2). Go-Back-n ARQ(슬라이딩 윈도우)

- 전송된 프레임이 손상되거나 분실된 경우 그리고 ACK 패킷의 손실로 인한 TIME_OUT이 발생된 경우, 확인된 마지막 프레임 이후로 모든 프레임을 재전송한다.
- 슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송측은 전송된 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별해야 한다.
- ACK : 다음 프레임을 전송
- NAK : 손상된 프레임 자체 번호를 반환

<br>

**[재전송 되는 경우]**

(1). NAK 프레임을 받았을 경우

만약, 수신측으로 0 ~ 5까지의 데이터를 보냈다고 가정했을 때, 수신측에서 데이터를 받았음을 확인하는 ACK 프레임을 중간 중간 보내게 되며, ACK 프레임을 확인한 전송측은 계속해서 데이터를 전송한다. 그러나 만약 수신측에서 데이터 오류 프레임 2를 발견하고 NAK2를 전송측에 보낸다고 해보자. NAK2를 받은 전송측은 데이터 프레임 2가 잘못되었다는 것을 알고 데이터를 재전송한다. **GBn ARQ의 특징은 데이터를 재전송하는 부분이다. NAK(n)를 받아 n 데이터를 재전송한다.**

<br>

(2). 전송 데이터 프레임의 분실

GBn ARQ의 특징은 확인된 데이터 이후의 모든 데이터 프레임 재전송과 수신측의 폐기이다.수신측에서 데이터 1을 받고 다음 데이터로 3을 받게 된다면 데이터 2를 받지 못했으므로 수신측에서는 데이터 3을 폐기하고 데이터 2를 받지 못했다는 NAK2를 전송측에 보낸다. NAK를 받은 전송측은 (1) 경우와 같이 NAK(n) 데이터로부터 모든 데이터를 재전송하며 수신측은 기존에 받았던 데이터 중 NAK(n)으로 보냈던 대상 데이터 이후의 모든 데이터를 폐기하고 재전송 받는다.

![https://blog.kakaocdn.net/dn/caXIaC/btqJptevJU6/2lkY4y2hK9a7k0Si6KjHJK/img.png](https://blog.kakaocdn.net/dn/caXIaC/btqJptevJU6/2lkY4y2hK9a7k0Si6KjHJK/img.png)

(3). 지정된 타임 아웃 내의 ACK 프레임 분실(Lost ACK)

- 전송측은 분실된 ACK를 다루기 위해 타이머를 가지고 있다
- 전송측에서는 이 타이머의 타임 아웃 동안 수신측으로부터 ACK 데이터를 받지 못했을 경우, 마지막 ACK된 데이터부터 재전송한다

![https://blog.kakaocdn.net/dn/Spno0/btqJrwV7CaE/4H0Y6adKb7SSX0gAOsgSuk/img.png](https://blog.kakaocdn.net/dn/Spno0/btqJrwV7CaE/4H0Y6adKb7SSX0gAOsgSuk/img.png)

- 전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 데이터를 재전송한다
- 수신측은 원하는 프레임이 아닐 경우, 데이터를 모두 폐기 처분한다
- 타이아웃(ACK 분실)의 경우, 마지막 ACK된 데이터부터 재전송한다

<br>

3. SR(Selective-Reject) ARQ

- GBn ARQ의 확인된 마지막 프레임 이후의 모든 프레임을 재전송하는 단점을 보완하는 기법이다
- SR ARQ는 손상된, 손실된 프레임만 재전송한다
- 그렇기 때문에 **별도의 데이터 재정렬을 수행하야 하며, 별도의 버퍼를 필요로 한다**
- 수신측에 버퍼를 두어 받은 데이터의 정렬이 필요하다

![https://blog.kakaocdn.net/dn/rQvQS/btqJvN3DCLE/d9ZsQd1sZL673k1gAS0iA1/img.png](https://blog.kakaocdn.net/dn/rQvQS/btqJvN3DCLE/d9ZsQd1sZL673k1gAS0iA1/img.png)

<br>

## TCP의 혼잡제어

- 송신측의 데이터 전달과 네트워크의 데이터 처리 속도를 해결하기 위한 기법이다
- 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실이 발생한다
- 이러한 **네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어**하는 것이 혼잡 제어의 개념이다.

<br>

**(1). AIMD (Addtive Increase Multicative Decrease)**

- 합 증가 / 곱 감소 알고리즘이라고 한다
- 처음에 패킷 하나를 보내는 것으로 시작하여 전송한 패킷이 문제 없이 도착한다면 Window Size를 1씩 증가시키며 전송하는 방법이다. 만약, 패킷 전송을 실패하거나 TIME_OUT이 발생하면 Window Size를 절반으로 감소시킨다.
- 이 방식은 공평하다. *여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있다*
- 문제점은 초기 네트워크의 높은 대역폭을 사용하지 못하고 네트워크가 혼잡해지는 상황을 미리 감지하지 못하여 혼잡해지고 나서야 대역폭을 줄이는 방식이다.

<br>

**(2). Slow Start**

- AIMD가 네트워크의 수용량 주변에서는 효율적으로 동작하지만, 처음에 전송 속도를 올리는 데 시간이 너무 길다는 단점이 있다
- Slow Start는 AIMD와 마찬가지로 패킷을 하나씩 보내는 것부터 시작한다. 이 방식은 패킷이 문제 없이 도착하여 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기가 지나면 Window Size는 2배가 된다
- 따라서 그래프의 모양은 지수 함수 꼴이 된다
- 혼잡 현상이 발생하면 Window Size를 1로 떨어뜨린다
- 처음에는 네트워크의 수용량을 예측할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크 수용량을 어느정도 예상할 수 있으므로 혼잡 현상이 발생하였던 Window Size의 절반까지는 이전처럼 지수 함수 꼴로 Window Size를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다

![https://blog.kakaocdn.net/dn/3HTVj/btqJlsUPCno/uKH303wx8XNrmCzPOmrtqk/img.png](https://blog.kakaocdn.net/dn/3HTVj/btqJlsUPCno/uKH303wx8XNrmCzPOmrtqk/img.png)

- 미리 정해진 임계값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.
- Slow Start라는 이름을 사용하지만, 매 전송마다 2배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수함수적으로 증가한다
- 전송되는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다

<br>

![https://blog.kakaocdn.net/dn/blF3bg/btqJrxU3OD0/qvOhv5cJNsLuiuglXuuoo1/img.png](https://blog.kakaocdn.net/dn/blF3bg/btqJrxU3OD0/qvOhv5cJNsLuiuglXuuoo1/img.png)

[혼잡 회피(Congestion Avoidance)]

- 윈도우의 크기가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높다
- 따라서 이를 회피하기 위해 **윈도우 크기를 선형적으로 1씩 증가시키는 방법**이다.
- 수신측으로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우타임 아웃의 발생 : 네트워크 혼잡이 발생했다고 인식 혼잡 상태로 인식된 경우  --> 윈도우의 크기 세그먼트의 수를 1로 감소시킨다.  --> 동시에 임계값을 패킷 손실이 발생했을 때의 윈도우 크기의 절반으로 줄인다

<br>

**[빠른 회복(Fast Recovery)]**

- 혼잡한 상태가 되면 Window Size를 1로 줄이지 않고 절반으로 줄이고 선형 증가시키는 방법이다
- 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다

<br>

**[빠른 재전송(Fast Retransmit)]**

- 수신측에서 패킷을 받을 때 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보낸다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보낸다. 따라서 중간에 패킷 하나가 손실되면 송신측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하면 문제가 되는 순번의 패킷을 재전송할 수 있다.
- 빠른 재전송은 중복된 순번의 패킷을 3개(3 ACK) 받으면 재전송한다. 그리고 이러한 현상이 일어나는 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 절반으로 줄인다.