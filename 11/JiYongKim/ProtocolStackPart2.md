# Story 3,4

이전 OS 내부 프로토콜 스택의 접속단계 까지 알아보았다.

이번 스토리에서는 접속 과정 이후 실제 데이터의 송수신 단계를 알아보자

<br>

* * *
<br>

## Story3 : 프로토콜 스택의 데이터 송수신 단계

<br>

### 목차

1) 애플리케이션에서 프로토콜 스택에게 송신할 데이터 전달

2) 프로토콜 스택은 애플리케이션으로 부터 받은 데이터를 버퍼에 저장한다.

3) 송신용 메모리 버퍼에서 데이터를 꺼내 패킷에 넣어 송신한다.

4) 데이터 송신후 도착 확인

5) 데이터의 수신

<br>

이전 connect 단계 이후 애플리케이션으로 제어가 돌아오면 데이터 송 수신 단계가 시작된다. 

과정별 차례로 알아가 보자

<br>

* * *
<br>

## 1) 애플리케이션에서 프로토콜 스택에게 송신할 데이터 전달

<br>

애플리케이션은 보낼 데이터를 Socket 라이브러리의 `Write` 를 호출하여 데이터를 프로토콜 스택에게 전달한다.

- 프로토콜 스택은 애플리케이션에게 받은 데이터의 내용을 알지 못한다.
    
    ⇒ 프로토콜 스택은 1바이트씩 차례로 나열된 바이너리 데이터라고 인지만 한다.
    
    <br>

* * *
<br>

## 2) 프로토콜 스택은 애플리케이션으로 부터 받은 데이터를 버퍼에 저장한다.

프로토콜 스택은 애플리케이션으로부터 받은 데이터를 바로 송신하는것이 아니라,

**송신용 버퍼 메모리 영역에 저장**하고 **애플리케이션이 다음 데이터를 건네주기를 기다린다**.

<br>

- 데이터를 송신용 버퍼 메모리 영역에 임시 저장하는 이유?
    - 프로토콜 스택 에게 의뢰하는 송신 데이터는 애플리케이션에 따라 만드는 방법이 다르다
        
        >⇒ 즉 애플리케이션의 사정에 따라 건네주는 데이터의 길이가 결정된다.
        
        <br>

        - 만약 프로토콜 스택에서 데이터를 받을 시 마다 전송시
            - 애플리케이션이 조금씩 자주 데이터 의뢰할 경우
                
                >⇒ 작은 패킷을 자주 보내게 되어 네트워크 이용 효율 저하
                
                <br>
        
        이러한 이유 때문에 송신용 메모리 버퍼에 데이터를 저장하여 데이터를 송신하게 된다.
        
        (참고)<br>
         어느정도 데이터를 메모리 버퍼에 저장하고 송신을 시작할지는 OS의 종류나 버전에 따라 달라진다.
        

<br>

* * *

<br>

## 3) 송신용 메모리 버퍼에서 데이터를 꺼내 패킷에 넣어 송신한다.

프로토콜 스택은 애플리케이션 으로 부터 데이터가 모두 받을때까지 기다리는 것이 아니라,

**어느 정도** 모일때까지 기다리고 이후 데이터를 전송하게 된다.

- 그렇다면 여기서 <U>“**어느 정도 데이터가 모인다**”</U> 를 판단하는 2가지 기준이 있다.
    
    <br>

    - 하나의 패킷에 넣을 수 있는 데이터의 크기 기준
        
        <img width="571" alt="스크린샷 2022-03-03 오전 6 51 16" src="https://user-images.githubusercontent.com/81874493/156455702-1b62c8eb-c698-4568-8348-4ed706dd8e4b.png">

        (프로토콜 스택은 MTU라는 매개변수를 바탕으로 한 패킷에 저장할 수 있는 데이터의 크기를 판단)
        
        - MTU (Maximum Transmission Unit) : 한 패킷으로 운반 할 수 있는 디지털 데이터의 최대 길이
            
            >⇒ 이더넷에서 MTU 크기 - 보통 1,500바이트
            
        - MSS (Maximum Segment Size) : 헤더를 제외하고 한개의 패킷으로 운반 가능한 TCP의 데이터의 최대 길이
        
        <br>

        >크기 기준시)<br>
        패킷에 넣을 수 있는 데이터의 크기를 기준으로 MSS 크기를 기준으로 너무 적은양의 데이터를 패킷에 넣어 전송하지 않도록 조절 
        
        <br>

    - 타이밍 기준
        
        애플리케이션에서 데이터를 프로토콜 스택에게 넘겨줄때 의뢰하는 속도가 늦어질때,
        
        MSS 크기까지 저장한 후 전송한다면?
        
        >⇒ 데이터를 모으는 시간 만큼의 송신이 지연된다.
        
        <br>
        따라서 버퍼에 데이터가 모이지 않아도 **적당한 시간** 이후 송신 동작을 수행해야한다.
        <br>

        >⇒ 여기서의 적당 시간은 프로토콜 스택 내부의 타이머를 통해 일정 시간 경과시 패킷을 강제 송신한다.
        

<br>

정리해 보자면)
<details>
    <summary>정리</summary>

- 정리
    
    **판단의 요소는 2가지**
    
    - 패킷에 넣을 수 있는 데이터의 최대 크기
    - 시간을 기준으로 일정 시간 경과 시 데이터 송신
    
    ⇒ 각 요소별 트레이드 오프 존재
    
    - 크기 기준에 초점을 맞출시
        - 한번 전송시의 보낼 수 있는 데이터의 최대 길이 만큼 전송 (장점)
            
            ⇒ 네트워크 이용 효율이 높아진다.
            
        - 데이터가 모일때까지 버퍼에 머무는 시간이 증가 (단점)
            
            ⇒ 데이터가 버퍼에 머무는 시간까지 송신 동작이 지연된다.
            
    - 타이밍에 초점을 맞출시
        - 일정 시간 경과시 데이터 송신 (장점)
            
            ⇒ 데이터 송신 동작의 지연은 적어진다.
            
        - 버퍼의 데이터를 모두 보낼때 까지 여러번에 걸쳐 송신 (단점)
            
            ⇒ 네트워크 이용 효율이 떨어진다.
            
    
    **양자를 절충하여  송신 동작을 실행해야 한다.**
    
    - 하지만, TCP에서 절충에 관한 규정 존재 하지 않다.
        
        ⇒ 결국 프로토콜 스택을 만드는 개발자의 판단에 맡겨져 있다.
        
        ⇒ OS종류나 버전에 따라 이와 관련된 동작이 달라진다.
        
    - 프로토콜 스택 에게만 맡기지 않고 애플리케이션 측에서 송신 타이밍 제어하는 방법도 존재
        
        ex) 애플리케이션에서 “**버퍼에 머물지 않고 바로 송신할 것**” 옵션을 지정하여 의뢰
        
        ⇒ 브라우저와 같이 대화형 어플리케이션에서 위 옵션을 자주 사용하게 된다.
        
    </details>
    
    <br>


### 만약 송신 메모리 버퍼에 MSS 크기 이상의 데이터가 넘어 오게 된다면 ?

<br>

- 이 경우 송신 버퍼에 저장되는 데이터는 MSS 크기 초과
    
    ⇒ 애플리케이션으로 부터 다음 데이터를 기다릴 필요가 없다
    
    ⇒ 따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 MSS 크기 별로 분할
    
    ⇒ 분할한 조각을 한 개씩 패킷에 넣어 송신한다.
    

<img width="519" alt="스크린샷 2022-03-03 오전 6 51 26" src="https://user-images.githubusercontent.com/81874493/156455734-d57ae711-3ab2-4d91-a534-229622abbf5e.png">

1. 송신용 메모리 버퍼의 데이터를 MSS 크기에 맞추어 분할한다.
2. 분할한 데이터를 순서별로 패킷에 넣어 송신한다.

<br>

* * *

<br>

## 4) 데이터 송신후 도착 확인

TCP에는 송신 이후 패킷이 잘 도착했는지 상대측 응답 패킷의 ACK 번호를 사용하여 확인한다.

⇒ 만약 도착하지 않았을 경우 다시 송신하는 기능을 통해 재송신 동작으로 넘어간다.

>( 단, 여기서의 ACK 번호와 컨트롤 비트인 ACK 과 구분할 것!!)

<br>

### ACK 번호를 통한 도착 확인

ACK 번호와 시퀀스 번호를 통해 데이터의 정상 도착을 확인하게 된다.

- 시퀀스 번호 & ACK 번호
    
    <img width="565" alt="스크린샷 2022-03-03 오전 6 51 32" src="https://user-images.githubusercontent.com/81874493/156455763-5096b4b6-67db-4b93-9407-897b0f448ce4.png">

    - 시퀀스 번호 : 데이터를 분할하여 송신하는 경우 송신 개시 부터 데이터의 몇번 째 바이트에 해당하는 값으로 TCP 헤더에 기록하여 데이터의 순서를 보장한다.
        
        <br>

        - 참고)
            - 실제 시퀀스 번호는 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작한다.
                
                ⇒ 이유 : 예측을 통한 악의적 공격할 우려가 있기 때문
                
                <br>

    - ACK 번호 : 데이터 분할 송수신시 전체 데이터크기에서 현재까지 받은 데이터양을 뺀 이후의 데이터를 요청하는 값
    
<br>

실제 확인 과정)

<img width="698" alt="스크린샷 2022-03-03 오전 6 51 40" src="https://user-images.githubusercontent.com/81874493/156455778-7aa40729-188c-425c-a09d-9575ff0202d9.png">

<br>

<접속 과정>

1. 접속 동작시 클라이언트가  자신이 보낼 데이터의 시퀀스 초기값을 산출하여 서버에게 통지한다.
2. 서버는 클라이언트가 통지한 시퀀스 번호를 통해 ACK번호를 산출한 값과 자신이 보낼 데이터의 시퀀스 초기값을 클라이언트에게 통지한다.
3. 클라이언트도 서버와 마찬가지로 서버의 시퀀스 초기값을 통해 ACK 번호를 산출하여 통지한다.

======> ( 여기까지의 과정을 통해 양측간 시퀀스 번호와 ACK 번호가 준비되어 송수신 동작이 시작)

<br>

< 클라이언트의 데이터 송신 과정>

1. 클라이언트는 서버에게 시퀀스 번호와 데이터를 송신한다.
    
    ex) 시퀀스 번호 : 1 , 데이터 (500 바이트)
    
2. 서버에는 클라이언트가 송신한 데이터와 시퀀스 번호를 바탕으로 ACK 번호를 산출하여 송신한다.
    
    ex) ACK 번호 : 501 
    

<br>

<서버의 데이터 송신 과정>

1. 서버 또한 클라이언트에게 시퀀스 번호와 데이터를 송신한다.
    
    ex) 시퀀스 번호 : 1 , 데이터 (200 바이트)
    
2. 클라이언트는 서버가 송신한 데이터와 시퀀스 번호를 바탕으로 ACK 번호를 산출하여 송신한다.
    
    ex) ACK 번호 : 201
    

TCP는 위와 같은 과정으로 상대측의 데이터 수신 확인하게 된다.

<br>


### TCP의 데이터 송신 도중 데이터 유실이 있을 경우?

<br>

위의 TCP 송신 과정에서

- 데이터 수신 확인이 될때까지 송신한 패킷을 **송신용 버퍼 메모리 영역에 보관**
- 송신한 데이터에 대응하는 **ACK 번호가 돌아오지 않을시** 송신용 패킷에 보관된 패킷을 재전송한다.

<br>

TCP 상에서 오류 검출시 재전송과 같이 회복 조치를 하기 때문에

⇒ LAN 어댑터, 버퍼, 라우터 등과 같은 다른 곳에서 따로 회복 조치 할 필요가 없다.

하지만,

만약 서버가 다운되거나 랜케이블이 분리되는 등의 이유로 TCP가 아무리 데이터를 보내도 도착하지 않는 경우

- 데이터를 몇번 보내 보고 회복 전망 없는 것으로 판단 후
    
    ⇒ 데이터 송수신 동작을 강제 종료 하고 애플리케이션에 오류를 통지한다.
    
<br>

<br>

### ACK 번호 대기 시간 조정

패킷 손실과 같이 ACK 번호 반송이 오지 않을 경우 송신측에서 한 없이 반송을 기다리게 된다면

기다리기만 할 뿐 데이터의 송 수신이 진행되지 않는다.

⇒ 위와 같은 오류 회복 처리 방법이 필요

<br>

**<타임 아웃>**

TCP에서는 데이터를 송신 이후 송신에 대한 응답으로 ACK 번호를 받게 되는데

⇒ 이 ACK 번호가 돌아오는 것을 기다리는 시간을 **타임아웃 값**이라고 한다.

⇒ TCP는 타임아웃 이후 데이터를 받지 못했다 판단하고 데이터를 재전송 하게 된다.

<br>

**<타임 아웃 값을 정하는 기준이 필요!>**

- 타임 아웃 값을 짧게 설정할경우
    - 네트워크 혼잡의 이유로 ACK 반송이 이루어지는중 타임아웃이 걸려버림
- 타임 아웃 값을 길게 설정할 경우
    - 패킷 손실시 타임아웃 시간을 계속해서 기다리게 되어 패킷 재전송 동작이 지연
    

⇒ 위의 같은 상황으로 인해 타임 아웃 값을 결정하는 시간이 필요하다.

<br>

**<TCP의 타임 아웃 값 결정 기준>**

- ACK 번호가 돌아오는 시간을 기준으로 대기시간을 판단.
    - 데이터 송수신시 매번 ACK 번호가 돌아오는 시간을 계측
        
        ⇒ ACK 번호 돌아오는 시간이 지연되면 이에 대응하여 대기 시간도 늘린다.
        
        ⇒ ACK 번호 돌아오는 시간이 짧아지면 이에 대응하여 대기 시간도 줄인다.
        

<br>

<br>

### 윈도우 제어 방식

<br>

**<데이터 송수신시  핑퐁 방식의 문제점>**

한개의 패킷을 보내고 한개의 ACK 응답을 기다리는 방식은 단순하고 쉽다.

⇒ 하지만, ACK 번호가 돌아올때까지의 시간동안 아무일도 하지 않고 기다림

⇒ 즉 시간 낭비로 이어진다.

이를 해결하기 위해 TCP에서는 `“윈도우 제어방식”`을 통해 데이터의 송수신 과정을 실행한다.

<br>

**<윈도우 제어방식의 개념>**
f
<img width="522" alt="스크린샷 2022-03-03 오전 6 51 51" src="https://user-images.githubusercontent.com/81874493/156455805-a5f9c6a6-20b0-4b2c-9429-c9b0d2607e6e.png">

- 윈도우 제어 방식이란?
    
    수신 후 ACK 번호 반송을 기다리지 않고,
    
    차례대로 연속해서 복수의 패킷을 보내는 방법이다.
    
    <br>

- 윈도우 제어 방식 동작 과정
    1. 양측간 수신 메모리 버퍼의 윈도우 사이즈를 통지하여 미리 인지한다.
    2. 수신측의 메모리 버퍼 크기에 맞추어 복수의 패킷을 전송
    3. 수신측의 메모리 버퍼 크기 만큼의 데이터 전송시 송신 동작 중지
    4. 송신측의 메모리 버퍼에서 데이터를 꺼내어 애플리케이션에 전달하고 비움
    5. 수신측 메모리 버퍼에 남은 용량을 송신측에게 TCP 헤더의 윈도우 필드를 통해 윈도우 사이즈를 통지
    6. 송신측은 수신측의 메모리 버퍼 크기에 맞추어 복수의 패킷 전송 ( 반복 )

<br>

**<ACK 번호와 윈도우>**

- ACK 번호의 통지 타이밍
    
    ACK 번호는 수신측에서 데이터를 받았을때, 내용 조사하여 정상 수신이 확인 되었을 때
    
    ⇒ 송신측에게 ACK번호를 알린다.
    
- 윈도우 통지 타이밍
    
    윈도우 통지는 수신측의 수신 버퍼에서 데이터들을 꺼내어 연결시켜 애플리케이션에게 전달하여 수신 버퍼에 빈 영역이 늘어났을때 
    
    ⇒ 송신측에게 윈도우 사이즈를 알린다.
    

<br>

위의 두 타이밍에 맞추어 송신측에게 통지할 경우

⇒ 각각의 타이밍이 달라 여러 패킷을 보내 효율성이 저하된다.

<br>

이에 대한 해결책은?

ACK 번호 타이밍 혹은 윈도우 통지 타이밍 중

먼저 준비되는 쪽이 기다리고 모두가 통지할 준비가 되었을 경우 하나의 패킷으로 구성하여 송신측에 알린다.

⇒ 이를 통해 패킷의 수를 줄여 효율성을 높힐 수 있다.

<br>

* * *

<br>

## 5) 데이터의 수신

데이터의 송신이 완료후 이에 대한 응답 메시지를 받기위해  애플리케이션은 소켓 라이브러리의 `read` 를 호출하게 된다.

<br>

**<데이터 수신 과정>**

단, 송신 완료후 얼마 안 된 시점의 경우 수신 버퍼에 데이터가 존재하지 않으므로

⇒ 수신 버퍼에 데이터가 쌓인 일때 까지 보류한 후 , 데이터를 애플리케이션에게 전달하는 과정을 진행한다.

<br>

1. 수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 데이터 누락을 확인한다.
    1. 데이터 누락시 송신측에게 데이터 재요청
2. 문제 없을시 ACK 번호를 반송한다.
3. 데이터 조각을 수신 버퍼에 일시 보관한다.
4. 데이터 조각을 연결하여 데이터를 원래 모습으로 복원
5. 복원된 데이터를 애플리케이션에게 건네준다.
    1. 즉 애플리케이션 지정 메모리 영역에 데이터를 옮겨 기록후 애플리케이션 에게 제어를 넘겨준다.
6. 이후 타이밍을 가늠하여 윈도우를 송신측에 통지한다.
    1. 윈도우와 함께 ACK 번호도 하나의 패킷에 넣어 통지

<br>

* * *

<br>

## Story 4 : 프로토콜 스택의 연결 종료 단계

### 목차

1) 연결 종료 단계로 넘어가는 시점

2) 연결 종료를 요청하는 주체

3) 연결 종료 단계의 과정

4) 소켓의 말소

<br>

* * *

<br>

### **연결 끊기 단계로 넘어가는 시점**

송신해야하는 데이터 전부를 송신 완료 했다고 판단 했을때

<br>

* * *

<br>

### **연결 끊기를 요청하는 주체**

웹 상에서는 클라이언트-서버 모델로 대부분 서버에서 연결 종료 단계로 들어가게된다.

하지만, 애플리케이션 종류별로 연결 종료 단계로 들어가는 주체는 다르며

⇒ 프로토콜 스택은 어떤 쪽에서 먼저 연결 종료 단계에 들어가도 좋게 설계되어 있다.

<br>

* * *

<br>

### **연결끊기 단계의 과정**

서버측에서 먼저 연결 종료 단계로 들어가는 과정으로 설명한다.

<br>

(서버측)

1. 서버측의 어플리케이션에서 송신할 데이터를 모두 송신 완료 한 후 `close` 를 호출한다.
2. 서버측 의 프로토콜 스택에서 연결 종료에 관한 정보를 설정하여 TCP 헤더를 구성한다.
    1. TCP 헤더의 FIN 컨트롤 비트를 1로 설정한다.
3. 서버측 프로토콜 스택의 IP 담당 부분에게 송신을 요청하여 클라이언트 측에게 송신한다

<br>

(클라이언트 측)

1. 클라이언트 측의 프로토콜 스택의 TCP 담당 부분에서 패킷을 해석한다.
2. FIN 번호가 1인 패킷을 잘 받았다는 응답 ACK 번호를 서버측에게 송신한다.
3. 이 후 애플리케이션이 수신용 메모리 버퍼에 데이터를 가지러 올때 까지 대기한다.
4. 애플리케이션에서 read를 호출했을때 
    1. 우선 서버측에서 연결 종료 단계에 들어갔다는 사실을 알린다.
    2. 수신용 메모리 버퍼의 데이터를 애플리케이션에게 넘긴다.
5. 데이터의 수신을 완료한 클라이언트 측도 Socket 라이브러리의 `close`를 호출하고 연결 종료단계로 들어간것을 알린다.
    1. TCP 헤더의 FIN 컨트롤 비트를 1로 설정
    
    <br>

(서버측)

1. 클라이언트가 송신한 패킷을 해석한 후 그에 대한 응답 메시지를 송신한다.

이 과정을 통해 서버와의 대화 즉 커넥션이 종료되게 된다.

<br>

* * *

<br>

### **소켓의 말소**

서버와의 커넥션이 끝나면 소켓은 필요 없어지기 때문에 말소하게 된다.

⇒ 단, 커넥션 종료시 바로 말소하지 않고 잠시 기다린 후 말소하게 된다.

<br>

**<그렇다면 왜 즉시 사라지지 않는 걸까?>**

- 위의 연결 끊기 과정에서 9번 단계에 서버측의 ACK을 클라이언트 측에서 받기 전 소켓을 말소 했을 경우
    
    ⇒ 클라이언트 측의 전 소켓과 동일한 포트로 새로운 소켓을 생성 되어있다면,
    
    ⇒ 예상과 다르게 동일한 포트의 소켓이 연결 종료가 될 수 있다
    
    ⇒ 위와 같은 오작동을 피하고자 잠시 기다린 후 말소하게 된다.
    
<br>

**<얼마 만큼의 시간 뒤에 말소하게 될까?>**

- 패킷을 보내고 타임 아웃 시간 동안은 패킷이 네트워크에 존재할 가능성이 있으므로
    
    패킷의 재전송 동작이 완전히 끝나는 시간 동안 기다리게 된다.
    
    ⇒ 정확한 규정은 없지만 보통 몇 분 정도 기다리고 소켓을 말소한다.
