# 프로토콜 스택 ┃ Part 2

- [프로토콜 스택 ┃ Part 2](#프로토콜-스택--part-2)
  - [들어가며](#들어가며)
  - [데이터 송신과 송신 버퍼](#데이터-송신과-송신-버퍼)
  - [데이터 송신과 패킷](#데이터-송신과-패킷)
  - [TCP 오류 검출과 회복](#tcp-오류-검출과-회복)

## 들어가며

지난 주차에 이어 프로토콜 스택의 동작을 다음 주석부터 이어가자.

```
browser{
  DNS 송·수신 동작

  Socket.socket();  
  Socket.connect(); 
  Socket.write();     // +++ Start!
  Socket.read();
  Socket.close();
}
```

## 데이터 송신과 송신 버퍼

`Socket.write()`는 애플리케이션이 송신 데이터를 프로토콜 스택에 건네주는 것으로 시작한다.

프로토콜 스택은 애플리케이션으로 부터 받은 송신 데이터를 바로 송신하지 않고,

송신용 버퍼 메모리 영역에 저장한다.

이때, 애플리케이션이 송신 데이터를 한 번에 보낼지, 세분화해서 보낼지가 다르며

세분화한다면, 세분화된 데이터를 모두 송신용 버퍼에서 받기 위해 프로토콜 스택이 기다리기도 한다.

이 판단을 하는 요소는 2가지는 다음과 같다.

1. 한 패킷에 저장할 수 있는 데이터의 크기
2. 타이밍

## 데이터 송신과 패킷

송신 데이터를 한 번에 보낼 수 없을 정도로 데이터가 크다면,

분할시켜 분할한 데이터를 만든다. 즉, 패킷을 만든다.

분할된 패킷들은 각자의 TCP 헤더가 부가된다.

## TCP 오류 검출과 회복

TCP는 수신처가 올바르게 받았는지를 확인하는 기능이 있다.

별도의 슬라이드에서 확인해볼건데, 앞서 등장하는 단어의 역할을 짚고 슬라이드를 통해 이해하자.

    시퀀스 번호:      중복된 세그먼트 검출
    SYN 컨트롤 비트:  수신측과 접속 성공 여부
    ACK 컨트롤 비트:  수신측으로의 올바른 도착 여부

이제 아래 대본과 함께 [슬라이드](https://slides.com/kimyongki/deck-2ebcd7/embed)를 확인해보자.

1. 송신측은 송신측의 TCP 헤더를 만들고, 수신처의 포트 번호를 지정한다.
2. `송신측의 시퀀스 번호`와 `SYN 컨트롤 비트`를 1로 만든다.
3. 송신측은 요청 세그먼트를 보낸다.
4. 수신측은 요청 세그먼트를 받는데, 송신측의 시퀀스 번호를 통해 `중복된 세그먼트를 검출`한다.
5. 검출을 통과한 세그먼트를 받았다면, 수신측은 수신측의 TCP 헤더를 만든다.
6. `수신측의 시퀀스 번호`와 `SYN 컨트롤 비트를 1`로 만든다. 
7. 수신측은 또한, `ACK 번호를 송신측 시퀀스 번호 + 1`로 지정하고, `ACK 컨트롤 비트를 1`로 만든다. 이는 요청 세그먼트에 대한 확인을 나타낸다.
8. 수신측은 응답 세그먼트를 송신측에 보낸다.
9. 송신측은 `SYN 컨트롤 비트 1`로 수신측과 접속 성공을 확인한다.
10. 접속 성공을 확인하면, 송신측 소켓에 수신측 제어 정보를 기록한다.
11. 송신측은 응답 세그먼트를 받는데, `ACK 번호가 자신(송신측)의 시퀀스 번호 + 1`인지 검출한다.
12. 검출을 통과한 세그먼트를 받았다면, 송신측은 송신측의 TCP 헤더를 다시 만든다. 
13. 송신측은 `ACK 번호를 수신측의 시퀀스 번호 + 1`로 지정하고, `ACK 컨트롤 비트를 1`로 만든다. 이는 응답 세그먼트에 대한 확인을 나타낸다.
14. 이렇게 응답 세그먼트에 대한 확인 세그먼트를 수신측에 보낸다.

...