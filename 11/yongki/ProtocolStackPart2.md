# 프로토콜 스택 ┃ Part 2

- [프로토콜 스택 ┃ Part 2](#프로토콜-스택--part-2)
  - [TCP 오류 검출과 회복](#tcp-오류-검출과-회복)
  - [데이터를 송·수신 한다.](#데이터를-송수신-한다)
    - [송신 버퍼와 분할](#송신-버퍼와-분할)
    - [패킷 최소화](#패킷-최소화)
  - [서버에서 연결을 끊어 소켓을 말소한다.](#서버에서-연결을-끊어-소켓을-말소한다)
    - [말소 과정의 변수](#말소-과정의-변수)
  - [참고 문헌](#참고-문헌)

## TCP 오류 검출과 회복

TCP는 수신처가 패킷을 올바르게 받았는지를 확인하는 기능이 있다.

지난 주차의 `서버에 접속한다`의 [접속](https://slides.com/yongki150/deck-2ebcd7/embed)의 과정에서 TCP 오류 검출을 추가한 부분을 더해서 확인해보자.

이에 앞서, 등장하는 단어의 역할을 짚어보자.

    시퀀스 번호:      중복된 패킷 검출
    ACK 번호:         송신측에 대한 수신측의 응답 패킷인지 검출, 아닐 시 재전송
    SYN 컨트롤 비트:  수신측과 접속 성공 여부
    ACK 컨트롤 비트:  수신측으로의 올바른 도착 여부

1. 송신측은 TCP 헤더를 만들고, 송·수신처의 포트 번호를 지정한다. 

    **송신측이 클라이언트라면 송신측의 포트 번호는 지정되어 있지 않고, 미사용 값에서 적당히 할당한다.**
2. `송신측의 시퀀스 번호`와 `SYN 컨트롤 비트`를 1로 설정한다.
3. 송신측은 요청 패킷을 보내고, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        송신측의 소켓 상태:  SYN_SENT
        수신측의 소켓 상태:  ­­-
4. 수신측은 요청 패킷을 받는데, 송신측의 시퀀스 번호를 통해 `중복된 패킷을 검출`한다.
5. 검출을 통과한 패킷을 받았다면, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        송신측의 소켓 상태:  SYN_SENT
        수신측의 소켓 상태:  ­­SYN_RECEIVED
6. 수신측은 `수신측의 시퀀스 번호`와 `SYN 컨트롤 비트`를 1로 설정한 TCP 헤더를 만든다
7. 수신측은 요청 패킷에 대한 응답 패킷으로 `ACK 번호`를 `송신측 시퀀스 번호 + 1`로, `ACK 컨트롤 비트`를 1로 설정한다.
8. 수신측은 응답 패킷을 송신측에 보낸다.
9.  송신측은 응답 패킷을 받는데, 
    `ACK 번호`가 `자신(송신측)의 시퀀스 번호 + 1`인지 검출
    `SYN 컨트롤 비트` 1로 수신측과 접속 성공을 확인하고, 
    프로토콜 스택이 해당 소켓의 상태를 기록한다.
    
        송신측의 소켓 상태:  ESTABLISHED
        수신측의 소켓 상태:  ­­SYN_RECEIVED
10. 송신측은 응답 패킷에 대한 확인 패킷으로 `ACK 번호` `수신측의 시퀀스 번호 + 1`로, `ACK 컨트롤 비트`를 1로 설정한 TCP 헤더를 만든다.
11. 송신측은 응답 패킷에 대한 확인 패킷을 수신측에 보낸다.
12. 수신측은 확인 패킷을 받으면, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        송신측의 소켓 상태:  ESTABLISHED
        수신측의 소켓 상태:  ­­ESTABLISHED

## 데이터를 송·수신 한다.

지난 주차에 이어 프로토콜 스택의 동작을 다음 주석부터 이어가자.

```
browser{
  DNS 송·수신 동작

  Socket.socket();  
  Socket.connect(); 
  Socket.write();     // +++ Start!
  Socket.read();
  Socket.close();
}
```

### 송신 버퍼와 분할

`Socket.write()`는 애플리케이션이 송신 데이터를 프로토콜 스택에 건네주는 것으로 시작한다.

프로토콜 스택은 애플리케이션으로 부터 받은 송신 데이터를 

    바로 송신하지 않고, 송신용 버퍼 메모리 영역에 저장함으로써 기다린다.

애플리케이션이 프로토콜 스택에게 

    데이터에 대한 송신 의뢰를 한 번에 보낼지, 세분화 할지가 다르기 때문이다.

기다리는 판단을 하는 요소 2가지는 다음과 같다.

1. MSS[^mss]
    [^mss]: 헤더를 제외한 하나의 패킷에 저장할 수 있는 데이터의 크기

    즉, 프로토콜 스택 ∋ 송신용 버퍼 ∋ 하나의 패킷의 MSS가 채워질때 까지 기다린다.
    
2. 타이머

    애플리케이션의 송신 의뢰가 늦을 시, MSS가 채워지지 않아도

    프로토콜 스택 ∋ 타이머를 통해 일정 시간 이상 경과하면 패킷을 송신한다.

이 둘은 트레이드 오프 관계에 있으며, OS 종류에 따라 절충안이 다르다.

송신 데이터가 MSS를 초과할 정도로 데이터가 크다면, 분할시킨다.

분할되는 조각의 크기는 역시 MSS가 되겠고, 분할한 조각마다 각자의 패킷을 만들어 송신한다.

### 패킷 최소화

`Socket.read()`는 [데이터 송·수신](https://slides.com/yongki150/week-11-connect/embed)하는 과정으로 확인해보자.

이에 앞서, 등장하는 단어의 역할을 짚어보자.

    시퀀스 번호:    송신할 조각 데이터의 맨 앞 위치
    ACK 번호:       수신한 조각 데이터의 맨 뒤 위치로, 그 다음 받을 조각 데이터의 맨 앞 위치를 통보
    윈도우:         수신측에서 송신측에 수신 받을 수 있는 양을 통지

앞서 접속의 과정에서 서버측이 응답 패킷을 클라이언트측에 보내는 과정에서 

TCP 헤더에 `윈도우 필드가 추가`된다.

클라이언트측이 응답 패킷을 받을 때, 서버측의 수신용 버퍼를 고려하여 송신 가능 데이터를 추린다.
   > 이는 수신측이 윈도우 필드를 응답 패킷 마다 보낼 필요가 없는 이유이다.

클라이언트측으로부터 데이터 요청 패킷을 받은 서버측은 수신용 버퍼에 적재한다.

패킷 최소화는 이 시점에 2가지 상황에서 이뤄진다.

a. 수신용 버퍼에 적재 도중 서버측 애플리케이션에 의해 버퍼가 일부 비워지는 상황과
       
    윈도우 필드가 추가된 패킷을 클라이언트측에게 응답 패킷 외에도 알려야하는데,
    
    데이터 응답 패킷 or 윈도우 통지 패킷 중 먼저 만들어진 쪽이 잠시 기다린 뒤, 합승한다.

b. `윈도우 제어 방식`에서 여러 요청 패킷이 모두 성공적으로 수신했을 상황이다.
 
    요청 만큼 응답 패킷을 주는 것이 아닌, 하나의 응답 패킷에 합승시킨다.

## 서버에서 연결을 끊어 소켓을 말소한다.

데이터 송·수신을 종료하는 측은 HTTP 프로토콜의 버전과 애플리케이션에 따라 다르므로, 

어느 쪽이든 종료할 수 있도록 프로토콜 스택은 만들어져있다.

서버측에서 종료하는 예시를 준비해보았다.

`Socket.close()`는 [말소](https://slides.com/yongki150/week-11-connect-fa98e2/embed)의 과정으로 알아보자.

1. 서버측은 `FIN 컨트롤 비트`를 1로 설정한 TCP 헤더를 만든다.
2. 서버측의 말소 요청 패킷을 보내고, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        서버측의 소켓 상태:             FIN_WAIT_1
        클라이언트측의 소켓 상태:       ­­-
3. 클라이언트측은 서버측의 말소 요청 패킷을 받으면, 프로토콜 스택이 해당 소켓의 상태를 기록한다.
    
        서버측의 소켓 상태:             FIN_WAIT_1
        클라이언트측의 소켓 상태:       CLOSE_WAIT
4. 클라이언트측은 `ACK 컨트롤 비트`를 1로 설정한 TCP 헤더를 만든다.
5. 클라이언트측은 서버측의 말소 요청에 대한 응답 패킷을 보내고, 소켓과 관련된 애플리케이션에게 종료 프로세스를 요청한다.
6. 서버측이 응답 패킷을 받으면, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        서버측의 소켓 상태:             FIN_WAIT_2
        클라이언트측의 소켓 상태:       CLOSE_WAIT
7. 종료 프로세스를 받은 애플리케이션이 종료하면,
8. 클라이언트측은 `FIN 컨트롤 비트`를 1로 설정한 TCP 헤더를 만든다.
9. 클라이언트측은 말소 요청 패킷을 보내고, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        서버측의 소켓 상태:             FIN_WAIT_2
        클라이언트측의 소켓 상태:       LAST_ACK
10. 서버측이 클라이언트측의 말소 요청 패킷을 받으면, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        서버측의 소켓 상태:             FIN_WAIT_2 → TIME_WAIT
        클라이언트측의 소켓 상태:       LAST_ACK

    만약, 서버측이 클라이언트측의 말소 요청 패킷을 받지 못한 경우는 클라이언트측이 말소를 진행할 수 없다.

    그러면 서버측의 소켓 상태는 일정 시간 이후 자동 말소된다.

                                        FIN_WAIT_2 → CLOSED


11. 서버측은 `ACK 컨트롤 비트`를 1로 설정한 TCP 헤더를 만든다.
12. 서버측은 클라이언트측의 말소 요청에 대한 응답 패킷을 보내고, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        서버측의 소켓 상태:             CLOSED
        클라이언트측의 소켓 상태:       LAST_ACK

13. 클라이언트측이 응답 패킷을 받으면, 프로토콜 스택이 해당 소켓의 상태를 기록한다.

        서버측의 소켓 상태:             CLOSED
        클라이언트측의 소켓 상태:       CLOSED

### 말소 과정의 변수

클라이언트측의 말소 요청 패킷 이전에 서버측이 말소 되었다면,

클라이언트측의 말소 요청 패킷이 

이전의 서버측의 소켓이 아닌, 새로 할당된 서버측의 소켓을 말소 해버릴 수 있다.

이를 방지하고자 서버측은 바로 말소 하지 않고, `TIME_WAIT`한다.

<hr/>

## 참고 문헌

[Handsake 간의 소켓 상태](https://goodgid.github.io/TCP-IP-3Way-4Way/) ━ *goodGid*