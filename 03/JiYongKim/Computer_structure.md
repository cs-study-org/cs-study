# 컴퓨터 내부 구조
주요 개념 단위만 짚고 넘어감.

<br>

## 목차
## 1. CPU
## 2. Bus Interface
## 3. Register
## 4. 32bit? 64bit?
## 5. 컴퓨터 구성요소간 통신
## 6. 데이터 단위
## 7. Big Endian & Little Endian
## 8. RISC & CISC
<br>

* * *

<br>


## CPU (Central Processing Unit)

    cpu란 컴퓨터의 중앙 처리 장치로  4대 주요 기능 (기억 ,해석, 연산, 제어)를 관할 하는 장치 이다.


<img width="694" alt="하드웨어 구조" src="https://user-images.githubusercontent.com/81874493/147878638-e664db92-072f-48f2-97e6-49ccad4154e9.png">

**내부 구성**

- **ALU** : 덧셈, 뺄셈 같은 두 숫자의 **산술연산**과 배타적 논리합, 논리곱, 논리합 같은 **논리연산**을 계산하는 디지털 회로

<br>

- **Control Unit** : CPU가 처리해야하는 명령어를 해석하고 그에 맞는 신호 발생
    
    ⇒ 레지스터와 ALU 사이의 명령 흐름을 제어

<br>

- **Bus Interface** : 컴퓨터 하드웨어 요소간 데이터를 서로 주고 받을 수 있는 통로 역할
    
    ⇒ Bus Interface는 외부의 입출력 버스(I/O Bus == System Bus)와 연결됨
    
    ⇒ CPU의 외부와 연결되어 있으며 외부에서 들어오는 데이터를 받거나, 데이터를 보내는 역할을 담당

<br>

- **Register** : CPU 내부의 임시 저장 공간
    
    ⇒ 연산 후에 나오는 임시 데이터를 저장하거나, CPU의 상태, 다음 명령의 메모리 번지수.. 등이 이 레지스터에 기억


<br>

> ⇒ Bus Interface 와 Register에 대해서만 조금 더 자세히 알아보고 가자

<br>

* * *

<br>

## Bus Interface

Bus Interface 는 <U>**CPU 외부와 데이터를 주고 받는 통로**</U> 이다.

- CPU 내부의 버스 인터페이스는 외부의 입출력 버스(I/O Bus)와 연결된다
    
    ⇒CPU의 외부와 연결되어 외부에서 들어오는 데이터를 받거나, 데이터를 보내는 역할을 담당
    
    ⇒ 즉 명령어를 내보내거나 입출력 버스를 통해 데이터를 받을 수 있다.
    
    <br>
    
- 시스템 버스( System Bus )==입출력 버스 (I/O Bus)
    
    시스템 버스는 다른 하드웨어 구성 요소 사이에서 데이터를 교환하기 위해 거치는 통로 이다.
    

    <img width="694" alt="하드웨어 구조" src="https://user-images.githubusercontent.com/81874493/147878644-c43feb9c-2a67-4d5c-9a67-abdfd8749691.png">

    - 그림에서 CPU와 메모리,I/O 장치(키보드, 마우스..etc)와 연결되어 구성 요소 사이의 데이터 입출력이 가능해진다.
    - 시스템 버스 에서 전송되는 데이터에 따라 버스가 분류된다.

        <br>

        - Address Bus
            
          >  ⇒ CPU가 메모리에서 읽거나 써야할 때 메모리의 물리적 주소 지정 및  데이터 받아올때의 주소 전달에 사용
            
           > ⇒ 혹은 I/O 장치의 포트 번호 전달에 사용
            
            >   - 주소 버스는 “cpu에서 → 메모리” 로는 단방향 버스 사용
            >   - 주소 버스는 (cpu,메모리) 와 I/O unit 간에는 양방향 버스 사용

        <br>
        
        - Data Bus
            
            >⇒ CPU와  메모리 혹은 I/O 장치의에서 데이터 전송할때 사용
            
            >   - 데이터 버스는 각 구성요소 (cpu, 메모리 , I/O unit)는 양방향 전달 가능 버스 사용

        <br>
        
        - Control Bus
            
            > ⇒ 현재 CPU의 상태나, 상태 변경등의 제어 신호 ( Read / Write)를 메모리 혹은 I/O 장치에 전송하는데 사용 
            
            >   - 컨트롤 버스는 각 구성요소 (cpu, 메모리 , I/O unit)는 양방향 전달 가능 버스 사용

<br>

* * *

<br>

## 레지스터(Register)

<br>

레지스터란 CPU(Central Processing Unit) 내부에서 <U>**산술 연산 처리하는데 필요한 데이터를 일시적으로 저장하는 기억장치**</U>이다.

<br>

- 필요성
    - 하드디스크 - 컴퓨터에 데이터를 영구 저장하기 위해 이용
    - 메인메모리 - Ram(주 기억장치)는 프로그램의 코드가 메모리에 적재되어 실행되는 곳이며, 프로그램 실행을 위해 이용

    <br>
    
    >⇒ CPU는 **자체적으로 데이터 저장할 방법이 없기 때문**에 메모리로 직접 데이터를 전송 할 수 없어 CPU 연산결과를 임시로 저장할 CPU 내부의  저장공간이 필요하다.
    
    <br>

    >⇒ CPU의 연산 결과를 메모리에 보내고 영구적으로 저장할 데이터를 하드디스크에 저장해야하는 등의 명령을 처리하기 위해
    
    > =>  메모리, 하드디스크에 저장될 위치(주소) 와 명령의 종류 를 저장할 수 있는 기억 공간이 필요하다
    
    → 이 역할들을 해주는 것이 CPU 내부에 존재하는 **레지스터** 이다.
    
    <br>

- 동작
    1. Fetch : 사용자 명령과 주 기억장치에 저장된 프로그램을 CPU 프로세서로 가져온다.
    2. Decode : 가져온 명령을 해석한다.
    3. Execute : CPU에 의해 생성된 결과를 메모리에 저장한다.
    
- 특징
    - 레지스터는 메모리 계층의 최상위에 위치하며 가장 빠른 속도로 접근 가능한 메모리
    - 메모리와 레지스터 간의 데이터 교환 (Load & Store)
        - CPU의 모든 데이터는 레지스터를 통해 밖으로 나가고 들어온다
            1. 메모리에서 필요한 데이터를 레지스터로 블러옴( Load ) 
            2. 레지스터에 저장된 연산 처리 결과를 메모리로 옮겨 저장한다( Store )
    
    <br>
        
- 레지스터 종류
    - 메모리 주소 레지스터 (MAR, Memory Address Register)
        
        >⇒ CPU가 메모리의 일부에 데이터를 저장하거나 데이터를 읽을 때 필요한 메모리 위치의 주소를 MAR에 저장한다.

        <br>
        
    - 메모리 버퍼 레지스터 (MBR, Memory Buffer Register)
        
        >⇒ 메모리를 읽거나 메모리에 쓰려는 데이터 또는 명령을 저장하는데 사용
        
        >⇒ MBR에 배치된 명령은 명령어 레지스터(IR) 로 전송
        
        >⇒ MBR에 배치된 데이터는 누산 레지스터 (AC) 또는 I/O레지스터로 전송
        
        <br>
        
    
    - I/O 주소 레지스터 (I/O Address Register)
        
        >⇒ I/O 주소 레지스터는 특정 I/O 입출력 장치의 주소를 지정하는데 사용
        
        <br>
        
    
    - I/O 버퍼 레지스터 (I/O Buffer Register)
        
        >⇒ I/O 버퍼 레지스터는 특정 I/O 모듈과 프로세서 간에 데이터 교환하는데 사용
        
        <br>
        
    - 프로그램 카운터 (PC, Program Counter)
        
        >⇒프로그램 카운터는 명령어 포인터(IP, Instruction Pointer) 레지스터 라고도 한다.
        
        >⇒ 프로그램 카운터는 프로세서가 수행할 다음 명령의 주소를 일시적으로 저장하는데 사용된다.
        
        >⇒ 명령을 가져오면 IP(Instruction Pointer) 값이 증가
        
        >⇒ 이 레지스터는 **항상 가져올 다음 명령의 주소를 가리키거나 현재 명령의 주소를 유지**한다.
        
        <br>
        
    - 명령어 레지스터(IR, Instruction Register)
        
        >⇒ 주 기억장치에서 수행할 명령을 가져오면 명령어 레지스터에 저장된다.
        
        >⇒ 제어장치는 이 레지스터의 지시를 받아 컴퓨터의 해당 구성요소로 신호를 전송하고 명령을 해석하여 실행한다.
        
        <br>
        
    - 누산기 레지스터(AC, Accumulator Register)
        
        >⇒ 누산기 레지스터는 ALU 내부에 위치하며, ALU의 산술 및 논리 연산 중에 사용된다.
        
        >⇒ 이 레지스터는 시스템에 사용될 초기 데이터, 중간 결과 및 최종 동작 결과를 보관하고 최종결과는 MBR을 통해 주기억장치로 전송된다.
        
        <br>
        
    - 스택 제어 레지스터(SCR, Stack control Register)
        
        >⇒ 이 레지스터는 FILO(First In Last Out)방식으로 메모리의 스택을 관리한다.
        
        <br>
        
    
    - 플레그 레지스터(FR, Flag Register)
        
        >⇒ 플래그 레지스터는 CPU 작동 중 특정 상태가 발생했음을 나타내는 데 사용된다.
        
        <br>
        
    - 데이터 레지스터(DR, Data Register)
        
        >⇒ 마이크로컴퓨터에서 주변 장치로 또는 주변 장치에서 전송되는 데이터를 임시로 저장하는 데 사용되는 레지스터입니다.

<br>

* * *

<br>        

## 32비트(bit)? 64(bit)?

요즘 컴퓨터들은 일반적 32/64 비트 시스템을 많이 사용한다.

>⇒ 여기서 비트의 수는 <U>**컴퓨터가 한번에 처리할 수 있는 비트 수**</U>

>⇒ 즉 <U>**CPU가 한번에 처리할 수 있는  레지스터의 저장 가능한 공간의 크기가 32bit 은지 64bit인지를 나타내는 것**</U>

<br>

- 32bit = 2^32 = 4,294,967,296
    - 32bit로 한번에 표현할 수 있는 최대 크기가 4GB이기 때문에 4GB의 메모리만 사용할 수 있음

<br>

- 64bit = 2^64 = 18,446,744,073,709,551,616
    - 64bit로 한번에 표현할 수 있는 최대 크기가 16EB(엑사 바이트)이지만 실제로 ***48bit만 사용***

<br>

⇒ 위의 수만큼 한번에 처리할 수 있다는 것 

<br>

* * *

<br>        

## **컴퓨터 구성 요소간 통신**

**1) CPU(레지스터) <----> 메모리**

- 적재(Load)와 저장(Store) 명령에 의해 수행
    
    (1) 적재(Load)
    
    - 주소 버스 : 메모리에서 불러올 데이터가 저장된 주소값이 전달(CPU -> Memory)
    - 신호 버스 : Memory Read 신호 전달(CPU -> Memory)
    - 데이터 버스 : 지정한 메모리에 저장된 값 전달(Memory -> CPU)
    
    <br>
    
    (2) 저장(Store)
    
    - 주소 버스 : 메모리에서 해당 데이터를 저장할 주소값 전달(CPU -> Memory)
    - 신호 버스 : Memory Write 신호 전달(CPU -> Memory)
    - 데이터 버스 : 저장할 데이터 전달(CPU -> Memory)

<br>

**2) CPU <----> I/O Unit**

- 입력(Input)과 출력(Output)명령에 의해 수행
    
    (1) 입력(Input)
    
    - 주소 버스 : 해당 입출력 장치의 포트 번호 전달(CPU -> I/O Unit)
    - 신호 버스 : I/O Read(input) 신호 전달(CPU -> I/O Unit)
    - 데이터 버스 : 해당 입출력 장치는 데이터 전달(I/O Unit -> CPU)
    
    <br>

    (2) 출력(Output)
    
    - 주소 버스 : 해당 입출력 장치의 포트 번호 전달(CPU -> I/O Unit)
    - 신호 버스 : I/O Write(output) 신호 전달(CPU -> I/O Unit)
    - 데이터 버스 : 입출력 장치에 데이터 전달(CPU -> I/O Unit)
    
    <br>

    (3) 인터럽트(Inputerrupt)
    
    - 입출력장치는 제어신호를 통해 인터럽트 요청을 보내 CPU에 입출력작업을 요청할 수 있음
    - 인터럽트 요청 : 입출력 준비를 마친 I/O Unit이 CPU에 입출력작업의 시작 요청
    - 인터럽트 확인 : CPU가 입추력 동작을 수행할 것을 입출력장치에 통보

<br>

**3) 메모리 <----> I/O Unit**

- 입출력장치와 메모리의 통신은 CPU를 이용하지 않고 직접 기억장치 액세스 방식(DMA, Direct Memory Access)으로 통신
- DMA 제어기는 CPU를 대신해 주소 버스와 제어버스에 신호를 전달
- DMA 제어기는 통신 시작 전 CPU에 버스 사용해 대한 허가를 받아야함

<br>

* * *

<br>

## 데이터의 단위

1. 비트 (Bit)
    - 컴퓨터 시스템에서 데이터 연산을 하거나 표현할 수 있는 제일 기본 단위로 자리값 마다 0과 1 두가지(2진수)로만 표현할 수 있다.
<br>

2. 바이트(Byte)
    - 8개의 비트를 모아 하나의 바이트라 한다.
    - 10진수 0~255 까지, 16진수 0~0xFF 까지 표현 가능하다.

<br>

3. 워드(Word)
    - 컴퓨터 구조에서, 워드란 하나의 연산을 통해 저장 장치로부터 프로세서의 레지스터에 옮겨 놓을 수 있는 데이터 단위이다.
        >- 32bit 컴퓨터 ⇒ 1 word = 32bit
        >- 64bit 컴퓨터 ⇒ 1 word = 64bit
        
        <br>
    - **워드의 길이라는 cpu가 한번에 읽어들일 수 있는 bit의 개수**를 나타낸다. 따라서, **명령어 역시 워드 길이와 같아야 한다**.(1워드 명령어인 경우에)
    - cpu가 한번에 다룰 수 있는 데이터 역시 워드 길이만큼의 제한을 가지게 되므로 중간중간 cpu 작업 효율을 높이게 위해 사용하는 **데이터 레지스터** 역시 워드 길이와 같다.
    - **스택이나 연관된 데이터를 저장하기 위한 버퍼** 역시 한 계층의 길이는 워드 길이와 동일하다.
    
    >⇒ MBR(memory - buffer - register)의 길이 = IR(instruction register)의 길이 = DR(data register)의 길이
    
    <br>

4. 이후 KB > MB > GB > TB ... 파일의 단위로 많이 사용된다.

<br>

* * *

<br>

## Big Endian & Little Endian

- Bit & Byte
    - 컴퓨터는 모든 데이터를 2진수로 표현/처리
    - 비트(bit) = 컴퓨터가 데이터를 처리하기 위해 사용하는 데이터의 최소 단위
    - 바이트(byte) = 8개의 비트가 모여 구성되며, 한 문자를 표현할 수 있는 최소 단위
    
    <br>

- 바이트 저장 순서
    - 컴퓨터는 데이터를 메모리에 저장할때 byte 단위로 나누어 저장
        - 컴퓨터가 한번에 저장하는 크기는
            >- 32비트(4바이트)
            >- 64비트(8바이트)
        
        <br>

        ⇒ 따라서 연속되는 큰 데이터는 바이트 순서대로 나누어 저장해야 한다.
        
        ⇒ 이때 연속되는 바이트를 저장하는데 사용되는 순서를 바이트 저장 순서(Byte order) 라고 한다.
        
        <br>
        바이트가 저장 되는 순서에 따라 두가지 방식으로 분류된다
        
        >- 빅 엔디안(Big Endian)
        >- 리틀 엔디안(Little Endian)
        
        <br>

- 빅 엔디안(Big Endian)
    
    빅 엔디안 방식은 <U>**낮은 주소에 데이터의 높은 바이트(MSB)부터 저장하는 방식**</U>
    
    - 이 방식은 평소 사람이 숫자를 사용하는 선형 방식과 같은 방식
    - 메모리에 저장된 순서 그대로 읽을 수 있다.
    - 이해하기 쉽다.
    - RISC CPU 계열에서는 이 방식으로 데이터를 저장
    
    - 예시
        
        >저장할 32비트 크기의 정수 ⇒ 0x12345678 
        
        >이 정수를 각각 1바이트 값으로 나눔 ⇒ 0x12, 0x34, 0x56, 0x78
        
        >빅엔디안 방식으로 저장
        

        <img width="487" alt="빅 엔디안" src="https://user-images.githubusercontent.com/81874493/147878656-3cd7a892-0e4a-42d8-b765-936097802978.png">

       <br>

- 리틀 엔디안(Little Endian)
    
    리틀 엔디안 방식은 <U>**낮은 주소에 데이터의 낮은 바이트(LSB) 부터 저장하는 방식**</U>
    
    - 리틀 엔디안은 사람이 숫자를 사용하는 선형 방식과 반대로 읽어야 한다.
    - 인텔 cpu 계열에서는 리틀 엔디안 방식으로 데이터를 저장한다.
    
    - 예시
        
        >저장할 32비트 크기의 정수 ⇒ 0x12345678 
        
        >이 정수를 각각 1바이트 값으로 나눔 ⇒ 0x12, 0x34, 0x56, 0x78
        
        >리틀엔디안 방식으로 저장
    

    <img width="625" alt="리틀 엔디안" src="https://user-images.githubusercontent.com/81874493/147878674-bb909237-8659-4135-80c4-8dc6182def5c.png">

    <br>

- 빅 엔디안 vs 리틀 엔디안 
    - 수학적 연산
        - 수학적 연산에 있어 LSB 부터 연산하는 방식과 같기 때문에
        
            >⇒ 리틀 엔디안을 사용했을때 더 쉽다/빠르다
         
    <br>

    - 타입 변환
        - 타입 변환에 있어 LSB 부터 몇 비트까지 잘라 형변환 하기 때문에
        
            >⇒ 리틀 엔디안을 사용했을 때 쉽다/빠르다
         
    <br>

    - 숫자 비교
        - 숫자 비교에 MSB 부터 확인하게 되기 때문에
        
            >⇒ 빅 엔디안을 사용했을 때 더 쉽다/빠르다
         
    <br>

    - 디버깅, 확인
        - 메모리 내 특정 값들을 확인시 사람이 읽는 순서와 동일해야 편함
        - 빅 엔디안 방식은사람이 읽는 순서로 메모리에 저장됨
        
            >⇒ 빅 엔디안을 사용했을때 더 쉽다/빠르다
        
    <br>

    - 네트워크 바이트 오더
        - 네트워크 상 데이터 전송시 네트워크 바이트 오더를 준수해야 한다
        - 네트워크 바이트 오더는 빅 엔디안이 가장 흔한 포멧
            - <U>**TCP, UDP, IPv4, IPv6과 같은 프로토콜은 빅 엔디안 방식 사용**</U>
            - 소켓 통신시 자주 사용되는 읽기/쓰기 함수들 경우 내부적으로 엔디안 변환 처리가 다 되어 있다.

<br>

* * *

<br>

## RISC 와 CISC

CPU 설계 방식에 있어 **”구조적 측면의 차이로 어떻게 명령어를 처리하느냐”** 의 기준으로 2가지로 분류된다.

- CISC ( Complex Instruction Set Computer )
    
    확장형 컴퓨터 또는 복합 명령 집합 컴퓨터의 의미로, 복합적인 명령어 셋을 통해서 연산한다는 뜻을 가진다.
    
    - 대표적 CPU는 intel사 x86
    - 특징
        - 여러개의 단순한 명령어의 포괄적인 하나의 명령어로 처리해 효율을 도모
            
            > ⇒ 프로그램을 복잡하게 하는 연산 기능들을 CPU에 하드웨어로 준비해 놓고 간단한 명령으로만 실행시킨다는 것
          
          <br>

        - CISC를 대상으로 하는 고급 언어의 컴파일러는 비교적 간단하게 실행된다. ( 하드웨어는 복잡하게 , 소프트웨어는 간단하게)
        
        <br>

        - CISC는 소프트웨어에는 쉽지만, 하드웨어에는 복잡한 기능의 논리 설계가 어려운 아키텍쳐
        
        <br>

- RISC ( Reduced Instruction Set Computer )
    
    축소 명령형 컴퓨터라는 의미로 **명령의 종류를 줄이고, 내부회로를 단순하게 만들어** 그 하나하나의 명령을 **고속**으로 실행 시킬 수 있도록 향상 시킨 아키텍쳐 이다.
    
    - 대표적 ARM의 ARM시리즈
    - 특징
        - CISC와는 반대로 기본 명령어 셋을 추구하는 형태
            
            >⇒ 컴퓨터에서 주 수행되는 작업을 색출하여, 그것을 토대로 최적화 시켜 만든다.
            
            <br>

        - RISC는 명령어가 적기 때문에 복잡한 명령을 단순한 명령으로 나타내야 하기 때문에 프로그램의 크기가 커지고 고급언어의 컴파일도 복잡하게 된다.
        
        <br>

        - RISC는 하드웨어는 쉽지만 소프트웨어에서 어려운 아키텍쳐
        
        <br>

- RISC와 CISC  차이
    - 캐시
        - CISC는 복합적인 명령어를 많이 가지고 있어, 트랜지스터 직접도가 과다하게 늘어나 캐시의 크기가 작아질 수 밖에 없다.
        - RISC는 명령어 체계 단순화를 지향하고, 핵심 명령 특화 체제에 있어, 트렌지스터 직접 여분이 있기 때문에 L1 캐시를 증대시켜 성능을 더욱 증대 시킬 수 있다.
    - 성능
        
        RISC > CISC
        
    - 클럭 속도
        
        RISC < CISC
        
- 결론
    
    CISC는 복합 명령을 가짐으로써 하위 호환성을 충분히 확보할 수 있고 RISC의 경우 효율적인 CPU 구조를 가지고 있다.
    
     <U>**다만 CISC는 트랜지스터 집적에 있어서 효율성이 결여되어 있고, 그 결과 성능 향상에 난점**</U>을 겪고, <U>**RISC의 경우 하위 호환을 위해 에뮬레이션 방식을 채택해야 하고, 일정한 환경에서만 성능을 발할 수 있는 단점**</U>이 있는 것이다.
    
    >⇒ 따라서 호환성이 절대적으로 필요한 PC 환경에서는 CISC가, 전문적인 일에 있어서는 RISC가 서로 독보적인 우위에 점하고 있는 것이다.

<br><br>

# 참고자료

[엔디안 예시 참고 문헌](https://jhnyang.tistory.com/226)
