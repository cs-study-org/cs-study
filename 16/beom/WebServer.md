# 서버의 개요

## 클라이언트 vs 서버
- 네트워크에 관한 부분(LAN 어댑터, 프로토콜 스택, Socket 라이브러리)의 기능이 동일하다.
- 서버는 여러개의 클라이언트와 대화하는 구조이다.


## 웹 서버의 구조
웹 서버는 두 부분으로 나눌 수 있다.
1. 서버 프로그램에서 클라이언트의 접속을 기다리는 부분
2. 클라이언트와 대화를 나누는 부분

`1번`은 서버 프로그램이 실행되어 초기화 작업을 마친 상태이다.(클라를 기다리는)
`2번`은 클라가 접속을 할 때 실행되어 소켓을 건네주고 대화

`2번`은 각 클라이언트와 1대1로 대화를 한다. 즉 대화가 섞이지 x
- 이유는 서버 OS가 **멀티태크스** 또는 **멀티스레드**라는 기능에 의해 다수의 프로그램을 동시에 작동할 수 있기 때문이다.

> 클라이언트의 데이터 송, 수신 동작
> 1. 소켓을 만듬.(소켓 작성 단계)
> 2. 서버측의 소켓과 파이프로 연결.(접속 단계)
> 3. 데이터를 송, 수신.(송, 수신 단계)
> 4. 파이프를 분리하고 소켓을 말소.(연결 끊기 단계)

> 서버의 데이터 송, 수신 동작
> 1. 소켓을 만듬.(소켓 작성 단계)
> 2. 소켓을 접속 대기 상태로 만듬(접속 대기 상태)
> 3. 접속을 접수(접속 접수 단계)
> 4. 데이터 송, 수신(송, 수신 단계)
> 5. 파이프 분리 후 소켓 말소(연결 끊기 단계)

![웹 소켓 연결과정](asset/websocket.png)

위와 같이 동작하는데

웹서버가 accept를 통해 클라이언트로부터 소켓을 접수하면

3way-handshaking을 통해 연결을 하고 접속 대기 소켓을 복사하여 독립된 새로운 소켓을 생성한다.

독립된 새로운 소켓은 독립적으로 실행되고

기존의 접속 대기 상태의 소켓은 다시 다른 클라이언트의 connecting을 기다린다.

## 웹 소켓의 포트번호
이전에 학습할 때 이 부분에서 많이 헷갈렸다.

웹에서 포트번호는 80번으로 알고 있는데 그럼 모든 웹은 80번 포트를 사용한다.

그럼 복사된 소켓도 포트번호가 80이기 때문에 소켓을 식별할 수 있는 방법은 무엇인가??

**해결 방법**
- 정보를 조합해서 소켓을 식별한다.
  - 클라이언트의 IP주소
  - 클라이언트의 포트 번호
  - 서버의 IP주소
  - 서버의 포트 번호(80번 고정)

1. 웹서버의 포트 번호는 80번으로 고정이다.
2. 하지만 클라이언트의 포트번호를 아무번호나 할당가능하다.
3. 하지만 다른 클라이언트끼리는 포트 번호가 중복이 날 수 있다.
4. 하지만 각 클라이언트의 IP주소는 다르기 때문에 식별 가능

## 소켓 - 파일 디스크립터
사실 소켓을 식별할 경우 포트번호를 사용하는 것이 아니라 파일 디스크립터를 사용한다. 

파일 디스크립터란 **시스템(운영체제)이 특정 파일에 할당해준 정수값을 의미한다.**

이는 우리가 흔히 알고 있는 파일뿐 아니라 소켓과 같은 자원도 가지고 있는값이다. 

예를 들어 소켓을 생성하는 socket()함수, 연결을 수락하는 accept() 함수 모두 파일 디스크립터 값을 반환한다.

우리가 자주 사용하는 표준 입출력은 이미 파일 디스크립터 값이 할당되어 있으며, 아래와 같다

> stdin(표준입력) : 0
> stdout(표준출력) : 1
> stderr(표준에러) : 2

이야기가 조금 다른곳으로 흘러갔지만 이와 같이 소켓에서는 socket() 함수와 accept() 함수를 통해 파일 디스크립터 값이 할당받아 식별한다.

**소켓을 식별하기 위해 디스크립터를 사용하는 이유**
- 접속을 대기할 때는 아직 클라이언트 소켓이 지정되지 않았으므로 정보가 x
- 디스크립터라는 한 개의 정보로 식별하는 것이 더 간단하기 때문에







