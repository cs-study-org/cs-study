# Chapter6

<웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다.>

## Story1 서버의 개요

<br>

### 1) 서버 애플리케이션의 구조

서버는 동시의 복수의 클라이언트와 통신 동작 실행한다

>⇒ 하지만 하나의 프로그램으로 여러 클라이언트 처리는 쉽지 않다.

그렇기에 클라이언트 접속시 마다 새로운 서버 프로그램을 작동시켜 서버 애플리케이션와 클라이언트가 1대1 대화 방법을 선택하는 것이 일반적인 방식이다.

<br>

<서버 애플리케이션의 구조>

<img width="724" alt="스크린샷 2022-04-15 오후 6 29 34" src="https://user-images.githubusercontent.com/81874493/163554663-05fb5a7a-0d23-418f-ad40-0c44d7111971.png">

1. 서버 프로그램 작동하여 설정 파일 읽기등의 초기화 동작 완료
2. 서버 애플리케이션의 접속을 기다리는 곳에서 소켓 작성하고 소켓을 클라이언트에서의 접속 동작을 기다리는 상태로 만들고 대기
3. 클라이언트 접속시 작동하여 클라이언트와 통신할 소켓을 건네주고 1:1 대화하고 끝나면 연결을 끊고 이부분을 종료한다.

<br>

<서버내의 프로그램들이 동시에 함께 동작되는 이유>

서버 OS는 

- 멀티태스크
    
    ⇒ os가 가지고 있는 기능으로 복수의 테스크(프로그램)을 동시에 함게 실행하는 기능을 의미
    
- 멀티 스레드
    
    ⇒ 프로그램내의 복수의 스레드를 동시에 함께 실행하는 기능을 의미
    

를 통해 다수의 프로그램을 동시에 작동할 수 있다.

<br>

### 2) 서버측의 소켓과 포트

<클라이언트 측의 Sokcet 라이브러리 호출 단계>

1) 소켓 생성 (소켓 작성 단계)

2) 서버측의 소켓과 파이프로 연결 (접속 단계)

3) 데이터 송 * 수신 (데이터 송수신 단계)

4) 파이프를 분리하고 소켓을 말소 (연결 끊기 단계)

<서버 측의 Socket 라이브러리 호출 단계>

1) 소켓 생성 (소켓 작성 단계)

2-1) 소켓을 접속 대기 상태로 만든다 (접속 대기 상태)

2-2) 접속을 접수한다 (접속 접수 단계)

3) 데이터 송수신 (데이터 송수신 단계)

4) 파이프를 분리하고 소켓을 말소 (연결 끊기 단계)

>⇒ 위와 같이 Socket 라이브러리를 호출하는 부분은 서버와 클라이언트간 차이점이 존재한다.

⇒ 서버측의 구체적인 동작을 알아보자

<br>

<서버측의 동작 과정>

<img width="703" alt="스크린샷 2022-04-15 오후 6 29 42" src="https://user-images.githubusercontent.com/81874493/163554682-727836f8-9418-400f-97ca-e6ec36f3057a.png">

1) 우선 서버 애플리케이션의 클라이언트의 접속을 기다리는 곳을 동작 시킨다.

2) 클라이언트와 연결할 소켓을 작성한다.

3) 소켓에 포트 번호와 디스크립터를 작성하여 소켓을 구성

4) Listen을 호출하여 클라이언트의 접속을 기다리는 상태로 만든다

5) 서버에서는 accept를 미리 호출하여 접속을 접수를 대기한다

>⇒ 클라이언트의 접속 요청이 오지 않았지만 이전에 미리 accept를 호출하여 접속 접수 동작을 실행한다.

6) 클라이언트로부터 접속 요청이 들어올 경우

- 응답 패킷을 반송하여 접속 접수 동작 실행
- 접속 대기 소켓을 복사하여 새로운 소켓 생성
- 새로운 소켓에 접속 상대의 정보를 비롯 제어정보를 기록한다

>⇒ 위 과정을 통해 접속을 접수

7) accept가 끝나면 접속을 접수하는 부분은 클라이언트와 대화하는 부분에게 제어권을 넘겨 가동시킨다.

8) 클라이언트와 대화하는 곳에서는 새로운 소켓을 이용한 파이프를 연결하여 서로 데이터 송수신 이후 종료한다.

<접속 동작시의 소켓과 새로운 소켓>

접속 동작할때의 소켓은 접속 대기 상태인 채로 계속 존재한다

>⇒ 접속 접수 동작 후 대기상태의 소켓을 복사하여 접속 대상의 정보를 기록하여 사용한다.

<br>

<새로운 소켓을 만드는 이유?>

새 소켓을 만들지 않고 접속 대기 소켓에 그대로 접속시 접속 대기 소켓이 사라지기 때문에 다른 클라이언트가 접속할 수 가 없어진다.

>⇒ 즉 접속 대기 소켓은 클라이언트들의 접속 받는 기능만 하는 소켓이면 접속시 새로운 소켓을 만들어 할당해주는 형식이다.

<br>

<새로운 소켓을 만들때의 포트 번호>

포트번호는 소켓 식별을 하기 위해 사용하는 것이다.

하지만 포트 번호는 소켓을 지정하기 위한 것이지만 같은 번호로 할당된 여러 소켓이 존재하여 포트 번호로 소켓을 지정할 수 없다는 문제가 있다

>⇒ 이 문제를 위해 소켓을 지정할때 서버측의 소켓에 할당한 포트 번호 뿐 아니라 클라 측 포트번호와 Ip 주소를 통해 네가지 정보를 사용하여 구분한다.

- 클라이언트측의 IP
- 클라이언트 측의 포트 번호
- 서버측의 IP
- 서버측의 포트 번호

>⇒ 소켓 식별시 이 네가지 정보를 사용하면 되지만 소켓을 만든 직후 아직 접속하지 않은 상태일때 상대측의 정보가 준비되어 있지 않을 수 있기 때문에

>⇒ 접속 대기 소켓에 클라측의 정보가 기록되어있지 않을 수 있으며 한개의 정보로 식별하는 쪽이 간단하기 때문에 **디스크립터를 통해 소켓을 식별하여 사용한다.**

<br>

* * *

<br>

## Story2 서버의 수신동작

서버로부터의 패킷 수신 동작을 차례로 확인해 보자

1. Lan 어댑터 에서 수신 신호를 디지털 데이터로 변환한다.
    1. 패킷의 신호를 Lan 어댑터에서 수신하여 디지털 데이터로 변경한다.
    2. 변경 이후 패킷의 마지막 FCS를 통해 오류 유무를 검사한다.
        - 오류는 검사의 계산식에 따라 계산하고 FCS필드값과 비교하여 오류 유무를 판단
    3. 검사 이후 MAC주소를 조사하여 자신을 수신처로 보낸것인지 판단
    4. 이후 자신이 수신처일 경우 LAN어댑터의 내부의 버퍼 메모리에 저장한다.
    5. 저장 이후 인터럽트를 발생시켜 CPU에게 패킷 도착을 알린다.
    6. CPU는 LAN 드라이버로 실행을 전환하고 버퍼 메모리에서 수신 패킷을 추출한다
    7. 추출한 패킷의 MAC헤더의 타입 필드 값에 따라 프로토콜을 판별하고 프로토콜을 처리하는 소프트웨어를 호출하여 패킷을 건넨다.

<br>

1. IP 담당 부분이 패킷을 수신한다.
    1. 프로토콜 스택에 패킷이 전달되면 IP 담당 부분이 동작하여 IP 헤더를 검사한다.
    2. 수신처 IP가 자신인지 확인하고 패킷이 분할되었는지 확인한다 
        
        ⇒ 만약 패킷이 분할되어있다면 패킷 조각이 전부 도착할때까지 대기하고 전부 도착시 패킷을 복원하여 패킷을 검사한다.
        
    3. IP 담당 부분이 패킷 조사를 완료하면 다음 프로토콜을 조사하여 해당 담당 부분에 패킷을 건네준다.

<br>

2. TCP 담당 부분이 패킷을 수신한다.
    - 접속 단계의 패킷을 수신할 경우
        1. SYN =1 컨트롤 비트를 통해 접속을 접수하는 동작 실행전 수신처 포트번호를 조사하여 동일한 포트 번호가 할당된 소켓의 존재 여부를 확인
        2. 접속 대기 소켓을 복사하여 새 소켓을 만들고 상대측의 IP주소, 포트번호, 시퀀스 초기값 ,윈도우 값등의 필요 정보를 기록
        3. 송신 버퍼와 수신 버퍼로 사용하는 메모리 영역 확보
        4. 클라이언트에게 보내는 데이터에 관한 시퀀스 초기값, 수신 버퍼 용량, 윈도우 값 등을 기록한 TCP헤더를 작성하여 IP담당 부분에게 의뢰하여 클라이언트에게 반송한다.
        
    - 데이터 패킷을 수신할 경우
        1. 데이터 패킷이 도착한 경우 TC 담당 부분은 도착한 패킷이 어느 소켓에 해당되는지 확인
            - 송신처 IP주소, 수신처 IP주소 , 수신처 포트번호, 송신처 포트번호 4개의 정보를 통해 모드 합치되는 소켓을 확인
        2. 해당 소켓이 데이터를 잘 받고 있는지 즉 소켓을 통한 데이터 수신에 오류가 있는지 확인한다.
        3. 오류가 없을 시 수신 버퍼에 데이터를 저장하고 수신 확인 응답용 TCP 헤더를 만든다.
        4. 응답용 TCP 헤더를 구성한 후 IP 담당 부분에게 송신을 의뢰한다.
        
<br>

3. TCP 담당 부분의 연결 끊기
    1. TCP 프로토콜 규칙에 따르면 연결 끊기 동작은 클라와 서버중 어느 쪽이 먼저 실행해도 상관 없다.
    2. HTTP1.0 의 경우 서버에서 연결 끊기 동작을 시작한다.
    3. 이 경우 서버측에서 close를 호출하면 FIN = 1 컨트롤 비트를 설정하여 IP 담당 부분에게 의뢰한다.
        
        ⇒ 이후 클라이언트가 FIN=1로 한 헤더를 서버에게 보낸후 서버가 ACK 번호를 반송하면 연결 끊기 동작은 마무리 된다.
        
    4. 연결 끊기 동작이 끝나면 네트워크상 패킷이 소멸될 수 있는 시간을 기다린 후 소켓을 말소한다.

<br>

* * *

<br>

## 번외) HTTP

- HTTP
  
    <details>
    <summary>Http</summary>
    - HTTP
    
    ## HTTP
    
    HyperText Transfer Protocol
    
    ⇒ 문서간에  링크를 통해 연결할 수 있는 하이퍼텍스트 문서를 통해
    
    연결할 수 있는 HTML을 전송하는 프로토콜 ⇒ http의 시작
    
    <br>
    
    * * *

    <br>

    ## 모든것이 HTTP
    
    지금은 모든것을 HTTP 메세지에 담아 전송한다!
    
    - HTML, TEXT
    - IMAGE, 음성, 영상, 파일
    - JSON, XML(API) ⇒ 보통 서버끼리 통신시 사용
    - 거의 모든 형태의 데이터 전송 가능
    - 서버간 데이터를 주고 받을 때도 대부분 HTTP 사용
    - 지금은 HTTP 시대!
        
        ⇒ TCP를 직접 연결해 통신하는 경우는 게임서버 등이 있음.
        
    
    <br>
    
    * * *

    <br>

    ## HTTP 역사
    
    <img width="467" alt="스크린샷 2022-04-15 오후 6 35 07" src="https://user-images.githubusercontent.com/81874493/163554825-4433d49e-49e2-4ef4-8230-a682bf8a1da9.png">  

    ⇒ HTTP/1.1에 대부분의 기능이 들어있고 이후 버전은 성능개선에 초점
    
    ⇒ HTTP/1.1 에 대해서 공부하는 것이 중요
    
    <br>
    
    * * *

    <br>
    
    ## 기반 프로토콜
    
    - HTTP/1.1, HTTP/2 ⇒ TCP 기반으로  개발 되어있음
    - HTTP/3 ⇒ UDP 기반으로 개발 되어있음
    
    ⇒ 현재 HTTP/1.1 주로 사용
    
    <img width="673" alt="스크린샷 2022-04-15 오후 6 29 51" src="https://user-images.githubusercontent.com/81874493/163554849-af6ec66c-c939-46f1-be97-b9d9c5a54b8d.png">

    ⇒ 2, 3 도 많이사용
    
    ⇒ 결국은 HTTP/1.1 스펙을 잘 알면 된다.
    

    <br>
    
    * * *

    <br>

    ## HTTP 특징
    
    - 클라이언트 서버 구조로 동작
    - 무상태 프로토콜(Stateless) 지향, 비연결성
    - HTTP 메세지를 통해 통신
    - 단순함, 확장 가능
    
    ⇒ **각각 자세히 알아보자!!**
    
    <br>
    
    * * *

    <br>
    
    ## 클라이언트 서버 구조
    
    <img width="451" alt="스크린샷 2022-04-15 오후 6 29 57" src="https://user-images.githubusercontent.com/81874493/163554880-aef945f1-43a1-4b3e-b107-2c496dd02439.png">

    1. 클라이언트가 HTTP메세지를 통해 서버에 요청
    2. 클라이언트는 서버에서 응답이 올때까지 무작정 기다림
    3. 서버에서 응답 결과가 오면 그때 응답을 열어서 동작하게 됨
    
    <br>

    **여기서 중요한 점**
    
    1. 개념적으로 서버와 클라이언트를 분리한다.
    2. 비지니스 로직과 데이터들을 모두 서버에 집중시켜 밀어넣음
    3. 클라이언트는 UI와 사용성등에 집중시킴
    
    ⇒ 이렇게 되면
    
    - 클라이언트와 서버가 각각 독립적으로 진화가 가능
    
    <br>

    **정리)**
    
    - HTTP에서는 서버와 클라이언트 구조로 되어있음
    - 클라이언트는 요청을 보냄(서버가 응답이 올때까지 무작정 기다림)
    - 서버는 응답을 보냄
    - 클라는 응답이 오면 응답에 대한 동작을 실행
    
    <br>
    
    * * *

    <br>


    ## 무상태 프로토콜 (Stateless)
    
    HTTP는 무상태 프로토콜을 지향한다.
    
    - 서버가 클라이언트의 상태를 보존하지 않는다
        
        ⇒ 이게 뭐지 ???
        
        ⇒ 예제
        
        <**Stateful 상태 유지**>
        
        <img width="425" alt="스크린샷 2022-04-15 오후 6 30 09" src="https://user-images.githubusercontent.com/81874493/163554917-2374e050-ac49-48c9-8e1e-cd88bb0e591e.png">

        ⇒ Stateful ⇒ 서버가 클라이언트의 이전 상태를 보존
        
        (예시에서는 문맥(Context)을 보존한다)
        
        <br>

        <**stateless 무상태**>
        
        (점원이 중간에 바뀜)
        
        <img width="346" alt="스크린샷 2022-04-15 오후 6 30 14" src="https://user-images.githubusercontent.com/81874493/163554930-547aa2ce-ab0b-4844-a338-2279b422bcb0.png">

        ⇒Stateless ⇒ 서버가 클라이언트의 이전 상태를 보존하지 않음
        
        (예시에서는 문맥을 보존하지 않는다)
        
        음 **상태를 유지하는것과 유지하지 않는것**을 stateful, stateless 라고 하는구나 ... 아직 확 와닿지 않는다...
        
        **다시 확인해보자**
        
        <br>

        <**Stateful 상태 유지**>
        
        <img width="390" alt="스크린샷 2022-04-15 오후 6 30 19" src="https://user-images.githubusercontent.com/81874493/163554955-1afe2a64-87aa-4a03-a32f-f35ee509012e.png">

        1. 점원은 노트북이라는 문맥 상태를 유지
        2. 점원은 노트북, 2개 구매라는 상태 유지
        3. 점원은 노트북, 2개 구매, 신용카드 결재 상태를 유지
        
        <br>

        <**stateless 무상태**>
        
        <img width="587" alt="스크린샷 2022-04-15 오후 6 30 24" src="https://user-images.githubusercontent.com/81874493/163554967-89a37981-bf19-48d8-a159-5856171005f3.png">

        ⇒ 문맥 상태를 유지하지 않기때문에 이러한 대화를 해야된다.
        
        **여기서 중요한점 !!!** 
        
        **무상태 에서 점원이 중간에 변경되면???!?!?**
        
        <img width="484" alt="스크린샷 2022-04-15 오후 6 30 28" src="https://user-images.githubusercontent.com/81874493/163554984-ecf7aec9-1038-4387-860e-57dd1fde2d0e.png">

    <br>

    결론)
    
    <서비스 개발 입장관점에서>
    
    상태유지 stateful 에서 **중간에 점원이 바뀌면 장애/오류가 발생**
    
    ( 다른 점원으로 바뀌면 문맥상태가 사라짐)
    
    무상태 stateless 에서 **중간에 점원이 바뀌어도 정상 작동**
    
    ( 다른 점원으로 바뀌어도 그때그때 점원이 필요하는 정보를 넘김)
    
    (그래서 중간에 점원이 바뀌어도 정상 작동 됨)
    
    <br>

    **Stateful, Stateless 차이 정리**
    
    - 상태 유지 : 중간에 다른 점원으로 변경되면 안된다
        
        ⇒ 중간 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려주어야 한다.
        
    - 무상태 : 중간에 다른 점원으로 바뀌어도 된다
        
        ⇒ 갑자기 고객이 증가해도 점원을 대거 투입 가능
        
        ⇒ 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입 가능
        
        ⇒ **무상태는 응답 서버를 쉽게 바꿀 수 있다. → 무한한 서버 증설 가능**
        
    <br>

    **#상태 유지**
    
    <img width="664" alt="스크린샷 2022-04-15 오후 6 30 45" src="https://user-images.githubusercontent.com/81874493/163555022-aa62f5a9-fb1a-47e3-b07f-8198736e9d0c.png">

    ⇒ 따로 상태 유지된 정보가 사라져 결제를 처음부터 다시 시작해야함
    
    <br>

    **#무상태** 
    
    <img width="689" alt="스크린샷 2022-04-15 오후 6 30 55" src="https://user-images.githubusercontent.com/81874493/163555041-7fd4378b-6d52-453e-b586-dde59b0cb8a9.png">

    ⇒ 장애시에도 다른 서버로 대체 가능 왜? 무상태이기 때문
    
    <img width="683" alt="스크린샷 2022-04-15 오후 6 31 01" src="https://user-images.githubusercontent.com/81874493/163555079-737b08d8-8ec8-4ea6-82d2-7c11f7adcc27.png">

    ⇒ 무상태 설계시 수평확장에 유리하게 작용할 수 있다.
    
    <br>

    **마지막 stateless의 한계**
    
    <img width="416" alt="스크린샷 2022-04-15 오후 6 31 05" src="https://user-images.githubusercontent.com/81874493/163555104-c5cd3a92-da0a-4927-93cb-dabeb0c0eda8.png">

    ⇒ **웹 애플리케이션을 설계할 때에는 최대한 무상태로 설계한다**
    
    ⇒ **상태 유지는 어쩔 수 없는 경우(로그인)만 최소한으로 사용한다.**
    

    <br>
    
    * * *

    <br>

    ## 비 연결성(Connectionless)
    
    **연결을 유지하는 모델** 
    
    ex) TCP /IP 연결 하는 경우
    
    #1
    
    <img width="519" alt="스크린샷 2022-04-15 오후 6 31 16" src="https://user-images.githubusercontent.com/81874493/163555144-24b516e0-1b6e-4a2d-98fc-0aac166227fa.png">

    #2
    
    <img width="486" alt="스크린샷 2022-04-15 오후 6 31 18" src="https://user-images.githubusercontent.com/81874493/163555161-6ecd3b49-dee7-49f0-a5e5-7c73479d936a.png">

    #3
    
    <img width="667" alt="스크린샷 2022-04-15 오후 6 31 22" src="https://user-images.githubusercontent.com/81874493/163555188-c495d3f9-f4c7-46a2-8cff-47e0b8a01b8f.png">

    ⇒위 그림과 같이  클라이언트는 서버와 연결이 유지되어 있음
    
    ⇒ 연결을 유지하는 서버의 자원은 계속 소모 되고 있다.
    
    <br>

    단점)
    
    - 요청/응답 이 없어도 연결을 유지를 해야한다.
        
        ⇒ 즉 무언가 실제 동작이 없어도 연결을 유지해야하는 비용이 든다.
        
    
    **연결을 유지하지 않는 모델**
    
    #1
    
    <img width="484" alt="스크린샷 2022-04-15 오후 6 31 28" src="https://user-images.githubusercontent.com/81874493/163555216-a1eb94de-387b-440d-93bf-d05f33ef59c3.png">

    <br>

    #2
    
    <img width="475" alt="스크린샷 2022-04-15 오후 6 31 31" src="https://user-images.githubusercontent.com/81874493/163555223-8f8eed69-4f10-4dc7-b0d0-8f86707588e4.png">

    ⇒ 위 그림은 요청이 올때 연결하고 응답이 완료되면 연결을 끊는다.
    
    장점)
    
    - 서버 연결 유지하지 않음
    - 최소한의 연결 자원 유지
    
    ⇒ 서버가 동시에 유지해야 하는 자원을
    
    ⇒ 요청시에만 연결하고 응답 보내고 끊어 버리기 때문에
    
    ⇒ 최소한의 자원으로 서버 유지가 가능
    
    <br>

    **비 연결성**
    
    - HTTP는 기본이 연결을 유지하지 않는 모델
    - 일반적 초단위 이하의 빠른 속도로 응답
    - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서는 동시 처리하는 요청은 수십개 이하로 매우 작다
        
        ⇒ 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않는다.
        
    - 서버 자원을 매우 효율적으로 사용할 수 있다.
    
    <br>

    **비 연결성의 한계와 극복**
    
    - TCP/IP 연결을 새로 맺어야 한다 - 3 way handshake 시간 추가
    - 웹 브라우저로 사이트를 요청시 html 뿐 아니라 js,css,추가 이미지 등 수많은 자원이 함께 다운로드 된다.
    
    - 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
    - HTTP/2, HTTP/3 에서 더많은 최적화가 되어있다.
    
    <br>

    **<초기>**
    
    <img width="485" alt="스크린샷 2022-04-15 오후 6 31 37" src="https://user-images.githubusercontent.com/81874493/163555249-dec45265-4f3f-4ba7-9519-e16ee0031343.png">

    <br>

    **<지속 연결 사용>**
    
    <img width="519" alt="스크린샷 2022-04-15 오후 6 31 43" src="https://user-images.githubusercontent.com/81874493/163555259-2a090e59-3dcd-47aa-9a39-983f34a3e064.png">

    ⇒ 내부 매커니즘에 따라 웬만한 HTML 페이지 하나를 다 받을 때까지는 지속연결을 유지 후 종료
    
    <br>

    참고)
    
    <img width="464" alt="스크린샷 2022-04-15 오후 6 31 47" src="https://user-images.githubusercontent.com/81874493/163555325-b0fcbe7c-f406-4c5a-a822-af7c52f24f2b.png">

    ⇒ 수만면이 동시 접속시 대용량 트패픽
    
    ⇒ 이런경우 비연결성 소용이 없다.
    
    ⇒ 그래서 이렇게 동시에 몰려오는 경우는 !!
    
    ⇒ **최대한 어떻게든 STATELESS 하게 설계하는 것이 중요**
    
    ⇒ 동시 접근을 수를 줄이기, 동시 접근시 커버 가능 서버 구축 등 해결책
    

    <br>
    
    * * *

    <br>

    ## HTTP 메세지
    
    <HTTP 요청 메세지 구조>
    
    <img width="263" alt="스크린샷 2022-04-15 오후 6 31 53" src="https://user-images.githubusercontent.com/81874493/163555348-defbda02-17d7-452a-ae8b-800064311cfd.png">

    <br>

    <HTTP 응답 메세지 구조>
    
    <img width="274" alt="스크린샷 2022-04-15 오후 6 31 56" src="https://user-images.githubusercontent.com/81874493/163555364-893ced82-ff24-496a-aea2-167243cc71bc.png">

    ⇒ 구조가 약간 다르다 
    
    ⇒ 형식적 구조를 확인해 보자
    
    <img width="518" alt="스크린샷 2022-04-15 오후 6 32 02" src="https://user-images.githubusercontent.com/81874493/163555388-c3c48a7d-771d-4b39-b1d6-1b9e0d60d361.png">

    <img width="702" alt="스크린샷 2022-04-15 오후 6 32 08" src="https://user-images.githubusercontent.com/81874493/163555407-6b97d913-bc2f-4d79-b085-6c44d852ba8a.png">

    <br>

    <요청>
    
    <img width="694" alt="스크린샷 2022-04-15 오후 6 32 15" src="https://user-images.githubusercontent.com/81874493/163555425-474c3f5d-50c6-406a-b2f9-a394b6855e4f.png">

    <br>

    <응답>
    
    <img width="665" alt="스크린샷 2022-04-15 오후 6 32 19" src="https://user-images.githubusercontent.com/81874493/163555438-7c56b897-5afe-49f8-9c9c-33648c433c6f.png">

    **이제 세세히 하나씩 확인해 보자**
    
    <br>

    - 요청 메세지
        
        
        <img width="511" alt="스크린샷 2022-04-15 오후 6 32 24" src="https://user-images.githubusercontent.com/81874493/163555633-bd5e171e-e1da-4af9-bd3a-b81baf7e85a8.png">

        <br>

        - **시작 라인(START-LINE)**
            
            **종류** : **(request-line(요청) / status-line(응답))**
            
            형식) 
            
            **request-line =**
            
            **method SP(공백) request-target SP HTTP-version CRLF(엔터)**
            
            ⇒ 형식 : **메소드** (공백) **요청 대상** (/공백) **HTTP버전** (엔터)
            
            ⇒ 예) GET /search?q=hello&hl=ko HTTP/1.1
            
            ⇒ 메소드 : GET
            
            ⇒요청 대상 : /search?q=hello&hl=ko
            
            ⇒ HTTP 버전 : HTTP/1.1
            
            <br>

            - HTTP 메소드
                
                -종류 : GET,POST,PUT,DELETE ... etc
                
                -서버가 수행해야할 동작을 지정
                
                -get : 서버에게 자신이 요청한 리소스를 내놔라
                
                -post : 서버에게 자신이 보낸 리소스를 처리해라
                
                -delete : 서버에게 자신이 보낸 리소스 삭제해라
                
                <br>

            - 요청 대상
                
                -absolute-path[?query](절대경로[?쿼리]) 형식
                
                -절대경로 = "/" 로 시작하는 경로
                

                <br>

            - HTTP 버전
                
                -HTTP 버전 작성
                
            <br>

        - 응답 메세지
        
        <img width="513" alt="스크린샷 2022-04-15 오후 6 32 31" src="https://user-images.githubusercontent.com/81874493/163555666-4686cabe-b107-49af-b243-1232cc8f9df4.png">

        <br>

        - **시작 라인(START-LINE)**
        
        **종류** :  **(request-line(요청) / status-line(응답))**
        
        형식)
        
        **status-line =**
        
        **HTTP-version** SP **status-code** SP **reason-phrase** CRLF
        
        ⇒ 형식 : **http버전** (공백) **상태 코드** (공백) **이유 구문** (엔터)
        
        예) HTTP /1.1 200 OK
        
        ⇒ http버전 : 1.1
        
        ⇒ 상태 코드 : 200
        
        ⇒ 이유 구문 : ok
        
        <br>

        - HTTP버전
            
            -HTTP 버전 작성
            
            <br>

        - 상태 코드
            - 요청 성공, 실패를 나타냄
            - 200 : 성공
            - 400 : 클라이언트 요청 오류
            - 500 : 서버 내부 오류

            <br>

        - 이유 구문
            
            -사람이 이해할 수 있는 짧은 상태 코드 설명 글
            
    
    ===========================================
    
    <br>

    **이제 요청 응답 공통 부분**
    
    - **HEADER 헤더**
        
        header-field =
        
        field-name ":" OWS field-value OWS (OWS : 띄어쓰기 허용)
        
        <img width="657" alt="스크린샷 2022-04-15 오후 6 32 38" src="https://user-images.githubusercontent.com/81874493/163555696-0fc69e0f-cfe6-4e1a-ab6a-fb31159f4373.png">

        ⇒Host,Content-Type등 이부분은 대소문자 구분 안함
        
        ⇒ value값 즉 [www.google.com](http://www.google.com) 이부분은 대소문자 구분함
        
        <img width="656" alt="스크린샷 2022-04-15 오후 6 32 44" src="https://user-images.githubusercontent.com/81874493/163555720-a6cb9686-779e-446a-99cb-ee9d1dd845b6.png">

        ⇒ 즉 **헤더에는 메세지 body 부분 빼고 필요한 모든 메타데이터 정보가 다 들어있는 곳**
        
    
    ==============================================
    
    - **HTTP 메세지 바디**
        
        <img width="651" alt="스크린샷 2022-04-15 오후 6 32 49" src="https://user-images.githubusercontent.com/81874493/163555734-3cfcc745-4657-4856-902d-2a6130d304ca.png">

    
    =============================================
    
    **HTTP 메세지 결론)**
    
    - HTTP 단순 , 스펙도 읽어볼만
    - HTTP 메세지도 매우 단순
    - 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술이다.
    
    <br>
    
    * * *

    <br>

    ## HTTP 정리
    
    - HTTP메세지에 모든 것을 전송 가능
    - HTTP 역사 HTTP/1.1 기준으로 학습
    - 클라이언트 서버 구조
    - 무상태 프로토콜(Stateless)
    - HTTP 메세지
    - 단순함, 확장 가능
    - 지금은 HTTP 시대
    </details>
