# 목차

## Story 01. 소켓을 작성한다.

## Story 02. 서버에 접속한다.

<br>

* * *

<br>

# story 01. 소켓을 작성한다.

<br>

이전 Chapter1 에서는

> 데이터 전송을 위해 **프로토콜 스택에게 4단계의 의뢰 동작을 어플리케이션 단에서의 설명** 이였다면

> 이번에는 **OS 내부의 프로토콜 스택 단에서의 4단계 의뢰에 대한 동작**들을 차례로 확인해 보자

<br>

## 프로토콜 스택

우선 프로토콜 스택에 대해 알아보자

<br>

### 01) 프로토콜 스택이란?

정의 : OS의 내장된 네트워크 제어용 소프트웨어이다.

<br>

### 02) 전체적인 구성

<img width="528" alt="스크린샷 2022-02-21 오후 7 51 40" src="https://user-images.githubusercontent.com/81874493/154941071-c414907e-d560-47e1-b546-92945f6fffc3.png">

- 네트워크 애플리케이션
    - 일반적 네트워크를 통해 데이터의 송 수신이 이루어지는 애플리케이션을 의미한다.
        - ex) 웹 브라우저,웹 서버, 메일 서버 .... etc
        
        <br>

    - Socket 라이브러리
        - 네트워크를 통해 데이터 송 수신을 위해 Socket 라이브러리를 통해 프로토콜 스택에게 데이터 송신을 의뢰하기 위한 네트워크 프로그램 부품의 모음집
            - Socket 라이브러리 내부의 리졸버가 존재한다.
                
                ⇒ DNS 서버에게 도메인에 매칭되는 IP 주소를 받기위해 DNS 서버 조회 메시지를 작성하여 프로토콜 스택에 송신을 의뢰하는 부품
                
                <br>

- 프로토콜 스택
    - 정의 :OS 내부의 네트워크 제어용 소프트웨어
    
    <br>

    - 구성
        - TCP ( 커넥션 사용 - 3way handshake를 통해 커넥션을 구성 ) 프로토콜을 사용하여 데이터 송수신 동작 제어 담당 부분
            
            ⇒ 브라우저나 메일 등 일반적 애플리케이션은 TCP 프로토콜을 사용하여 데이터 송수신
            
            <br>

        - UDP (커넥션 사용하지 않음 ) 프로토콜을 사용하여 데이터 송 수신 제어 담당 부분
            
            ⇒ DNS 서버 조회와 같이  짧은 제어용 데이터 송수신할 경우 UDP 프로토콜 사용
            
            <br>

        - IP 프로토콜을 사용하여 데이터 송수신 제어 담당 부분
            
            ⇒ 인터넷에서 데이터 운반시 데이터를 작게 나누어 패킷 이라는 형태로 운반
            
            ⇒ 이때 패킷을 통신 상대까지 운반하는 것이 IP 프로토콜의  주 역할
            
            <br>

            - 내부적 사용되는 프로토콜
                - ICMP : 패킷 운반시 발생하는 오류 통지나 제어용 메시지 통지시 사용 프로토콜
                - ARP : IP와 상응하는 MAC 주소를 조사할때 사용하는 프로토콜
                
                <br>

- LAN 드라이버
    
    하드웨어인 LAN 어댑터를 제어하는 소프트웨어
    
    <br>

- LAN 어댑터
    
    데이터의 실제 송 수신 동작, 즉 케이블에 대해 신호를 송 수신하는 동작을 실행하는 하드웨어.
    

<br>

<br>

## Socket

<br>

### 01) Socket의 실체

프로토콜 스택 내부에서 데이터 통신에 있어 제어 정보를 기록하는 메모리 영역을 따로 가지고 있다.

⇒ 여기 메모리 영역에 통신 동작 제어하기 위한 제어 정보를 기록한다.

- 제어정보
    - 통신 상대의 IP주소
    - 포트 번호
    - 어떤 통신 동작이 진행 상태인지
    - ... etc

<br>

결론) 

프로토콜 스택이 사용하기 위해 메모리에 기록한 통신 제어 정보

⇒ 이것이 소켓의 실체라고 할 수 있다. ( 소켓은 실체가 있는 것이 아니라 추상적인 개념 )

⇒ 혹은 통신 제어 정보가 저장된 영역을 소켓의 실체라고 봐도 무관하다.

<br>
<br>

### 02) 프로토콜 스택은 소켓의 통신 제어 정보를 참조 하며 동작한다.

<br>

ex)

- 데이토 송신시 소켓에 기록된 상대측 IP 주소와 포트 주소를 보고 데이터 송신
- 송신 중 데이터 유실시 응답이 돌아오지 않을 때 소켓에 기록된 송신 동작 후 경과 시간등을 사용하여 재송신
- .... 등

⇒ 소켓에는 통신 동작을 제어하기 위한 여러 제어 정보가 기록되어 있다.

프로토콜 스택의 위와 같은 소켓의 기록된 정보를 참조하여 다음에 무엇을 해야하는 지 판단하는데

⇒ 이것이 소켓의 역할이다.

<br>
<br>

### 03) ‘소켓을 생성한다?’ 의 의미

<br>

<img width="674" alt="스크린샷 2022-02-21 오후 7 51 50" src="https://user-images.githubusercontent.com/81874493/154941105-ec8a0088-19ec-4465-b5e8-863745967a8c.png">

`netstat`  :  소켓의 내용을 화면에 표시하는 명령어

⇒ 위의 그림에서 한 행이 하나의 소켓에 해당한다.

<br>

- 소켓을 만든다는 동작은
    - 여기에 새로 한행의 제어 정보를 추가하고
    - 통신 상태를 기록하고
    - 송 수신 데이터를 일시적으로 저장하는 버퍼 메모리를 준비하는 등
        
        ⇒ 통신할 준비하는 작업을 의미한다.
        

<br>
<br>

## 소켓 생성 단계에서 프로토콜 스택의 동작

브라우저나 애플리케이션에서 Socket 라이브러리를 통해 ‘Socket’ 을 호출했을때

⇒ 프로토콜 스택에서 어떻게 동작하는지 확인해 보자.

<br>

<img width="571" alt="스크린샷 2022-02-21 오후 7 51 58" src="https://user-images.githubusercontent.com/81874493/154941136-213cec79-3f0b-4d73-b696-a24f4fae21af.png">

브라우저나 어플리케이션이 Socket 라이브러리의 Socket 을 호출하였을 때,

1. 프로토콜 스택은 의뢰에 따라 한개의 소켓을 생성한다.
    1. 이때 소켓 한 개 분량의 메모리 영역을 확보한다.
    2. 송수신 시작 전 초기 상태임을 나타내는 제어 정보를 메모리 영역에 기록한다.
        
        ⇒ 위 과정을 통해 한개의 소켓이 생성된다.
        
2. 소켓이 생성되면 소켓을 나타내는 디스크립터를 브라우저 혹은 디스크립터에게 알려준다.
    - 디스크립터는 프로토콜 스택 내부의 다수 소켓 중 어느 것을 가리키는지를 나타내는 번호표 역할
    - 애플리케이션은 이후 프로토콜 스택에 데이터 송수신 의뢰시 디스크립터를 통지한다.

<br>

* * *

<br>

# Story 02. 서버에 접속한다.

<br>

## 접속 단계에서 프로토콜 스택의 동작

<br>

### 01) 접속의 의미

1. 통신할 서버의 IP주소 , 포트 번호 등을 프로토콜 스택에 알리는 동작
    - 소켓 만든 직후 아무것도 기록되어 있지 않아 통신 상대가 누구인지 모른다.
    - 즉 소켓을 만드는 과정 만으로는 프로토콜 스택 에는 아무것도 전달되지 않기 때문에 알리는 과정이 필요
    
    <br>

2. 데이터 송수신 동작시 송 수신하는 데이터를 일시적으로 저장하는 메모리 영역 (=메모리 버퍼) 확보
    - 데이터 송수신 하기 위해 데이터를 일시적으로 저장하는 영역 또한 접속 단계에서 확보해야한다.
    
    <br>

3. 통신할 상대측과 데이터 송수신 가능 상태 만들기
    - 클라이언트 측에서 자신의 IP와 포트 번호를 알려 데이터 송수신 동작을 하겠다고 알려야한다.
        - 이때 통신 상대와의 사이 IP 주소와 포트 번호와 같은 **제어 정보**를 주고 받아
            
             ⇒ **소켓에 필요한 정보를 기록**하고 송 수신이 가능한 상태로 만들게 된다.
            
        <br>

        - 접속 동작에서 주고받는 제어 정보는 통신 규칙에 따라 정보가 전달되고 송수신 가능 상태가 된다.
            
            ⇒ 이때 상호간 제어정보를 전달하고 송수신 가능 상태를 만들때 헤더를 사용한다.
            
    <br>

### 02) 제어 정보

제어정보는 크게 두가지로 나눌 수 있다.

- 클라이언트와 서버가 서로 연락을 절충 하기 위해 주고받는 제어 정보
    - 접속, 데이터 송수신, 연결 종료 동작 포함 통신 동작 전체에서 사용하는 제어 정보
        
        ⇒ 헤더에 기록된 제어 정보에 의해 통신 상호간 동작이 이루어진다.
        
        접속 단계)
        
        - 접속 단계에서는 데이터 송수신이 일어나지 않기 때문에 서로 상호 연결하기 위해 필요한 정보들을 패킷의 맨 앞부분인 헤더에 작성하여 상호간 필요 동작을 진행한다.
        
        <br>

- 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 제어정보
    - 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보등이 수시로 소켓에 기록된다.
        
        ex) 상대측 IP 주소, 상대측 포트 번호,  송 수신 동작의 진행 상황 등..
        
        ⇒ 프로토콜 스택은 소켓에 정보를 참조하며 동작하게 된다.
        
<br>
<br>

### 03) 접속 단계에서 프로토콜 스택의 동작

브라우저 혹은 애플리케이션이 

`connect(<디스크립터>, <서버측 IP 주소와 포트 번호>);`

⇒ connect를 호출하였을 경우 프로토콜 스택 동작 순서를 살펴보자

( 이 부분은 클라이언트 → 서버 → 클라이언트  순으로 진행되는 과정을 순서대로 작성됨)

<br>

**<클라이언트 측>**

1. `connect (디스크립터 , 서버측 IP 주소와 포트 번호)` 호출
2. 소켓 디스크립터와 서버측 IP 주소와 포트 번호 등의 제어 정보가 프로토콜 스택으로 전달된다.
3. TCP 프로토콜 담당 부분은 전달된 정보를 바탕으로 접속을 나타내는 TCP 헤더를 만든다.
    1. 송신처 , 수신처 포트 번호 작성
    2. SYN 컨트롤 비트를 1로 만든다  ( 연결 설정에 사용하는 컨트롤 비트 )
4. 작성한 TCP 헤더를 IP 담당 부분에 건네어 송신하도록 의뢰
5. IP 담당 부분은 IP 계층의 제어 정보 헤더를 만들고 LAN 을 통해 서버로 패킷을 전송

<br>

**<서버측>**

1. 클라이언트로 부터 패킷이 서버에 도착
2. 서버측의 IP 담당 부분이 패킷을 받고 IP계층 헤더를 해석 한 후 TCP 담당으로 패킷을 넘김
3. 서버측 TCP 담당 부분이 패킷의 헤더를 해석한다.
    1. 수신처의 포트 번호를 통해 수신처의 소켓을 찾는다.
    2. 서버측 소켓에 수신처 소켓, 수신처 IP, 수신처 포트 등 정보 서버측 소켓에 기록

=====================================( 여기까지 진행시 접속 진행 중 상태가 된다.)

<br>

1. 이후 서버측은 응답 패킷을 생성한다.
    1. 송신처와 수신처 포트번호 작성
    2. SYN 컨트롤 비트를 1로 만든다 ( 1 일 경우 접속 동작이 성공을 의미 )
    3. ACK 컨트롤 비트를 1로 만든다 ( 1일 경우 클라이언트 측 전송 했던 패킷이 잘 도착했다는 것을 의미 )
2. 응답 패킷을  IP 담당 부분을 경유하여 클라이언트에게 반송

<br>

**<클라이언트 측>**

1. 서버로 부터 패킷이 클라이언트에게 도착
2. IP 담당 부분을 경유하여 TCP 담당 부분으로 패킷을 전달 받음
3. TCP 헤더를 해석한다.
    1. ACK 이 1 이면 이전에 전송 했던 패킷이 잘 도착했다는 의미
    2. SYN 이 1 이면 접속 성공
        
        ⇒ 접속 성공시 소켓에 서버 IP 주소 포트 번호 등과 함꼐 소켓에 접속 완료 나타내는 제어 정보 기록
        
4. 이후 클라이언트 측도 응답 패킷을 생성
    1. 송신처와 수신처 포트번호 작성
    2. SYN 컨트롤 비트를 1로 만든다 ( 1 일 경우 접속 동작이 성공을 의미 )
    3. ACK 컨트롤 비트를 1로 만든다 ( 1일 경우 서버측이 전송 했던 패킷이 잘 도착했다는 것을 의미 )
5. 응답 패킷을  IP 담당 부분을 경유하여 서버 측에게 반송
    
    ⇒ 이 응답 패킷이 서버측에 잘 도착하면 접속 동작의 대화가 완료된다.
    
<br>
<br>

**결론)**

이 과정을 완료하면,

- 소켓은 데이터를 송 수신할 수 있는 상태가 된다.
    
    ⇒ 실제 연결되어 있지 않지만, 파이프와 같은것이 연결되었따고 생각하는게 편하다.
    
    ⇒ 이때 파이프와 같은 것을 커넥션이라고 하며 close를 호출하여 연결을 끊을 때 까지 계속 유지된다.

    <br>    

- 여기까지 과정으로 커넥션이 이루어지면 프로토콜 스택의 접속 동작이 끝나 connect 실행이 완료되어 제어권은 다시 어플리케이션으로 돌아간다.
