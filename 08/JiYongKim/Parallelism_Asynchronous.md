
# 목차

## 1. Multi

## 2. Process & Thread

## 3. 동시성 병렬성 & 블로킹 논블로킹

## 4. 경합 조건

## 5. 공유 자원

## 6. 임계 영역 

## 7. 프로세스 동기화

## 8. JS

<br>

* * *

<br>


## Multi

**Multi Tasking**

- 멀티 태스킹은 다수의 작업(Task)을 운영체제의 스케줄링에 의해 CPU와 같은 공용 자원을 나누어 사용하여 작업을 처리하는 것을 의미한다.
    
    >⇒ 즉 요점은 여러 작업을 동시에 수행되는것 처럼 보이는 것
    
    - 멀티 태스킹 수행 방식
        - 멀티 프로그래밍
        - 멀티 시스템
        - 실시간 시스템
            
            >⇒ 위와 같은 방식으로 멀티태스킹을 수행한다.
            
            <br>

- 멀티태스킹의 종류
    
    운영체제의 스케줄링에 의해 프로세스 혹은 스레드가 선택되어 실행되게 되는데 CPU라는 한정적인 자원을 사용하고자 서로 경쟁 관계가 된다.
    
    이때,
    - 현재 CPU를 차지하고 있는 프로세스 혹은 스레드가 CPU 연산이 필요없을 때 운영체제가 CPU를 회수하는 할 수 있는 방식을 --> **“비선점형 멀티태스킹”**
    - 반면 스레드나 프로세스가 CPU를 차지하고 있더라도 운영체제의 트리거나 타이머를 통해  강제로 CPU를 회수할 수 있는 방식이 --> **“ 선점형 멀티 태스킹”**
    
    <br>

**Multi Processing & Multi Core Processor**

- Multi Processing이란?
    
    멀티 프로세싱은 다수의 프로세서가 협력적 일하는 것을 의미한다.
    
    >⇒ 즉 다수의 프로세서가 협력적으로 처리하는 것
    
    ( 중점은 처리 방식 )
    
    <br>
    
- Multi Core processor이란?
    
    코어 라고하는 처리장치를 두개 이상 포함시킨 칩을 가진 프로세서
    
    >⇒ 즉 회로를 의미

<br>    

<img width="707" alt="스크린샷 2022-02-09 오후 3 45 52" src="https://user-images.githubusercontent.com/81874493/153136785-442a50f7-1294-4240-ae19-b966b2125c6a.png">

좌측)

멀티 코어 프로세서가 멀티 프로세싱 방식으로 작업을 처리

<br>

우측)

멀티 코어 프로세서가 독립적인 방식으로 작업을 처리

<br>

* * *

<br>

## 프로세스 & 스레드

**프로세스**

- 정의 : 프로세스는 운영체제로부터 자원을 할당받아 프로그램이 실제로 메모리에 적재 되어(loaded) 실행되고 있는 인스턴스(instance)를 말한다

- 특징
    - 운영체제의 스케줄러에 의해 선택되고 실행된다.
    - 프로세스는 각각 독립된 메모리 영역(코드, 데이터, 스택, 힙의 구조)과 주소 공간을 운영체제로부터 할당 받는다
    - 프로세스는 각각 독립된 영역이기에 다른 프로세스의 변수나 자료구조에 접근할 수 없다
        - 만약 다른 프로세스의 자원에 접근하고 싶다면
            - 파이프(pipe)
            - 시그널(signal)
            - 소켓(socket)
            - RPC(remote procedure call)
                
                >⇒ 등 과 같은 **프로세스 간 통신**(IPC : Inter-Process Communication)*을 사용해야 한다.

<br>

**스레드**

- 정의 : **스레드**는 프로세스가 할당받은 자원을 이용하여, 프로세스 내 다른 코드와 독립적으로 실행될 수 있는  일련의 실행 흐름.

- 특징
    - 프로세스는 최소 한개 이상의 스레드를 가지며 이 스레드를 메인스레드 라고 한다.
    - 프로세스의 메모리 주소 공간 중 **코드, 데이터, 힙은 스레드 간 공유**되며,
        
        **스택 만 스레드 별로 할당**된다. 
        
        >⇒ 그래서 스레드 간에는 이 공유 메모리를 이용해 상호작용을 할 수 있다.
        
        <br>

        <img width="436" alt="스크린샷 2022-02-09 오후 3 46 00" src="https://user-images.githubusercontent.com/81874493/153136809-7438cd73-c177-46b1-87bf-94e3bbda667a.png">

        (참고로  Thread 는 스택뿐 아니라 PC(Program Counter) 또한 각자 할당받는다)
        

<br>

- 스레드의 분류 
    
    프로세스가 커널 프로세스와 사용자 프로세스로 나뉘는 것 처럼,
    
    스레드 또한 **사용자 레벨, 커널 레벨 스레드** 두가지로 분류된다.
    
    - 사용자 스레드
        
        정의 : 라이브러리에 의해 구현되는 일반적인 스레드 ( 개발자가 만들어내는 스레드 )
        
        <br>

    - 커널 스레드
        
        정의 : 커널이 직접 생성하고 관리하는 스레드 ( 커널 기능 처리의 실행 흐름 )
        
    
    <br>

    >⇒ 사용자 스레드가 커널 스레드를 사용하려면 시스템 콜을 통해 커널 기능을 사용해야한다.
    
    >⇒ 이때 커널 스레드 - 사용자 스레드 간 대응 방식에 따라 멀티 스레드 모델이 구분된다.
    
    <br>

- 멀티 스레드 모델
    - 사용자 레벨 스레드
        - 1 to N 모델
        - 장점
            - 라이브러리가 직접 스케줄링하고 작업에 필요 처리를 하기에 문맥 교환이 필요 없다.
        - 단점
            - 여러 스레드가 하나의 커널 스레드와 연결되어 입출력과 같은 작업을 위해 대기 상태에 들어가게 되면 모든 사용자 스레드가 같이 대기하게 된다.
            - 한 프로세스의 타임슬라이스를 여러 스레드가 공유하기 때문에 여러개의 CPU를 동시 사용할 수 없다.
            
            <br>

    - 커널 레벨 스레드
        - 1 to 1 모델
        - 장점
            - 독립적으로 스케줄링이 되기 때문에 특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업을 계속할 수 있다.
            - 보안에 강하고 안정적 작동
        - 단점
            - 문맥 교환 시 오버헤드로 인해 느리게 작동
            
    - 멀티 레벨 스레드
        - 사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식
        - N to M 모델
        - 장점
            - 하나의 커널 스레드가 대기상태에 들어가면 다른 커널 스레드가 대신 작업하여 유연하게 작업 처리가 가능
        - 단점
            - 커널 레벨과 사용자 레벨을 같이 사용하기 때문에 여전히 문맥교환시 오버헤드가 있어 사용자 레벨 스레드보다 빠르지 않다.
<br>

        >빠르게 움직여야 하는 스레드는 사용자레벨 스레드로 동작하고, 안정적으로 동작하여야 하는 스레드는 커널 레벨 스레드로 작동한다.

<br>

**멀티 프로세스 & 멀티 스레드**

- 정의
    
    프로그램을 구현할 때 연산량 증가, 모듈화, 편의성 등의 이유로
    
    <br>

    **멀티 프로세스** 
    
    - 하나의 프로그램을 여러 개의 프로세스로 구성하여 하나의 작업을 하나의 프로세스가 처리하도록 하는것<br>

        - 장점
            - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에는 영향이 확산되지 않는다.
        - 단점
            - context switching 에서의 오버헤드
                - 프로세스는 각각의 독립된 메모리 영역을 할당 받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어
                    
                    >⇒  context switching이 발생하면 캐시에 있는 모든 데이터를 모두 리셋하고 다시 캐시에 정보를 불러와야 하는 오버헤드가 발생.
                    
            - 프로세스 사이의 어렵고 복잡한 통신 기법 (IPC)
                
                >⇒ 프로세스는 각각의 독립된 메모리 영역을 할당 받았기 때문에 프로세스들 사이의 변수를 공유할 수 없다.
                
                <br>
    
    **멀티 스레드**
    
    - 하나의 프로그램을 여러개의 스레드로 구성하여 하나의 작업을 하나의 스레드 가 처리하도록 하는 것
        - 장점
            - 시스템 자원 소모 감소 (자원의 효율성 증대)
                
                >⇒ 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
                
            - 시스템 처리량 증가 (처리 비용 감소)
                - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
                    
                    >⇒ 스레드간 공유를 통해 공유하는 자원 외의 것들에 대한 context switching의 비용이 줄어든다.
                    
            - 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
                - 스레드는 프로세스 내의 stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다
                
                <br>

        - 단점
            - 멀티 스레드의 경우 자원 공유의 문제가 발생한다. (동기화 문제)
            - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

<br>

* * *
<br>

## 동시성과 병렬성 & 블로킹과 논블로킹

### 동시성 & 병렬성

<details>
    <summary>동시성 & 병렬성</summary>

- 동시성 & 병렬성
    
    동시성과 병렬성은 큰개념으로 바라봐야한다
    
    >⇒ 즉 코어별 스레드 동작 방식으로 좁게 이해하면 안된다 큰 개념으로 여러 곳에서 사용되는 개념으로 알고있자.
    
    <br>
    
    **동시성 (Concurrency)**
    
    <img width="679" alt="스크린샷 2022-02-09 오후 3 46 12" src="https://user-images.githubusercontent.com/81874493/153136841-c89d4e53-d269-466d-b929-d01ddc815efd.png">

    정의 : 하나의 자원에서 독립적인 두 작업이 함께 처리되는것.
    
    ⇒ 즉 동시성의 초점은 하나의 자원에서 둘 이상의 작업을 할 수 있느냐 없느냐 이다. 
    
    - 예시
        - 마우스 입력, 키보드 입력, 화면 조정 등 여러 가지 일을 동시에 처리하기 위해 여러 스레드를 두고 context switching 하며 번갈아 작업한다
        - 싱글 코어에서 멀티 스레드가 동작
            
            ⇒ 싱글 코어에서 여러 스레드를 번갈아가며 처리한다.
            
    
    **병렬성 ( Parallelism )**
    
    <img width="661" alt="스크린샷 2022-02-09 오후 3 46 17" src="https://user-images.githubusercontent.com/81874493/153136852-0a0f2b23-b12a-4d1e-86b0-a64b1d9b3018.png">

    정의 :  물리적 동일 시간에 여러 작업이 함께 처리되는 것.
    
    ⇒ 하나의 자원에서 물리적 동일 시간내 여러 작업이 동시에 처리되는 것
    
    - 예시
        - 멀티 코어에서 멀티 스레드를 동작
            
            ⇒ 한 개 이상의 스레드를 포함하는 각 코어 들이 동시에 실행되는 성질을 말한다.
            
            ⇒ 멀티 코어에서 여러 스레드가 물리적 동일 시간에 작업 되어지는 것
            
    
    **동시성 vs 병렬성**
    
    | 동시성 | 병렬성 |
    | --- | --- |
    | 하나의 자원에서 독립적인 두 작업이 함께 처리되는것. | 물리적 동일 시간에 여러 작업이 처리 되는 것 |
    - 필충조건
        
        동시성은 병렬성 이기 위해 필요한 조건 이지만 충분조건은 아니다.
        
        - 병렬성을 만족하면, 동시성도 만족하게 된다.
        - 동시성을 만족한다고 병렬성을 만족하는 것은 아니다.
</details>  

<br>  


### 동기 비동기 & 블로킹 논블로킹

<details>
    <summary>동기 비동기 & 블로킹 논블로킹</summary>

- 동기 비동기 & 블로킹 논블로킹
    
    # 동기(Synchronous) vs 비동기(Asynchronous)
    
    동기와 비동기의 관심사
    
    - 동기/비동기의 관심사는 **작업 수행의 시간**에 있다
        - 여러개의 작업(Task)들이 서로 작업 시간을 맞춰 수행 되느냐, 되지 않느냐 에 따라 구분된다.
            - 서로 작업 시간을 맞춰 수행 : 동기
                
                ⇒ 즉 동기는 작업을 요청할때 작업이 완료 시간만 기다리는것
                
            - 서로 작업 시간과는 무관 : 비동기
                
                ⇒ 즉 비동기는 작업 요청시 작업이 언제끝나던 말던 관심 없고 자기일 하는것
                
    
    ## 동기 ( Synchronous)
    
    <img width="692" alt="스크린샷 2022-02-09 오후 3 50 48" src="https://user-images.githubusercontent.com/81874493/153137153-6176fb53-b1c8-437c-8d0e-29ef2e91df02.png">

    동기( Synchronous)는 직렬적으로 태스크(Task)를 수행
    
    ⇒ 즉 테스크는 순차적으로 실행되며 어떠한 작업이 수행 중이라면 다음 작업은 대기하게 되는 데이터의 처리 방식
    
    - 개념
        
        동기 작업이란 두 개 이상의 주체가 
        
        - 서로 동시에 작업을 수행
        - 서로 동시에 작업이 종료
        - 작업이 끝나는 동시에 작업이 시작할때
        
        <img width="687" alt="스크린샷 2022-02-09 오후 3 50 53" src="https://user-images.githubusercontent.com/81874493/153137208-925ffc09-87fd-4a82-85eb-082ea7c2d6c1.png">

        >⇒ 즉 서로 다른 주체가 하는 작업의 시작, 종료 작업에 관계가 있을때 
        
    
    <동기식 동작 코드>
    
    ```java
    public class synchro(){
    	public void main(String[] args){
    			method1();
    			method2();
    			method3();
    		}
    		
    		public static void method1(){
    			System.out.println("method1");
    		}
    		public static void method2(){
    			System.out.println("method2");
    		}
    		public static void method3(){
    			System.out.println("method3");
    		}
    	}
    
    // 결과
    /*
    method1
    method2
    method3
    */
    ```
    
    - 순차적으로 실행
    - 프로그램을 다시 시작해도 순서가 변하지 않는다.
    
    - 동기식 처리의 장점
        - 설계가 매우 간단하고 직관적이다.
    - 동기식 처리의 단점
        - 요청에 따른 결과가 반환되기 전까지 어떠한 작업도 못하고 대기해야 한다.
        
    
    >⇒ 동기식 처리에서는 요청에 따른 시간에 중점을 맞추고 있음
    
    >⇒ 다시 말해 동기식 처리는 요청한 함수가 끝나는 시간만 기다리고 있는것
    
    <br>

    ## 비동기식 처리 (Asynchronous)
    
    
    <img width="702" alt="스크린샷 2022-02-09 오후 3 50 59" src="https://user-images.githubusercontent.com/81874493/153137285-d3a3d1bc-4b2a-4837-9695-aed42b80cb6a.png">

    비동기 ( Asynchronous)는 병렬적으로 태스크(Task)를 수행
    
    ⇒ 즉 작업 수행중인 테스크가 완료되지 않더라도 다음 테스크를 실행시키는  데이터 처리 방식이다.
    
    - 개념
        
        비동기 작업이란 두 개 이상의 주체가 
        
        - 서로의 작업의 시작, 종료 시간과 관계가 없음
        - 별도의 작업 수행 시작/종료 시간을 가지고 있음
        
        <img width="680" alt="스크린샷 2022-02-09 오후 3 51 04" src="https://user-images.githubusercontent.com/81874493/153137253-d94574d2-db3f-4453-84c0-b6110fe77fcf.png">

        ⇒ 즉 서로 다른 주체가 하는 작업의 시작,종료 시간과 관계가 없을 때
        
    
    <비동기식 동작 코드>
    
    ⇒ 자바에서는 Multi Thread 동작이 비동기식으로 작동한다.
    
    ```java
    public class Asynch(){
    	public void main(String[] args){
    
    	Thread t1 = new Thread(()=>{
    		method1();
    	});
    
    	Thread t2 = new Thread(()=>{
    		method2();
    	});
    
    	Thread t3 = new Thread(()=>{
    		method3();
    	});
    
    	t1.start();
    	t2.start();
    	t3.start();
    
    	}
    	public static void method1() {
    		System.out.println("method1");
    	}
    	public static void method2() {
    		System.out.println("method2");
    	}
    	public static void method3() {
    		System.out.println("method3");
    	}
    }
    
    // 결과
    /*
    method3
    method1
    method2
    */
    ```
    
    - 각 메소드를 Thread 객체에 담아 Thread 실행 메소드 start를 통해 각 메소드를 실행
    - 처리 순서가 보장되지 않는다.
    - 참고) Java에서 Thread는 자바의 스레드 스케쥴러에 의해 제어된다.
    
    - 비동기식 처리의 장점
        - 요청에 따른 결과가 반환되는 동안 다른 작업을 수행 할 수 있어 자원을 효율적으로 사용할 수 있다..
    - 비동기식 처리의 단점
        - 동기식 처리보다 설계가 복잡하다.
        
    
    >⇒ 즉 비동기는 작업 요청시 작업이 언제끝나던 말던 관심 없고 자기일 하는것
    
    <br>

    # 블로킹(Blocking) vs 논브로킹(non-Blocking)
    
    주로 IO R/W 에서 블로킹과 논블로킹의 개념이 사용된다.
    
    블로킹과 논블로킹의 관심사
    
    - 블로킹/논블로킹의 관심사는 **한 작업이 처리되는 동안 다른 작업도 처리가 가능하냐** 에 있다
        - 블로킹/논블로킹의 구분은 ‘**제어권의 처리 방법**’으로 구분된다.
            - 다른 함수 호출시 제어권을 넘기고 작업완료시까지 대기 : 블로킹
            - 다른 함수 호출시 함수를 호출한 주체에게 제어권이 있어 다른 작업 진행이 가능 : 논블로킹

    <br>        
    
    ## 블로킹(Blocking)
    
    블로킹은 A함수에서 B함수를 호출 하였을 경우
    
    - A함수는 제어권을 B함수에게 넘긴다.
        - A함수는 제어권을 넘겼기 때문에 대기한다.
    - B함수가 실행되고 완료 되었을경우 리턴을 통해 제어권을 돌려준다.
    
    즉 블로킹은 다른 함수를 호출할 때, 제어권을 넘겨 작업이 완료된후 돌려받는 방식
    
    >⇒ 제어권을 돌려받기 전까지 작업을 진행 할 수 없다.
    
    <br>

    ## 논블로킹(non-Blocking)
    
    논블로킹은 A함수에서 B함수를 호출 하였을 경우
    
    - A함수는 제어권을 B함수에게 넘긴다.
        - B함수는 요청 작업을 즉시 마칠수 없다면 바로 return 한다.
            
            ⇒ 이후 B함수는 요청 작업 계속 진행
            
            ⇒ 완료시 콜백 함수를 통해 완료를 알림
            
    - A함수는 바로 제어권을 돌려받아 다른 작업을 진행한다.
    
    <br>

    ## 동기/비동기 & 블로킹/논블로킹 조합
    
    괜찮은 예시가 있음 읽어보기 추천!
    [동기 비동기 블로킹 논블로킹 조합 관련자료](https://cotak.tistory.com/136)

</details> 

<br>

**지금까지의 결론)**

위와 같이 여러 작업을 함께 처리하는 기술들을 통해 작업을 수행함에 따라

>⇒ 동일한 자원 접근에 대한 동시 접근 문제점이 발생한다.

<br>

## 경합(경쟁) 조건(Race condition)

**경합 (경쟁) 상태 (Race Condition)**

정의 : 공유 자원에 대해 여러 프로세스가 동시에 접근을 시도할 때, 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다.

<br>

>⇒ 즉 **두 가지 이상의 명령어 혹은 프로세스가 실행되는 순서를 명확하게**

>**정해주지 않아**서 어떤 명령어가 먼저 실행될 지 몰라 그 결과를 알 수 없게 되는 것이라는 뜻이다.

<br>

>⇒ 이로 인해 동시에 접근할 때 자료의 **`일관성`** 을 해치는 결과가 나타날 수 있다.

<br>

**경합 조건이 일어나는 조건!**

- 두 개 이상의 프로그램 혹은 쓰레드가 공통된 자원에 접근하여 읽기/쓰기 와 같은 작업이 일어날때!

<br>

**실생활 예시)**

사람 A,B가 동일한 계좌에 동시에 금액을 입금하는경우

- 작업 처리 단위
    1. 계좌 금액을 읽음
    2. 읽은 값에 입금 금액을 더함
    3. 계좌에 반영시킴

<br>

- 문제 상황 순서
    
    <계좌에 10만원이 존재>
    
    1. A가 계좌 금액을 읽음(10만원)
    2. B가 계좌 금액을 읽음(10만원)
    3. A가 10만원에 5만원을 더함
    4. B가 10만원에 3만원을 더함
    5. A가 계좌에 반영 시킴.
    6. B가 계좌에 반영 시킴.
    
    >⇒ 최종 계좌에 반영된 금액 → 13만원
    
    <br>

**경쟁 상태 발생 예시)**

- 커널 작업을 수행 중에 인터럽트가 발생 하여 동일 데이터를 조작할때
- 프로세스가 system call을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생하여 동일 데이터를 조작할 때,
- 멀티 프로세서에서 공유 메모리 내의 동일한 커널 데이터에 여러 프로세스가 접근할 때

<br>

* * *

<br>

## 공유 자원

그렇다면 위의 “경합조건”에서의 공유자원이 하나의 계좌인것 처럼

>⇒ 컴퓨터 분야에서 공유자원은 어떤게 될 수 있을까?

<br>

예시)

- 스레드간 공유 메모리
    
    ⇒ 한 프로세스내 여러 스레드는 메모리의 코드, 데이터 힙 영역을 공유하여 사용한다.
    
    ⇒ 스레드간 공유 자원 ( 메모리 ) 접근에 있어 동기화 문제가 있다.
    
    ⇒ ( 참고, 스레드는 독립적인 작업의 흐름이기에 각자의 스택과 PC(Program Counter)는 따로 할당된다.)
    
<br>

- 프린터 공유
    
    ⇒ 여러 사용자들이 하나의 프린터를 공유하여 사용한다.
    
    ⇒ 여러 사용자들의 문서가 프린터에서 뒤섞인다면 제대로 작동하지 않는다.
    
<br>

>⇒ 위와 같은 공유 자원을 사용함에 있어 늘 공유 자원 접근시에 문제가 뒤따른다.

<br>

* * *

<br>

## 임계 영역 ( Critical Section)


( 아래의 내용은 프로세스 뿐 아니라 스레드도 포함되는 내용 인지하자!)

**임계영역(Critical Section)**

정의 : 프로세스간 공유 자원 접근 하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 접근 할 수 있도록 보장 해주어야 하는 영역을 말한다.

<br>

**임계영역을 해결하기 위한 3가지 조건**

>⇒ 임계 영역을 문제를 해결 하기 위해 3가지 조건을 충족하여야 한다.

- 상호 배재 ( Mutual Exclusion )
    - 하나의 프로세스가 임계영역에 접근 하였을 경우 다른 프로세스는 접근할 수 없어야 한다.

<br>

- 진행 ( Progress )
    - 현재 이용하지 않는 임계영역에 접근하는 프로세스가 여러개라면 어떤 프로세스가 들어가야 할지 결정해주어야 한다.

<br>

- 한정 대기 ( Bounded Waiting )
    - 다른 프로세스의 기아(Starvation)현상을 방지하기 위해 임계영역에 들어간 프로세스는 다음 임계영역에 들어갈 때 제한을 두어야 한다.

<br>

**임계 영역 동시 접근 해결 방법**

- Lock
- Semaphore
- monitor
    
    .. 등이 있다. 

<br>

* * *

<br>

## 프로세스 동기화와 동기화로 인한문제


**프로세스 동기화**

정의 : 협력하는 프로세스 사이에서 실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것

>⇒ 다르게 말하면 동기화는 프로세스들이 서로 동작을 맞추고 정보를 공유하는 것을 의미

<br>

**동기화와 관련한 고전적인 문제**

✓ **은행 계좌 문제 (Back Account Problem)**

- 부모는 은행 계좌에 입금을 한다. 자식은 은행 계좌에서 출금한다.
- 입금과 출금 과정이 별도로 이루어져야 한다.
- **크리티컬 섹션** : 은행 계좌

<br>

✓ **식사하는 철학자 문제 (Dining Philosopher Problem)**

- 원형 테이블에 철학자들이 앉아있고 철학자의 수만큼 젓가락이 철학자 사이에 하나씩 놓여있다.
- 철학자들이 식사를 하기 위해서는 양쪽에 하나씩 놓여있는 젓가락을 둘 다 들어서 사용해야 한다.
- 어떤 철학자가 젓가락을 사용 중이라면, 다른 어떤 철학자는 식사를 할 수 없다.
- **크리티컬 섹션** : 젓가락

<br>

**동기화의 도구**

- 락(lock)
    
    동시에 공유 자원 접근 하는것을 막기 위해 임계 구역에 진입하는 프로세스는 Lock을 획득하고 임계구역을 빠져나올때, Lock을 방출함 으로서
    
    >⇒ 동시 접근 되지 않도록 적용하는 방법
    
    참고)
    - Spin Lock

         만약 **다른 스레드가 lock을 소유하고 있다면 그 lock이 반환될 때까지 계속 확인하며 기다리는 것**으로<br> "조금만 기다리면 바로 쓸 수 있는데 굳이 컨텍스트 스위칭으로 부하를 줄 필요가 있나?" 라는 컨셉으로 개발 되어<br> 크리티컬 섹션에 진입이 불가능할때 컨텍스트 스위칭을 하지 않고 잠시 루프를 돌면서 재시도 하는 것을 말한다. (busy wating 이라고도 불림 ) 

<br>

- 소프트웨어적 동기화
    - 알고리즘 이용
        - 피터슨의 알고리즘 (Peterson's Algorithm) : 피터슨의 해결안(Peterson's Solution)이라고도 하며, 2개의 프로세스만 있을 때 사용할 수 있다.
        
        <br>

        - 데커의 알고리즘 (Dekker's Algorithm) : 피터슨의 알고리즘과 비슷하며, 2개의 프로세스만 있을 때 사용할 수 있다.
        
        <br>

    - 세마포어
        
        **두개의 Atomic한 함수로 제어되는 정수 변수를 이용한 교착 상태 해법**
        
        <br>

        참고) 
        
        뮤텍스(Mutex)
            <br>
            **동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘**<br>
            [세마포어 뮤택스 예시](https://heeonii.tistory.com/14)
        
        

        <details>
        <summary>세마포어 vs 뮤택스</summary>
        - 세마포어 vs 뮤택스
            
            ### 차이점
            
            가장 큰 차이점은 동기화 대상의 개수 이다.
            
            - Mutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.
            - Mutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.
            - Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.
            - Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.
        </details>
    
    <br>
    
- 하드웨어적 동기화
    
    >⇒ 하드웨어적 동기화 방법은 하드웨어의 도움을 받아 두 명령어를 동시해 실행시키는 방식으로 진행된다.
    
    - Test And Set
        - 명령어는 동시성을 제어하기 위한 동기화 명령어 중 하나로서, 하드웨어의 도움을 받아 수행된다.
        - 한정 대기 조건을 만족하지 못하는 단점

<br>

### 동기화로 인해 발생하는 문제

- 교착상태 (Dead Lock)
    - 두 개 이상의 프로세스가 어떤 사건을 기다리고 있는데,
        
        같이 기다리는 프로세스 중 하나만이 그 사건을 발생시킬 수 있는 상황이다.
        
    - 교착상태 원인과 방지
        - 원인
            
            교착 상태는 공유자원과 이 자원을 함께 사용하는 프로세스나 스레드가 **아래의 4가지 조건을 모두 충족할 경우** 교착 상태가 발생한다.
            
            - 상호배제 : 공유 자원을 함께 사용할 수 없어 어느 한 프로세스가 독점적으로 사용 해야한다.
            - 점유 대기 : 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청한다.
            - 비선점 : 프로세스가 할당 받은 자원을 강제로 빼앗을 수 없다.
            - 순환 대기 : 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구한다.
            
            >⇒ 위의 4가지중 하나라도 충족되지 않으면 교착 상태가 발생하지 않는다.
            
            <br>

        - 방지
            - 자원을 상호 배제 하지 않고 언제든 공유할 수 있는 자원으로 만든다.
            - 어느 자원을 점유한 후 다른 자원을 요구하지 않고 한꺼번에 자원을 요구한다.
            - 선점형으로 바꾼다.
            - 자원 마다 우선순위를 부여해 모든 프로세스가 서로 정해진 순서대로 자원을 요구한다.
            
            <br>

- Starvation (기아) - Infinite Blocking (무한 대기)
    - 프로세스가 Sempahore Queue에서 무한히 대기하는 상황이다.
    
    <br>

- Priority Inversion (우선순위 역전)
    - 공유 자원에 대한 허가를 기다리는 동안 낮은 우선순위의 프로세스와 스케쥴링 순서가 뒤바뀌는 상황이다.
    
<br>

* * *

<br>




# 참고 자료

[프로세스 & 스레드 참고 자료](https://haedallog.tistory.com/138)

[임계영역 참고자료](https://hombody.tistory.com/240)

[프로세스 동기화 참고자료](https://rebas.kr/856)

[프로세스 동기화 참고자료](https://hombody.tistory.com/240)
