
## 03) 부하 분산

서버의 액세스가 증가할때?

- 서버로 통하는 회선을 빠르게 하는 방법
    
    ⇒ 하지만 서버의 처리 능력이 따라잡지 못할 수 있다.
    

이때 다수의 사용자가 집중적 액세스시 고성능의 기종을 사용하더라 해도 한대로 따라잡지 못한다

⇒ 이때는 복수 서버를 통해 처리를 분담하는 방법으로 서버 한대당의 처리량을 줄임 ⇒ 분산처리라고 한다.

분산처리 방식 

- 라운드 로빈
    - 여러대의 웹 서버를 설치하고 한대가 담당하는 사용자 수를 줄이는 방법
        - DNS 서버를 통해 분배
            
            <[www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) 와 매핑 되는 IP>
            
            - 192.0.2.60
            - 192.0.2.70
            - 192.0.2.80
            
            ⇒ DNS를 통해 IP 조회시 
            
            1. 첫번째 조회 응답 ( 192.0.2.60 , 192.0.2.70, 192.0.2.80 )
            2. 두번째 조회 응답 (  192.0.2.70, 192.0.2.80, 192.0.2.60 )
            3. 세번째 조회 응답 ( 192.0.2.80, 192.0.2.60, 192.0.2.70 )
                
                ⇒ 이후 1주기 순환후 원래대로 돌아가는 방식 == 라운드 로빈 방식
                
        - 결점
            - 웹 서버 중 고장난 웹 서버가 있을 때
                
                ⇒ DNS 서버는 웹서버의 상태를 알지 못하기 때문에 고장난 웹서버의 IP 반환을 한다.
                
                <br>

- 부하 분산 장치
    - 부하 분산 장치는 웹 서버가 아닌 DNS 서버에 등록한다
        
         ⇒ DNS서버에 IP에 해당하는 웹서버를 부하 분산 장치로 등록하여 분산 장치를 거치게 만든다
        
        <br>

    - 부하 분산 장치는 웹서버의 상태를 확인하여 요청을 분배한다
        - 대화가 복수의 페이지에 걸쳐있지 않은 경우
            - 단순한 액세스로 웹 서버의 부하 상태를 확인
                - 정기적 정보 교환으로 CPU나 메모리의 사용률 수집 하여 부하 웹 서버 판단
                - 시험 패킷을 보내어 응답 시간으로 부하 판단
                
                <br>

        - 대화가 복수의 페이지에 걸쳐있을 경우
            - 이전의 리퀘스트와 같은 웹서버에 전송해야 한다
                - HTTP 프로토콜 상 무상태 설계이기 때문에 전후 관계 판단이 어려움
                    
                    ⇒ 이를 판단하기 위해 HTTP헤더에 이에 대한 정보를 추가하여 전송해 요청할 웹서버를 판단한다.
                    

<br>

* * *

<br>

## 04) 캐시 서버

서버의 부하를 분산하는 방법 중 또 한가지 캐시

- 캐시
    - 웹 서버를 대신하여 미리 저장해 놓은 데이터를 클라이언트에게 반송하는 기능

<br>

- 캐시 서버
    - 프록시 구조를 사용하여 데이터를 캐시에 저장하는 서버
        
        ⇒ 프록시는 웹서버와 클라이언트 사이 웹서버에 액세스 동작을 중개하는 구조

<br>        

- 캐시 서버의 콘텐츠 관리
    1. DNS 서버에 캐시 서버를 등록하여 웹서버에 대한 요청을 대신 받는다.
    2. 받은 Request message 를 조사하여 자신의 캐시에 저장되어있는지 확인
        <br>

        - 캐시에 데이터 존재하는 경우
            
            1) 웹서버에게 ‘If-Modified-Since’ 헤더 필드를 추가하여 웹서버에 전송
            
            2) 웹 서버는 ‘If-Modified-Since’필드의 값 과 데이터 최종 갱신 일시를 비교하여 
            
            - 갱신일이 초과 되었을 경우 웹서버로 부터 갱신한 데이터를 받아 캐시에 데이터를 갱신하여 응답
            - 갱신일이 초과 되지 않았을 경우 캐시에 보관된 데이터를 클라이언트에게 응답
            
            <br>

        - 캐시에 데이터가 존재하지 않는경우
            
            1) 웹 서버에게 클라이언트 요청과 동일한 요청을 한다.
            
            2) 웹 서버로 부터 받은 데이터를 캐시에 저장한다.
            
            3) 웹 서버로 부터 받은 데이터를 클라이언트에게 응답한다.
            
<br>

* * *

<br>

## 05) 프록시

### **1. 프록시(Proxy)란?**

**프록시란?**

프록시의 사전적 의미는 ‘대신’, ‘대리’이다. 말 그대로 두 PC가 통신을 할 때 직접 하지 않고 중간에서 대리로 통신을 하는 것을 **‘프록시’**라고 하고, 중계 역할을 하는 것을 **‘프록시 서버’** 라고 부른다.

즉, 클라이언트와 서버 사이의 **‘중계 서버’**라고 생각하면 된다.

 프록시 서버는 보안 목적이나 캐싱 등의 기능을 제공한다.

프록시 서버가 중간에 위치함으로써 **클라이언트는 프록시 서버를 ‘서버’**라고 인식하고, **서버 입장에서는 프록시 서버를 ‘클라이언트’**로 인식하게 된다.

![https://user-images.githubusercontent.com/33229855/121799732-aa413f80-cc68-11eb-9268-5002f93d463f.png](https://user-images.githubusercontent.com/33229855/121799732-aa413f80-cc68-11eb-9268-5002f93d463f.png)

프록시 서버는 서버가 어디에 위치하느냐에 따라 **포워드 프록시**와 **백워드 프록시**로 나뉜다.

- 프록시의 종류
    - 포워드 프록시
        
        일반적으로 프록시라고 말하면 포워드 프록시를 말한다.
        
        클라이언트에서 서버로 리소스를 요청할 때 직접 요청하지 않고 프록시 서버를 거쳐서 요청한다. 이 경우 서버에서 받는 IP는 클라이언트의 IP가 아닌 프록시 서브의 IP이기 때문에 서버는 클라이언트가 누군지 알 수 없다. 즉, **서버에게 클라이언트가 누구인지 감춰주는 역할**을 한다.
        
        이러한 특징 때문에 **기업 사내망**에서 주로 사용된다.
        
        <br>

        ### **포워드 프록시의 특징/역할**
        
        - **캐싱** : 첫 번째 요청 이후부터는 동일한 요청이 들어올 경우, 프록시 서버에 캐싱된 내용을 전달해줌으로써 성능을 향상시킬 수 있다.
            
            웹 서비스에서 요청이 발생할 때마다 `1) 요청 → 2) 요청 전송 → 3) 요청 접수 → 4) 응답 생성 → 5) 응답 전송 → 6) 응답 수신` 과 같은 과정을 반복해서 거친다. 요청이 한 번 뿐일 때는 괜찮지만, 중복되는 요청을 매번 처리하기에는 심한 자원낭비가 생기고, 웹 서버의 부하가 증가 한다.
            
            이를 위해 포워드 프록시는 정적 데이터를 저장해두고 동일한 요청의 경우 웹서버 까지 가지 않고 포워드 프록시에서 처리할 수 있는 **캐싱 역할**을 수행한다.
            
        - **IP 우회** : 클라이언트 측에서 프록시 서버를 거쳐 웹 서비스를 이용할 경우, 서버 측에서는 요청을 받을 때 클라이언트의 IP가 아닌 프록시 서버의 IP를 전달받게 된다. 즉, 서버 측에 클라이언트의 정보를 숨길 수 있게 되는 것이다.
        - **제한** : 보안이 중요한 **사내망**에서 정해진 사이트에만 연결 할 수 있도록 설정하는 등 웹 사용 환경을 제한할 수 있다.
        
        ![https://user-images.githubusercontent.com/33229855/121800240-b24eae80-cc6b-11eb-811d-59634c440da7.png](https://user-images.githubusercontent.com/33229855/121800240-b24eae80-cc6b-11eb-811d-59634c440da7.png)
        
    
    <br>

    - 리버스 프록시
        
        리버스 프록시는 포워드 프록시와 반대 개념이다. 애플리케이션 서버의 앞에 위치하여 클라이언트가 서버를 요청할 때 리버스 프록시를 호출하고, 리버스 프록시가 서버로부터 응답을 전달받아 다시 클라이언트에게 전송하는 역할을 한다.
        
        이 경우, 클라이언트는 애플리케이션 서버를 직접 호출하는 것이 아니라 프록시 서버를 통해 호출하기 때문에 리버스 프록시는 애플리케이션 서버를 감추는 역할을 하게 된다.
        
        - **리버스 프록시의 예시** - NginX, Apache Web Server
        
        <br>

        ### **리버스 프록시의 특징/역할**
        
        - **로드밸런싱** : 리버스 프록시 뒤에 여러 개의 WAS를 둠으로써, 사용자 요청을 분산할 수 있다. End-point 마다 호출 서버를 설정할 수 있어 역할에 따라 서버의 트래픽을 분산할 수도 있다.
        - **보안** : 보안 상의 이유로 서버에 직접 접근하는 것을 막기 위해 DMZ같은 네트워크에 리버스 프록시를 구성하여 접근하도록 한다.
        
        ![https://user-images.githubusercontent.com/33229855/121800244-be3a7080-cc6b-11eb-9d57-c882395d3a95.png](https://user-images.githubusercontent.com/33229855/121800244-be3a7080-cc6b-11eb-9d57-c882395d3a95.png)
        
    
<br>

* * *

<br>


## 05) CDN

## CDN이란 무엇인가?

![https://media.vlpt.us/images/youngblue/post/f29d7267-0498-4319-b72d-f17b7944b243/99CE4C415BF2B5FB18.png](https://media.vlpt.us/images/youngblue/post/f29d7267-0498-4319-b72d-f17b7944b243/99CE4C415BF2B5FB18.png)

데이터 통신 기술이 발달하면서 전 세계적으로 유튜브, 넷플릭스 등 수 많은 데이터들이 전송되는 세상에 살고 있다. 이렇게 폭발적으로 증가하는 데이터를 최대한 지연 없이 효율적으로 전달하기 위해 CDN이라는 기술이 등장하게 된다.

**CDN은 Content Delivery Network의 약자로서 지리적인 제약 없이 전 세계 사용자에게 빠르고 안전하게 컨텐츠 전송을 할 수 있는 기술을 말한다. 이를 통해서 컨텐츠의 병목현상을 피할 수 있다.**

<br>

## CDN의 원리

CDN(Content Delivery Network)은 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하기 위해 고안된 기술이다. 만약 우리나라에 있는 사람이 미국에 있는 서버로부터 이미지나 파일 등을 다운받으려고 한다면 시간이 오래 걸릴 것이다.**따라서 서버를 분산시켜 캐싱해두고 사용자의 컨텐츠 요청이 들어오면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜 요청된 콘텐츠의 캐싱된 내용을 내어주는 방식으로 빠르게 데이터를 전송할 수 있게 된다.**만약 서버가 파일을 찾는데 실패하는 경우 CDN 플랫폼의 다른 서버에서 컨텐츠를 찾은다음 응답을 전송한다.

![https://media.vlpt.us/images/youngblue/post/3f7b945b-bf84-4f3f-9007-aa9c2f85c7ea/cdn.png](https://media.vlpt.us/images/youngblue/post/3f7b945b-bf84-4f3f-9007-aa9c2f85c7ea/cdn.png)

- 왼쪽 : CDN을 사용하지 않을 경우
- 오른쪽 : CDN을 사용할 경우

<br>

이때 CDN의 동작을 살펴보면 다음과 같은 규칙으로 수행된다.

1. 최초 요청은 서버로부터 컨텐츠를 가져와 고객에게 전송하며 동시에 CDN 캐싱장비에 저장한다.
2. 최초 요청 이후로의 요청은 CDN 에서 지정하는 해당 컨텐츠 만료 시점까지 캐싱된 컨텐츠를 전송한다.
3. 자주 사용하는 페이지에 한해서 캐싱되며, 해당 컨텐츠 호출이 없을 경우 주기적으로 삭제된다.
4. 서버가 파일을 찾는데 실패하는 경우 CDN 플랫폼의 다른 서버에서 컨텐츠를 찾은다음 엔드유저에게 응답을 전송한다.
5. 컨텐츠를 사용할 수 없거나 오래된 경우 CDN은 향후 요청에 대해 응답할 수 있도록 새로운 컨텐츠를 저장한다.

<br>

## CDN 캐싱 방식

### Static Caching

- Origin Server 에 있는 Content를 운영자가 미리 Cache Server에 복사 해두어 사용자가 Cache Server에 Content 요청 시 무조건 Cache Server에 있다
- 대부분의 국내 CDN에서 이 방식을 사용 (게임 클라이언트 다운로드 등)

<br>

### Dynamic Caching

- Origin Server에 있는 Content를 운영자가 미리 Cache Server에 복사하지 않음
- 사용자가 Content를 요청 시 해당 Content가 없는 경우 Origin Server로부터 다운로드 받아 전달한다. 있는 경우에는 캐싱된 Content전달
- 각각의 Content는 일정 시간 이후 Cache Server에서 삭제 될 수도 있다.

<br>

## 활용 사례

- 온라인 게임의 오픈 베타테스트나 정식서비스 시작시점에 클라이언트의 다운로드 수요가 급격하게 증가한다 이럴 경우 병목 현상이 일어나거나 심한 경우 서버가 다운 되기도 하기 때문에 CDN이 필수적으로 사용된다. 또한 대규모 업데이트를 위한 패치가 있을 경우에도 병목 현상을 막기 위해 CDN을 사용한다
- 넷플릭스(Netflix)에서는 온라인 동영상 스트리밍 서비스를 전세계로 제공하는 업체로서 최대한 지연 없이 안정적이고 빠르게 컨텐츠를 제공하기 위해서는 CDN 기술이 필수적이다.